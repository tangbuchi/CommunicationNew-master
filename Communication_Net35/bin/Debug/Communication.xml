<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Communication</name>
    </assembly>
    <members>
        <member name="T:Communication.Algorithms.ConnectPool.ConnectPool`1">
            <summary>
            一个连接池管理器，负责维护多个可用的连接，并且自动清理，扩容
            </summary>
            <typeparam name="TConnector">管理的连接类，需要支持IConnector接口</typeparam>
            <remarks>
            需要先实现 <see cref="T:Communication.Algorithms.ConnectPool.IConnector"/> 接口的对象，然后就可以实现真正的连接池了，理论上可以实现任意的连接对象，包括modbus连接对象，各种PLC连接对象，数据库连接对象，redis连接对象，SimplifyNet连接对象等等。下面的示例就是modbus-tcp的实现
            <note type="warning">要想真正的支持连接池访问，还需要服务器支持一个端口的多连接操作，三菱PLC的端口就不支持，如果要测试示例代码的连接池对象，需要使用本组件的<see cref="T:Communication.ModBus.ModbusTcpServer"/>来创建服务器对象</note>
            </remarks>
            <example>
            下面举例实现一个modbus的连接池对象，先实现接口化的操作
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="IConnector Example" title="IConnector示例" />
            然后就可以实现真正的连接池了
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="ConnectPoolExample" title="ConnectPool示例" />
            </example>
        </member>
        <member name="M:Communication.Algorithms.ConnectPool.ConnectPool`1.#ctor(System.Func{`0})">
            <summary>
            实例化一个连接池对象，需要指定如果创建新实例的方法
            </summary>
            <param name="createConnector">创建连接对象的委托</param>
        </member>
        <member name="M:Communication.Algorithms.ConnectPool.ConnectPool`1.GetAvailableConnector">
            <summary>
            获取可用的对象
            </summary>
            <returns>可用的连接对象</returns>
        </member>
        <member name="M:Communication.Algorithms.ConnectPool.ConnectPool`1.ReturnConnector(`0)">
            <summary>
            使用完之后需要通知管理器
            </summary>
            <param name="connector">连接对象</param>
        </member>
        <member name="P:Communication.Algorithms.ConnectPool.ConnectPool`1.MaxConnector">
            <summary>
            获取或设置最大的连接数
            </summary>
        </member>
        <member name="P:Communication.Algorithms.ConnectPool.ConnectPool`1.ConectionExpireTime">
            <summary>
            获取或设置连接过期的时间，单位秒，默认30秒
            </summary>
        </member>
        <member name="P:Communication.Algorithms.ConnectPool.ConnectPool`1.UsedConnector">
            <summary>
            当前已经使用的连接数
            </summary>
        </member>
        <member name="T:Communication.Algorithms.ConnectPool.IConnector">
            <summary>
            连接池的接口，连接池的管理对象必须实现此接口
            </summary>
            <remarks>为了使用完整的连接池功能，需要先实现本接口，然后配合<see cref="T:Communication.Algorithms.ConnectPool.ConnectPool`1"/>来使用</remarks>
            <example>
            下面举例实现一个modbus的连接池对象
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="IConnector Example" title="IConnector示例" />
            </example>
        </member>
        <member name="P:Communication.Algorithms.ConnectPool.IConnector.IsConnectUsing">
            <summary>
            指示当前的连接是否在使用用
            </summary>
        </member>
        <member name="P:Communication.Algorithms.ConnectPool.IConnector.GuidToken">
            <summary>
            唯一的GUID码
            </summary>
        </member>
        <member name="P:Communication.Algorithms.ConnectPool.IConnector.LastUseTime">
            <summary>
            最新一次使用的时间
            </summary>
        </member>
        <member name="M:Communication.Algorithms.ConnectPool.IConnector.Open">
            <summary>
            打开连接
            </summary>
        </member>
        <member name="M:Communication.Algorithms.ConnectPool.IConnector.Close">
            <summary>
            关闭并释放
            </summary>
        </member>
        <member name="T:Communication.Algorithms.Fourier.FFTHelper">
            <summary>
            离散傅氏变换的快速算法，处理的信号，适合单周期信号数为2的N次方个，支持变换及逆变换
            </summary>
        </member>
        <member name="M:Communication.Algorithms.Fourier.FFTHelper.bitrp(System.Double[],System.Double[],System.Int32)">
            <summary>
            
            </summary>
            <param name="xreal"></param>
            <param name="ximag"></param>
            <param name="n"></param>
        </member>
        <member name="M:Communication.Algorithms.Fourier.FFTHelper.FFT(System.Double[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:Communication.Algorithms.Fourier.FFTHelper.GetFFTImage(System.Double[],System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            获取FFT变换后的显示图形，需要指定图形的相关参数
            </summary>
            <param name="xreal">实数部分的值</param>
            <param name="width">图形的宽度</param>
            <param name="heigh">图形的高度</param>
            <param name="lineColor">线条颜色</param>
            <returns>等待呈现的图形</returns>
            <remarks>
            <note type="warning">.net standrard2.0 下不支持。</note>
            </remarks>
        </member>
        <member name="M:Communication.Algorithms.Fourier.FFTHelper.FFT(System.Double[],System.Double[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:Communication.Algorithms.Fourier.FFTHelper.IFFT(System.Double[],System.Double[])">
            <summary>
            快速傅立叶变换的逆变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>2的多少次方</returns>
        </member>
        <member name="T:Communication.BasicFramework.FormAuthorAdvertisement">
            <summary>
            显示作者一些信息的类，应当在软件系统中提供一处链接显示原作者信息，或者以彩蛋方式实现
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormAuthorAdvertisement.#ctor">
            <summary>
            实例化一个窗口，显示作者的相关信息
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.FormAuthorAdvertisement.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormAuthorAdvertisement.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Communication.BasicFramework.FormAuthorAdvertisement.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.FormAuthorize">
            <summary>
            用来测试版软件授权的窗口
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormAuthorize.#ctor(Communication.BasicFramework.SoftAuthorize,System.String,System.Func{System.String,System.String})">
            <summary>
            实例化授权注册窗口
            </summary>
            <param name="authorize"></param>
            <param name="aboutCode">提示关于怎么获取注册码的信息</param>
            <param name="encrypt">加密的方法</param>
        </member>
        <member name="F:Communication.BasicFramework.FormAuthorize.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormAuthorize.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Communication.BasicFramework.FormAuthorize.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.FormPopup">
            <summary>
            一个用于消息弹出显示的类
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.AddNewForm(Communication.BasicFramework.FormPopup)">
            <summary>
            新增一个显示的弹出窗口
            </summary>
            <param name="form"></param>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.ResetLocation">
            <summary>
            重置所有弹出窗口的位置
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.#ctor">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.#ctor(System.String)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.#ctor(System.String,System.Drawing.Color)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
            <param name="infocolor">文本的颜色</param>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.#ctor(System.String,System.Drawing.Color,System.Int32)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
            <param name="infocolor">文本的颜色</param>
            <param name="existTime">指定窗口多少时间后消失，单位毫秒</param>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.LocationUpMove">
            <summary>
            窗体的位置进行向上调整
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.LocationUpMove(System.Int32)">
            <summary>
            窗体的位置进行向上调整
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.FormPopup.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Communication.BasicFramework.FormPopup.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.FormPortraitSelect">
            <summary>
            一个正方形图形选择窗口，可以获取指定的分辨率
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPortraitSelect.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.FormPortraitSelect.HasPicture">
            <summary>
            是否有图片存在
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.FormPortraitSelect.RectangleSelected">
            <summary>
            已选择的图形大小
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.FormPortraitSelect.RectangleImage">
            <summary>
            在控件显示的图片的大小，按照比例缩放以后
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPortraitSelect.LoadPictureFile(System.String)">
            <summary>
            增加一张图片的路径
            </summary>
            <param name="picPath"></param>
        </member>
        <member name="M:Communication.BasicFramework.FormPortraitSelect.GetSpecifiedSizeImage(System.Int32)">
            <summary>
            获取指定大小的图片，该图片将会按照比例压缩
            </summary>
            <param name="size">图片的横向分辨率</param>
            <returns>缩放后的图形</returns>
        </member>
        <member name="F:Communication.BasicFramework.FormPortraitSelect.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormPortraitSelect.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Communication.BasicFramework.FormPortraitSelect.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.FormSupport">
            <summary>
            作者的技术支持的窗口界面
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormSupport.#ctor">
            <summary>
            实例化一个默认的界面
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.FormSupport.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.FormSupport.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Communication.BasicFramework.FormSupport.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SharpList`1">
            <summary>
            一个高效的数组管理类，用于高效控制固定长度的数组实现
            </summary>
            <typeparam name="T">泛型类型</typeparam>
        </member>
        <member name="M:Communication.BasicFramework.SharpList`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            实例化一个对象，需要指定数组的最大数据对象
            </summary>
            <param name="count">数据的个数</param>
            <param name="appendLast">是否从最后一个数添加</param>
        </member>
        <member name="P:Communication.BasicFramework.SharpList`1.Count">
            <summary>
            获取数据的个数
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SharpList`1.Add(`0)">
            <summary>
            新增一个数据值
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:Communication.BasicFramework.SharpList`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            批量的增加数据
            </summary>
            <param name="values">批量数据信息</param>
        </member>
        <member name="M:Communication.BasicFramework.SharpList`1.ToArray">
            <summary>
            获取数据的数组值
            </summary>
            <returns>数组值</returns>
        </member>
        <member name="P:Communication.BasicFramework.SharpList`1.Item(System.Int32)">
            <summary>
            获取或设置指定索引的位置的数据
            </summary>
            <param name="index">索引位置</param>
            <returns>数据值</returns>
        </member>
        <member name="T:Communication.BasicFramework.SoftAnimation">
            <summary>
            系统框架支持的一些常用的动画特效
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftAnimation.TimeFragment">
            <summary>
            最小的时间片段
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftAnimation.BeginBackcolorAnimation(System.Windows.Forms.Control,System.Drawing.Color,System.Int32)">
            <summary>
            调整控件背景色，采用了线性的颜色插补方式，实现了控件的背景色渐变，需要指定控件，颜色，以及渐变的时间
            </summary>
            <param name="control">控件</param>
            <param name="color">设置的颜色</param>
            <param name="time">时间</param>
        </member>
        <member name="T:Communication.BasicFramework.SoftAuthorize">
            <summary>
            软件授权类
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.#ctor(System.Boolean)">
            <summary>
            实例化一个软件授权类
            </summary>
            <param name="UseAdmin">是否使用管理员模式</param>
        </member>
        <member name="F:Communication.BasicFramework.SoftAuthorize.TextCode">
            <summary>
            注册码描述文本
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftAuthorize.FinalCode">
            <summary>
            最终的注册秘钥信息，注意是只读的。
            </summary>
            <remarks>
            时间：2018年9月1日 23:01:54，来自 洛阳-LYG 的建议，公开了本属性信息，只读。
            </remarks>
        </member>
        <member name="P:Communication.BasicFramework.SoftAuthorize.IsReleaseVersion">
            <summary>
            是否正式发行版，是的话就取消授权
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftAuthorize.HasLoadByFile">
            <summary>
            指示是否加载过文件信息
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftAuthorize.IsSoftTrial">
            <summary>
            指示系统是否处于试用运行
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.GetMachineCodeString">
            <summary>
            获取本机的机器码
            </summary>
            <returns>机器码字符串</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.ToSaveString">
            <summary>
            获取需要保存的数据内容
            </summary>
            <returns>实际保存的内容</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.LoadByString(System.String)">
            <summary>
            从字符串加载数据
            </summary>
            <param name="content">文件存储的数据</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.SaveToFile">
            <summary>
            使用特殊加密算法加密数据
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.LoadByFile">
            <summary>
            使用特殊解密算法解密数据
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.CheckAuthorize(System.String,System.Func{System.String,System.String})">
            <summary>
            检查该注册码是否是正确的注册码
            </summary>
            <param name="code">注册码信息</param>
            <param name="encrypt">数据加密的方法，必须用户指定</param>
            <returns>是否注册成功</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.IsAuthorizeSuccess(System.Func{System.String,System.String})">
            <summary>
            检测授权是否成功
            </summary>
            <param name="encrypt">数据加密的方法，必须用户指定</param>
            <returns>是否成功授权</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.GetInfo(System.Boolean)">
            <summary>
            获取本计算机唯一的机器码  
            </summary>
            <returns>字符串形式的机器码</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.GetHddInfo(System.Byte)">
            <summary>
            获得硬盘信息
            </summary>
            <param name="driveIndex">硬盘序号</param>
            <returns>硬盘信息</returns>
            <remarks>
            by sunmast for everyone
            thanks lu0 for his great works
            在Windows Array8/ME中，S.M.A.R.T并不缺省安装，请将SMARTVSD.VXD拷贝到%SYSTEM%＼IOSUBSYS目录下。
            在Windows 2000/2003下，需要Administrators组的权限。
            </remarks>
            <example>
            AtapiDevice.GetHddInfo()
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.CreateFile(System.String,System.IO.FileAccess,System.IO.FileShare,System.IntPtr,System.IO.FileMode,System.IO.FileAttributes,System.IntPtr)">
            <summary>
            执行打开/建立资源的功能。
            </summary>
            <param name="lpFileName">指定要打开的设备或文件的名称。</param>
            <param name="dwDesiredAccess">
            <para>Win32 常量，用于控制对设备的读访问、写访问或读/写访问的常数。内容如下表：
            <p><list type="table">
            <listheader>
            <term>名称</term>
            <description>说明</description>
            </listheader>
            <item>
            <term>GENERIC_READ</term><description>指定对设备进行读取访问。</description>
            </item>
            <item>
            <term>GENERIC_WRITE</term><description>指定对设备进行写访问。</description>
            </item>
            <item><term><b>0</b></term><description>如果值为零，则表示只允许获取与一个设备有关的信息。</description></item>
            </list></p>
            </para>
            </param>
            <param name="dwShareMode">指定打开设备时的文件共享模式</param>
            <param name="lpSecurityAttributes"></param>
            <param name="dwCreationDisposition">Win32 常量，指定操作系统打开文件的方式。内容如下表：
            <para><p>
            <list type="table">
            <listheader><term>名称</term><description>说明</description></listheader>
            <item>
            <term>CREATE_NEW</term>
            <description>指定操作系统应创建新文件。如果文件存在，则抛出 <see cref="T:System.IO.IOException"/> 异常。</description>
            </item>
            <item><term>CREATE_ALWAYS</term><description>指定操作系统应创建新文件。如果文件已存在，它将被改写。</description></item>
            </list>
            </p></para>
            </param>
            <param name="dwFlagsAndAttributes"></param>
            <param name="hTemplateFile"></param>
            <returns>使用函数打开的设备的句柄。</returns>
            <remarks>
            本函数可以执行打开或建立文件、文件流、目录/文件夹、物理磁盘、卷、系统控制的缓冲区、磁带设备、
            通信资源、邮件系统和命名管道。
            </remarks>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.CloseHandle(System.IntPtr)">
            <summary>
            关闭一个指定的指针对象指向的设备。。
            </summary>
            <param name="hObject">要关闭的句柄 <see cref="T:System.IntPtr"/> 对象。</param>
            <returns>成功返回 <b>0</b> ，不成功返回非零值。</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.DeviceIoControl(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,Communication.BasicFramework.SoftAuthorize.GetVersionOutParams@,System.UInt32,System.UInt32@,System.IntPtr)">
            <summary>
            对设备执行指定的操作。
            </summary>
            <param name="hDevice">要执行操作的设备句柄。</param>
            <param name="dwIoControlCode">Win32 API 常数，输入的是以 <b>FSCTL_</b> 为前缀的常数，定义在
            <b>WinIoCtl.h</b> 文件内，执行此重载方法必须输入 <b>SMART_GET_VERSION</b> 。</param>
            <param name="lpInBuffer">当参数为指针时，默认的输入值是 <b>0</b> 。</param>
            <param name="nInBufferSize">输入缓冲区的字节数量。</param>
            <param name="lpOutBuffer">一个 <b>GetVersionOutParams</b> ，表示执行函数后输出的设备检查。</param>
            <param name="nOutBufferSize">输出缓冲区的字节数量。</param>
            <param name="lpBytesReturned">实际装载到输出缓冲区的字节数量。</param>
            <param name="lpOverlapped">同步操作控制，一般不使用，默认值为 <b>0</b> 。</param>
            <returns>非零表示成功，零表示失败。</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftAuthorize.DeviceIoControl(System.IntPtr,System.UInt32,Communication.BasicFramework.SoftAuthorize.SendCmdInParams@,System.UInt32,Communication.BasicFramework.SoftAuthorize.SendCmdOutParams@,System.UInt32,System.UInt32@,System.IntPtr)">
            <summary>
            对设备执行指定的操作。
            </summary>
            <param name="hDevice">要执行操作的设备句柄。</param>
            <param name="dwIoControlCode">Win32 API 常数，输入的是以 <b>FSCTL_</b> 为前缀的常数，定义在
            <b>WinIoCtl.h</b> 文件内，执行此重载方法必须输入 <b>SMART_SEND_DRIVE_COMMAND</b> 或 <b>SMART_RCV_DRIVE_DATA</b> 。</param>
            <param name="lpInBuffer">一个 <b>SendCmdInParams</b> 结构，它保存向系统发送的查询要求具体命令的数据结构。</param>
            <param name="nInBufferSize">输入缓冲区的字节数量。</param>
            <param name="lpOutBuffer">一个 <b>SendCmdOutParams</b> 结构，它保存系统根据命令返回的设备相信信息二进制数据。</param>
            <param name="nOutBufferSize">输出缓冲区的字节数量。</param>
            <param name="lpBytesReturned">实际装载到输出缓冲区的字节数量。</param>
            <param name="lpOverlapped">同步操作控制，一般不使用，默认值为 <b>0</b> 。</param>
            <returns>非零表示成功，零表示失败。</returns>
        </member>
        <member name="F:Communication.BasicFramework.SoftAuthorize.HardDiskInfo.ModuleNumber">
            <summary>
            型号
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftAuthorize.HardDiskInfo.Firmware">
            <summary>
            固件版本
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftAuthorize.HardDiskInfo.SerialNumber">
            <summary>
            序列号
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftAuthorize.HardDiskInfo.Capacity">
            <summary>
            容量，以M为单位
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.ISoftFileSaveBase">
            <summary>
            支持字符串信息加载存储的接口，定义了几个通用的方法
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.ISoftFileSaveBase.ToSaveString">
            <summary>
            获取需要保存的数据，需要重写实现
            </summary>
            <returns>需要存储的信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.ISoftFileSaveBase.LoadByString(System.String)">
            <summary>
            从字符串加载数据，需要重写实现
            </summary>
            <param name="content">字符串数据</param>
        </member>
        <member name="M:Communication.BasicFramework.ISoftFileSaveBase.LoadByFile">
            <summary>
            不使用解密方法从文件读取数据
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.ISoftFileSaveBase.SaveToFile">
            <summary>
            不使用加密方法保存数据到文件
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.ISoftFileSaveBase.FileSavePath">
            <summary>
            文件路径的存储
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SoftFileSaveBase">
            <summary>
            文件存储功能的基类，包含了文件存储路径，存储方法等
            </summary>
            <remarks>
            需要继承才能实现你想存储的数据，比较经典的例子就是存储你的应用程序的配置信息，通常的格式就是xml文件或是json文件。具体请看例子：
            </remarks>
            <example>
            下面举例实现两个字段的普通数据存储
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="SoftFileSaveBase1" title="简单示例" />
            然后怎么调用呢？
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="Example" title="调用示例" />
            如果你想实现加密存储，这样就不用关心被用户看到了。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="SoftFileSaveBase2" title="加密示例" />
            如果还是担心被反编译获取数据，那么这个密钥就要来自服务器的数据，本地不做存储。
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftFileSaveBase.#ctor">
            <summary>
            实例化一个文件存储的基类
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftFileSaveBase.LogHeaderText">
            <summary>
            在日志保存时的标记当前调用类的信息
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftFileSaveBase.ToSaveString">
            <summary>
            获取需要保存的数据，需要重写实现
            </summary>
            <returns>需要存储的信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftFileSaveBase.LoadByString(System.String)">
            <summary>
            从字符串加载数据，需要重写实现
            </summary>
            <param name="content">字符串数据</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftFileSaveBase.LoadByFile">
            <summary>
            不使用解密方法从文件读取数据
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftFileSaveBase.LoadByFile(System.Converter{System.String,System.String})">
            <summary>
            使用用户自定义的解密方法从文件读取数据
            </summary>
            <param name="decrypt">用户自定义的解密方法</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftFileSaveBase.SaveToFile">
            <summary>
            不使用加密方法保存数据到文件
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftFileSaveBase.SaveToFile(System.Converter{System.String,System.String})">
            <summary>
            使用用户自定义的加密方法保存数据到文件
            </summary>
            <param name="encrypt">用户自定义的加密方法</param>
        </member>
        <member name="P:Communication.BasicFramework.SoftFileSaveBase.FileSavePath">
            <summary>
            文件存储的路径
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftFileSaveBase.ILogNet">
            <summary>
            日志记录类
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SoftBasic">
            <summary>
            一个软件基础类，提供常用的一些静态方法 ->
            A software-based class that provides some common static methods
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.CalculateFileMD5(System.String)">
            <summary>
            获取文件的md5码 -> Get the MD5 code of the file
            </summary>
            <param name="filePath">文件的路径，既可以是完整的路径，也可以是相对的路径 -> The path to the file</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个文件的md5码
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateFileMD5Example" title="CalculateFileMD5示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.CalculateStreamMD5(System.IO.Stream)">
            <summary>
            获取数据流的md5码 -> Get the MD5 code for the data stream
            </summary>
            <param name="stream">数据流，可以是内存流，也可以是文件流</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个流的md5码
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateStreamMD5Example1" title="CalculateStreamMD5示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.CalculateStreamMD5(System.String)">
            <summary>
            获取文本字符串信息的Md5码，编码为UTF8
            </summary>
            <param name="data">文本数据信息</param>
            <returns>Md5字符串</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.CalculateStreamMD5(System.String,System.Text.Encoding)">
            <summary>
            获取文本字符串信息的Md5码，使用指定的编码
            </summary>
            <param name="data">文本数据信息</param>
            <param name="encode">编码信息</param>
            <returns>Md5字符串</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.CalculateStreamMD5(System.Drawing.Bitmap)">
            <summary>
            获取内存图片的md5码 -> Get the MD5 code of the memory picture
            </summary>
            <param name="bitmap">内存图片</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个图像的md5码
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateStreamMD5Example2" title="CalculateStreamMD5示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetSizeDescription(System.Int64)">
            <summary>
            从一个字节大小返回带单位的描述
            </summary>
            <param name="size">实际的大小值</param>
            <returns>最终的字符串值</returns>
            <example>
            比如说我们获取了文件的长度，这个长度可以来自于本地，也可以来自于数据库查询
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetSizeDescriptionExample" title="GetSizeDescription示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetTimeSpanDescription(System.TimeSpan)">
            <summary>
            从一个时间差返回带单位的描述
            </summary>
            <param name="ts">实际的时间差</param>
            <returns>最终的字符串值</returns>
            <example>
            比如说我们获取了一个时间差信息
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetTimeSpanDescriptionExample" title="GetTimeSpanDescription示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.AddArrayData``1(``0[]@,``0[],System.Int32)">
            <summary>
            一个通用的数组新增个数方法，会自动判断越界情况，越界的情况下，会自动的截断或是填充 -> 
            A common array of new methods, will automatically determine the cross-border situation, in the case of cross-border, will be automatically truncated or filled
            </summary>
            <typeparam name="T">数据类型</typeparam>
            <param name="array">原数据</param>
            <param name="data">等待新增的数据</param>
            <param name="max">原数据的最大值</param>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="AddArrayDataExample" title="AddArrayData示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ArrayExpandToLength``1(``0[],System.Int32)">
            <summary>
            将一个数组进行扩充到指定长度，或是缩短到指定长度 ->
            Extend an array to a specified length, or shorten to a specified length or fill
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="data">原先数据的数据</param>
            <param name="length">新数组的长度</param>
            <returns>新数组长度信息</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayExpandToLengthExample" title="ArrayExpandToLength示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ArrayExpandToLengthEven``1(``0[])">
            <summary>
            将一个数组进行扩充到偶数长度 ->
            Extend an array to even lengths
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="data">原先数据的数据</param>
            <returns>新数组长度信息</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayExpandToLengthEvenExample" title="ArrayExpandToLengthEven示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.IsTwoBytesEquel(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            判断两个字节的指定部分是否相同 ->
            Determines whether the specified portion of a two-byte is the same
            </summary>
            <param name="b1">第一个字节</param>
            <param name="start1">第一个字节的起始位置</param>
            <param name="b2">第二个字节</param>
            <param name="start2">第二个字节的起始位置</param>
            <param name="length">校验的长度</param>
            <returns>返回是否相等</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoBytesEquelExample1" title="IsTwoBytesEquel示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.IsTwoBytesEquel(System.Byte[],System.Byte[])">
            <summary>
            判断两个字节的指定部分是否相同 ->
            Determines whether the specified portion of a two-byte is the same
            </summary>
            <param name="b1">第一个字节</param>
            <param name="b2">第二个字节</param>
            <returns>返回是否相等</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoBytesEquelExample2" title="IsTwoBytesEquel示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.IsByteTokenEquel(System.Byte[],System.Guid)">
            <summary>
            判断两个数据的令牌是否相等 ->
            Determines whether the tokens of two data are equal
            </summary>
            <param name="head">字节数据</param>
            <param name="token">GUID数据</param>
            <returns>返回是否相等</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoTokenEquelExample" title="IsByteTokenEquel示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.IsTwoTokenEquel(System.Guid,System.Guid)">
            <summary>
            判断两个数据的令牌是否相等 ->
            Determines whether the tokens of two data are equal
            </summary>
            <param name="token1">第一个令牌</param>
            <param name="token2">第二个令牌</param>
            <returns>返回是否相等</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetEnumValues``1">
            <summary>
            获取一个枚举类型的所有枚举值，可直接应用于组合框数据 ->
            Gets all the enumeration values of an enumeration type that can be applied directly to the combo box data
            </summary>
            <typeparam name="TEnum">枚举的类型值</typeparam>
            <returns>枚举值数组</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetEnumValuesExample" title="GetEnumValues示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetEnumFromString``1(System.String)">
            <summary>
            从字符串的枚举值数据转换成真实的枚举值数据 ->
            Convert enumeration value data from strings to real enumeration value data
            </summary>
            <typeparam name="TEnum">枚举的类型值</typeparam>
            <param name="value">枚举的字符串的数据值</param>
            <returns>真实的枚举值</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetEnumFromStringExample" title="GetEnumFromString示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetValueFromJsonObject``1(Newtonsoft.Json.Linq.JObject,System.String,``0)">
            <summary>
            一个泛型方法，提供json对象的数据读取 ->
            A generic method that provides data read for a JSON object
            </summary>
            <typeparam name="T">读取的泛型</typeparam>
            <param name="json">json对象</param>
            <param name="value_name">值名称</param>
            <param name="default_value">默认值</param>
            <returns>值对象</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetValueFromJsonObjectExample" title="GetValueFromJsonObject示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.JsonSetValue``1(Newtonsoft.Json.Linq.JObject,System.String,``0)">
            <summary>
            一个泛型方法，提供json对象的数据写入 ->
            A generic method that provides data writing to a JSON object
            </summary>
            <typeparam name="T">写入的泛型</typeparam>
            <param name="json">json对象</param>
            <param name="property">值名称</param>
            <param name="value">值数据</param>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="JsonSetValueExample" title="JsonSetValue示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ShowExceptionMessage(System.Exception)">
            <summary>
            显示一个完整的错误信息 ->
            Displays a complete error message
            </summary>
            <param name="ex">异常对象</param>
            <remarks>调用本方法可以显示一个异常的详细信息</remarks>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ShowExceptionMessage(System.String,System.Exception)">
            <summary>
            显示一个完整的错误信息，和额外的字符串描述信息 ->
            Displays a complete error message, and additional string description information
            </summary>
            <param name="extraMsg">额外的描述信息</param>
            <remarks>调用本方法可以显示一个异常的详细信息</remarks>
            <param name="ex">异常对象</param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetExceptionMessage(System.Exception)">
            <summary>
            获取一个异常的完整错误信息 ->
            Gets the complete error message for an exception
            </summary>
            <param name="ex">异常对象</param>
            <returns>完整的字符串数据</returns>
            <remarks>获取异常的完整信息</remarks>
            <exception cref="T:System.NullReferenceException">ex不能为空</exception>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetExceptionMessageExample1" title="GetExceptionMessage示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetExceptionMessage(System.String,System.Exception)">
            <summary>
            获取一个异常的完整错误信息，和额外的字符串描述信息 ->
            Gets the complete error message for an exception, and additional string description information
            </summary>
            <param name="extraMsg">额外的信息</param>
            <param name="ex">异常对象</param>
            <returns>完整的字符串数据</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetExceptionMessageExample2" title="GetExceptionMessage示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[])">
            <summary>
            字节数据转化成16进制表示的字符串 ->
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <returns>返回的字符串</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample1" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char)">
            <summary>
            字节数据转化成16进制表示的字符串 ->
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <param name="segment">分割符</param>
            <returns>返回的字符串</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample2" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ByteToHexString(System.String)">
            <summary>
            字符串数据转化成16进制表示的字符串 ->
            String data into a string of 16 binary representations
            </summary>
            <param name="InString">输入的字符串数据</param>
            <returns>返回的字符串</returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.HexStringToBytes(System.String)">
            <summary>
            将16进制的字符串转化成Byte数据，将检测每2个字符转化，也就是说，中间可以是任意字符 ->
            Converts a 16-character string into byte data, which will detect every 2 characters converted, that is, the middle can be any character
            </summary>
            <param name="hex">十六进制的字符串，中间可以是任意的分隔符</param>
            <returns>转换后的字节数组</returns>
            <remarks>参数举例：AA 01 34 A8</remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="HexStringToBytesExample" title="HexStringToBytes示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BytesReverseByWord(System.Byte[])">
            <summary>
            将byte数组按照双字节进行反转，如果为单数的情况，则自动补齐 ->
            Reverses the byte array by double byte, or if the singular is the case, automatically
            </summary>
            <param name="inBytes">输入的字节信息</param>
            <returns>反转后的数据</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BytesReverseByWord" title="BytesReverseByWord示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BytesToAsciiBytes(System.Byte[])">
            <summary>
            将原始的byte数组转换成ascii格式的byte数组 ->
            Converts the original byte array to an ASCII-formatted byte array
            </summary>
            <param name="inBytes">等待转换的byte数组</param>
            <returns>转换后的数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.AsciiBytesToBytes(System.Byte[])">
            <summary>
            将ascii格式的byte数组转换成原始的byte数组 ->
            Converts an ASCII-formatted byte array to the original byte array
            </summary>
            <param name="inBytes">等待转换的byte数组</param>
            <returns>转换后的数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Byte)">
            <summary>
            从字节构建一个ASCII格式的数据内容
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Int16)">
            <summary>
            从short构建一个ASCII格式的数据内容
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.UInt16)">
            <summary>
            从ushort构建一个ASCII格式的数据内容
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BoolArrayToByte(System.Boolean[])">
            <summary>
            将bool数组转换到byte数组 ->
            Converting a bool array to a byte array
            </summary>
            <param name="array">bool数组</param>
            <returns>转换后的字节数组</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BoolArrayToByte" title="BoolArrayToByte示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[],System.Int32)">
            <summary>
            从Byte数组中提取位数组，length代表位数 ->
            Extracts a bit array from a byte array, length represents the number of digits
            </summary>
            <param name="InBytes">原先的字节数组</param>
            <param name="length">想要转换的长度，如果超出自动会缩小到数组最大长度</param>
            <returns>转换后的bool数组</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToBoolArray" title="ByteToBoolArray示例" />
            </example> 
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[])">
            <summary>
            从Byte数组中提取所有的位数组 ->
            Extracts a bit array from a byte array, length represents the number of digits
            </summary>
            <param name="InBytes">原先的字节数组</param>
            <returns>转换后的bool数组</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToBoolArray" title="ByteToBoolArray示例" />
            </example> 
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.SpliceTwoByteArray(System.Byte[],System.Byte[])">
            <summary>
            拼接2个字节数组成一个数组 ->
            Splicing 2 bytes to to an array
            </summary>
            <param name="bytes1">数组一</param>
            <param name="bytes2">数组二</param>
            <returns>拼接后的数组</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="SpliceTwoByteArray" title="SpliceTwoByteArray示例" />
            </example> 
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BytesArraySelectBegin(System.Byte[],System.Int32)">
            <summary>
            选择一个byte数组的前面的几个byte数据信息
            </summary>
            <param name="value">原始的数据信息</param>
            <param name="length">数据的长度</param>
            <returns>选择的前面的几个数据信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BytesArrayRemoveBegin(System.Byte[],System.Int32)">
            <summary>
            将一个byte数组的前面指定位数移除，返回新的一个数组 ->
            Removes the preceding specified number of bits in a byte array, returning a new array
            </summary>
            <param name="value">字节数组</param>
            <param name="length">等待移除的长度</param>
            <returns>新的数据</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BytesArrayRemoveBegin" title="BytesArrayRemoveBegin示例" />
            </example> 
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BytesArrayRemoveLast(System.Byte[],System.Int32)">
            <summary>
            将一个byte数组的后面指定位数移除，返回新的一个数组 ->
            Removes the specified number of digits after a byte array, returning a new array
            </summary>
            <param name="value">字节数组</param>
            <param name="length">等待移除的长度</param>
            <returns>新的数据</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BytesArrayRemoveLast" title="BytesArrayRemoveLast示例" />
            </example> 
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.BytesArrayRemoveDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将一个byte数组的前后移除指定位数，返回新的一个数组 ->
            Removes a byte array before and after the specified number of bits, returning a new array
            </summary>
            <param name="value">字节数组</param>
            <param name="leftLength">前面的位数</param>
            <param name="rightLength">后面的位数</param>
            <returns>新的数据</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BytesArrayRemoveDouble" title="BytesArrayRemoveDouble示例" />
            </example> 
        </member>
        <member name="P:Communication.BasicFramework.SoftBasic.FrameworkVersion">
            <summary>
            设置或获取系统框架的版本号 ->
            Set or get the version number of the system framework
            </summary>
            <remarks>
            当你要显示本组件框架的版本号的时候，就可以用这个属性来显示
            </remarks>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.DeepClone(System.Object)">
            <summary>
            使用序列化反序列化深度克隆一个对象，该对象需要支持序列化特性 ->
            Cloning an object with serialization deserialization depth that requires support for serialization attributes
            </summary>
            <param name="oringinal">源对象，支持序列化</param>
            <returns>新的一个实例化的对象</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.NonSerializedAttribute"></exception>
            <remarks>
            <note type="warning">
            <paramref name="oringinal"/> 参数必须实现序列化的特性
            </note>
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="DeepClone" title="DeepClone示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBasic.GetUniqueStringByGuidAndRandom">
            <summary>
            获取一串唯一的随机字符串，长度为20，由Guid码和4位数的随机数组成，保证字符串的唯一性 ->
            Gets a string of unique random strings with a length of 20, consisting of a GUID code and a 4-digit random number to guarantee the uniqueness of the string
            </summary>
            <returns>随机字符串数据</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetUniqueStringByGuidAndRandom" title="GetUniqueStringByGuidAndRandom示例" />
            </example>
        </member>
        <member name="T:Communication.BasicFramework.SoftBuffer">
            <summary>
            一个线程安全的缓存数据块，支持批量动态修改，添加，并获取快照
            </summary>
            <remarks>
            这个类可以实现什么功能呢，就是你有一个大的数组，作为你的应用程序的中间数据池，允许你往byte[]数组里存放指定长度的子byte[]数组，也允许从里面拿数据，
            这些操作都是线程安全的，当然，本类扩展了一些额外的方法支持，也可以直接赋值或获取基本的数据类型对象。
            </remarks>
            <example>
            此处举例一些数据的读写说明，可以此处的数据示例。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\BasicFramework\SoftBufferExample.cs" region="SoftBufferExample1" title="SoftBuffer示例" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.#ctor">
            <summary>
            使用默认的大小初始化缓存空间
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.#ctor(System.Int32)">
            <summary>
            使用指定的容量初始化缓存数据块
            </summary>
            <param name="capacity">初始化的容量</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetBool(System.Boolean,System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据
            </summary>
            <param name="value">bool值</param>
            <param name="destIndex">目标存储的索引</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetBool(System.Boolean[],System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据
            </summary>
            <param name="value">bool数组值</param>
            <param name="destIndex">目标存储的索引</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetBool(System.Int32)">
            <summary>
            获取指定的位置的bool值，如果超出，则引发异常
            </summary>
            <param name="destIndex">目标存储的索引</param>
            <returns>获取索引位置的bool数据值</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetBool(System.Int32,System.Int32)">
            <summary>
            获取指定位置的bool数组值，如果超过，则引发异常
            </summary>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">读取的数组长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <returns>bool数组值</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据
            </summary>
            <param name="data">数据块信息</param>
            <param name="destIndex">目标存储的索引</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据
            </summary>
            <param name="data">数据块信息</param>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">准备拷贝的数据长度</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据
            </summary>
            <param name="data">数据块信息</param>
            <param name="sourceIndex">Data中的起始位置</param>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">准备拷贝的数据长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetBytes(System.Int32,System.Int32)">
            <summary>
            获取内存指定长度的数据信息
            </summary>
            <param name="index">起始位置</param>
            <param name="length">数组长度</param>
            <returns>返回实际的数据信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetBytes">
            <summary>
            获取内存所有的数据信息
            </summary>
            <returns>实际的数据信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Byte,System.Int32)">
            <summary>
            设置byte类型的数据到缓存区
            </summary>
            <param name="value">byte数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Int16[],System.Int32)">
            <summary>
            设置short类型的数据到缓存区
            </summary>
            <param name="values">short数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Int16,System.Int32)">
            <summary>
            设置short类型的数据到缓存区
            </summary>
            <param name="value">short数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.UInt16[],System.Int32)">
            <summary>
            设置ushort类型的数据到缓存区
            </summary>
            <param name="values">ushort数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.UInt16,System.Int32)">
            <summary>
            设置ushort类型的数据到缓存区
            </summary>
            <param name="value">ushort数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Int32[],System.Int32)">
            <summary>
            设置int类型的数据到缓存区
            </summary>
            <param name="values">int数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Int32,System.Int32)">
            <summary>
            设置int类型的数据到缓存区
            </summary>
            <param name="value">int数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.UInt32[],System.Int32)">
            <summary>
            设置uint类型的数据到缓存区
            </summary>
            <param name="values">uint数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.UInt32,System.Int32)">
            <summary>
            设置uint类型的数据到缓存区
            </summary>
            <param name="value">uint数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Single[],System.Int32)">
            <summary>
            设置float类型的数据到缓存区
            </summary>
            <param name="values">float数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Single,System.Int32)">
            <summary>
            设置float类型的数据到缓存区
            </summary>
            <param name="value">float数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Int64[],System.Int32)">
            <summary>
            设置long类型的数据到缓存区
            </summary>
            <param name="values">long数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Int64,System.Int32)">
            <summary>
            设置long类型的数据到缓存区
            </summary>
            <param name="value">long数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.UInt64[],System.Int32)">
            <summary>
            设置ulong类型的数据到缓存区
            </summary>
            <param name="values">ulong数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.UInt64,System.Int32)">
            <summary>
            设置ulong类型的数据到缓存区
            </summary>
            <param name="value">ulong数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Double[],System.Int32)">
            <summary>
            设置double类型的数据到缓存区
            </summary>
            <param name="values">double数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetValue(System.Double,System.Int32)">
            <summary>
            设置double类型的数据到缓存区
            </summary>
            <param name="value">double数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetByte(System.Int32)">
            <summary>
            获取byte类型的数据
            </summary>
            <param name="index">索引位置</param>
            <returns>byte数值</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetInt16(System.Int32,System.Int32)">
            <summary>
            获取short类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>short数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetInt16(System.Int32)">
            <summary>
            获取short类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>short数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetUInt16(System.Int32,System.Int32)">
            <summary>
            获取ushort类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>ushort数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetUInt16(System.Int32)">
            <summary>
            获取ushort类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>ushort数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetInt32(System.Int32,System.Int32)">
            <summary>
            获取int类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>int数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetInt32(System.Int32)">
            <summary>
            获取int类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>int数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetUInt32(System.Int32,System.Int32)">
            <summary>
            获取uint类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>uint数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetUInt32(System.Int32)">
            <summary>
            获取uint类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>uint数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetSingle(System.Int32,System.Int32)">
            <summary>
            获取float类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>float数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetSingle(System.Int32)">
            <summary>
            获取float类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>float数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetInt64(System.Int32,System.Int32)">
            <summary>
            获取long类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>long数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetInt64(System.Int32)">
            <summary>
            获取long类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>long数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetUInt64(System.Int32,System.Int32)">
            <summary>
            获取ulong类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>ulong数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetUInt64(System.Int32)">
            <summary>
            获取ulong类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>ulong数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetDouble(System.Int32,System.Int32)">
            <summary>
            获取double类型的数组到缓存区
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>ulong数组</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetDouble(System.Int32)">
            <summary>
            获取double类型的数据到缓存区
            </summary>
            <param name="index">索引位置</param>
            <returns>double数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.GetCustomer``1(System.Int32)">
            <summary>
            读取自定义类型的数据，需要规定解析规则
            </summary>
            <typeparam name="T">类型名称</typeparam>
            <param name="index">起始索引</param>
            <returns>自定义的数据类型</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftBuffer.SetCustomer``1(``0,System.Int32)">
            <summary>
            写入自定义类型的数据到缓存中去，需要规定生成字节的方法
            </summary>
            <typeparam name="T">自定义类型</typeparam>
            <param name="data">实例对象</param>
            <param name="index">起始地址</param>
        </member>
        <member name="P:Communication.BasicFramework.SoftBuffer.ByteTransform">
            <summary>
            获取或设置当前的数据缓存类的解析规则
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SoftCacheArrayBase">
            <summary>
            内存队列的基类
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftCacheArrayBase.DataBytes">
            <summary>
            字节数据流
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftCacheArrayBase.ArrayLength">
            <summary>
            数据的长度
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftCacheArrayBase.HybirdLock">
            <summary>
            数据数组变动时的数据锁
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayBase.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayBase.GetAllData">
            <summary>
            获取原本的数据字节
            </summary>
            <returns></returns>
        </member>
        <member name="T:Communication.BasicFramework.SoftCacheArrayLong">
            <summary>
            一个内存队列缓存的类，数据类型为Int64
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftCacheArrayLong.DataArray">
            <summary>
            数据的本身面貌
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayLong.#ctor(System.Int32,System.Int32)">
            <summary>
            实例化一个数据对象
            </summary>
            <param name="capacity"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayLong.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayLong.AddValue(System.Int64)">
            <summary>
            线程安全的添加数据
            </summary>
            <param name="value">值</param>
        </member>
        <member name="T:Communication.BasicFramework.SoftCacheArrayInt">
            <summary>
            一个内存队列缓存的类，数据类型为Int32
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftCacheArrayInt.DataArray">
            <summary>
            数据的本身面貌
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayInt.#ctor(System.Int32,System.Int32)">
            <summary>
            实例化一个数据对象
            </summary>
            <param name="capacity"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayInt.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayInt.AddValue(System.Int32)">
            <summary>
            线程安全的添加数据
            </summary>
            <param name="value">值</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftCacheArrayInt.GetIntArray">
            <summary>
            安全的获取数组队列
            </summary>
            <returns></returns>
        </member>
        <member name="T:Communication.BasicFramework.Exception`1">
            <summary>
            一个自定义的支持序列化反序列化的异常类，具体用法参照第四版《CLR Via C#》P414
            </summary>
            <typeparam name="TExceptionArgs">泛型异常</typeparam>
        </member>
        <member name="F:Communication.BasicFramework.Exception`1.c_args">
            <summary>
            用于反序列化的
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.Exception`1.Args">
            <summary>
            消息
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.Exception`1.#ctor(System.String,System.Exception)">
            <summary>
            实例化一个异常对象
            </summary>
            <param name="message">消息</param>
            <param name="innerException">内部异常类</param>
        </member>
        <member name="M:Communication.BasicFramework.Exception`1.#ctor(`0,System.String,System.Exception)">
            <summary>
            实例化一个异常对象
            </summary>
            <param name="args">异常消息</param>
            <param name="message">消息</param>
            <param name="innerException">内部异常类</param>
        </member>
        <member name="M:Communication.BasicFramework.Exception`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            获取存储对象的序列化数据
            </summary>
            <param name="info">序列化的信息</param>
            <param name="context">流的上下文</param>
        </member>
        <member name="P:Communication.BasicFramework.Exception`1.Message">
            <summary>
            获取描述当前异常的消息
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.Exception`1.Equals(System.Object)">
            <summary>
            确定指定的object是否等于当前的object
            </summary>
            <param name="obj">异常对象</param>
            <returns>是否一致</returns>
        </member>
        <member name="M:Communication.BasicFramework.Exception`1.GetHashCode">
            <summary>
            用作特定类型的哈希函数
            </summary>
            <returns>int值</returns>
        </member>
        <member name="T:Communication.BasicFramework.ExceptionArgs">
            <summary>
            异常消息基类
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.ExceptionArgs.Message">
            <summary>
            获取消息文本
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SoftMail">
            <summary>
            软件的邮箱类，用于发送邮箱数据
            </summary>
            <remarks>
            如果您想实现自己的邮件发送中心，就可以去对应的邮件服务器注册，如果是想快速实现邮件的发送，本系统提供了2个静态的已经注册好了的邮箱发送器。
            </remarks>
            <example>
            以下的代码演示了通过静态的发送对象来发送邮件，包含了发送普通的邮件，和发送html邮件。
            <code lang="cs" source="TestProject\CommunicationDemo\FormMail.cs" region="SoftMail" title="SoftMail示例" />
            </example>
        </member>
        <member name="P:Communication.BasicFramework.SoftMail.SoftMailSendFailedCount">
            <summary>
            系统连续发送失败的次数，为了不影响系统，连续三次失败就禁止发送
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftMail.MailSystem163">
            <summary>
            系统提供一个默认的163邮箱发送账号，只要更改接收地址即可发送服务，可能会被拦截
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftMail.MailSystemQQ">
            <summary>
            系统提供一个默认的QQ邮箱发送账号，只要更改接收地址即可发送服务，发送成功概率比较高
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.#ctor(System.Action{System.Net.Mail.SmtpClient},System.String,System.String)">
            <summary>
            实例化一个邮箱发送类，需要指定初始化信息
            </summary>
            <param name="mailIni">初始化的方法</param>
            <param name="addr_From">发送地址，应该和账户匹配</param>
            <param name="addr_to">邮件接收地址</param>
            <remarks>
            初始化的方法比较复杂，需要参照示例代码。
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45\BasicFramework\SoftMail.cs" region="Static Mail" title="SoftMail示例" />
            </example>
        </member>
        <member name="P:Communication.BasicFramework.SoftMail.smtpClient">
            <summary>
            系统的邮件发送客户端
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftMail.MailFromAddress">
            <summary>
            发送邮件的地址
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftMail.MailSendAddress">
            <summary>
            邮件发送的地址
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.SendMail(System.Exception)">
            <summary>
            发生BUG至邮件地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="ex">异常的BUG，同样试用兼容类型</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.SendMail(System.String,System.String)">
            <summary>
            发送邮件至地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.Boolean)">
            <summary>
            发送邮件至地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="isHtml">是否是html格式化文本</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.SendMail(System.Exception,System.String)">
            <summary>
            发生BUG至邮件地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="ex">异常的BUG，同样试用兼容类型</param>
            <param name="addtion">额外信息</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String)">
            <summary>
            发送邮件的方法，需要指定接收地址，主题及内容
            </summary>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String,System.Boolean)">
            <summary>
            发送邮件的方法，默认发送别名，优先级，是否HTML
            </summary>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="isHtml">是否是html格式的内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String[],System.String,System.String,System.Net.Mail.MailPriority,System.Boolean)">
            <summary>
            发送邮件的方法，需要提供完整的参数信息
            </summary>
            <param name="addr_from">发送地址</param>
            <param name="name">发送别名</param>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="priority">优先级</param>
            <param name="isHtml">邮件内容是否是HTML语言</param>
            <returns>发生是否成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="T:Communication.BasicFramework.SoftMsgQueue`1">
            <summary>
            一个简单通用的消息队列
            </summary>
            <typeparam name="T">类型</typeparam>
        </member>
        <member name="M:Communication.BasicFramework.SoftMsgQueue`1.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftMsgQueue`1.all_items">
            <summary>
            所有临时存储的数据
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftMsgQueue`1.MaxCache">
            <summary>
            临时消息存储的最大条数，必须大于10
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SoftMsgQueue`1.CurrentItem">
            <summary>
            获取最新添加进去的数据
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftMsgQueue`1.lock_queue">
            <summary>
            将集合进行锁定
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftMsgQueue`1.AddNewItem(`0)">
            <summary>
            新增一条数据
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftMsgQueue`1.ToSaveString">
            <summary>
            获取存储字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftMsgQueue`1.LoadByString(System.String)">
            <summary>
            获取加载字符串
            </summary>
            <param name="content"></param>
        </member>
        <member name="T:Communication.BasicFramework.MessageBoard">
            <summary>
            系统的消息类，用来发送消息，和确认消息的
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.MessageBoard.NameSend">
            <summary>
            发送方名称
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.MessageBoard.NameReceive">
            <summary>
            接收方名称
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.MessageBoard.SendTime">
            <summary>
            发送时间
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.MessageBoard.Content">
            <summary>
            发送的消息内容
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.MessageBoard.HasViewed">
            <summary>
            消息是否已经被查看
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SoftNumericalOrder">
            <summary>
            一个用于自动流水号生成的类，必须指定保存的文件，实时保存来确认安全
            </summary>
            <remarks>
            <note type="important">
            序号生成器软件，当获取序列号，清空序列号操作后，会自动的将ID号存储到本地的文件中，存储方式采用乐观并发模型实现。
            </note>
            </remarks>
            <example>
            此处举个例子，也是Demo程序的源代码，包含了2个按钮的示例和瞬间调用100万次的性能示例。
            <note type="tip">百万次调用的实际耗时取决于计算机的性能，不同的计算机的表现存在差异，比如作者的：i5-4590cpu,内存ddr3-8G表示差不多在800毫秒左右</note>
            <code lang="cs" source="TestProject\CommunicationDemo\FormSeqCreate.cs" region="FormSeqCreate" title="示例代码" />
            </example>
        </member>
        <member name="M:Communication.BasicFramework.SoftNumericalOrder.#ctor(System.String,System.String,System.Int32,System.String)">
            <summary>
            实例化一个流水号生成的对象
            </summary>
            <param name="textHead">流水号的头文本</param>
            <param name="timeFormate">流水号带的时间信息</param>
            <param name="numberLength">流水号数字的标准长度，不够补0</param>
            <param name="fileSavePath">流水号存储的文本位置</param>
        </member>
        <member name="F:Communication.BasicFramework.SoftNumericalOrder.CurrentIndex">
            <summary>
            当前的生成序列号
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftNumericalOrder.TextHead">
            <summary>
            流水号的文本头
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftNumericalOrder.TimeFormate">
            <summary>
            时间格式默认年月日
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.SoftNumericalOrder.NumberLength">
            <summary>
            流水号数字应该显示的长度
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftNumericalOrder.ToSaveString">
            <summary>
            获取流水号的值
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftNumericalOrder.LoadByString(System.String)">
            <summary>
            加载流水号
            </summary>
            <param name="content">源字符串信息</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftNumericalOrder.ClearNumericalOrder">
            <summary>
            清除流水号计数，进行重新计数
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftNumericalOrder.GetNumericalOrder">
            <summary>
            获取流水号数据
            </summary>
            <returns>新增计数后的信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftNumericalOrder.GetNumericalOrder(System.String)">
            <summary>
            获取流水号数据
            </summary>
            <param name="textHead">指定一个新的文本头</param>
            <returns>带头信息的计数后的信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftNumericalOrder.GetLongOrder">
            <summary>
            单纯的获取数字形式的流水号
            </summary>
            <returns>新增计数后的信息</returns>
        </member>
        <member name="F:Communication.BasicFramework.SoftNumericalOrder.AsyncCoordinator">
            <summary>
            高性能存储块
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SoftIncrementCount">
            <summary>
            一个简单的不持久化的序号自增类，采用线程安全实现，并允许指定最大数字，将包含该最大值，到达后清空从指定数开始
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftIncrementCount.#ctor(System.Int64,System.Int64)">
            <summary>
            实例化一个自增信息的对象，包括最大值
            </summary>
            <param name="max">数据的最大值，必须指定</param>
            <param name="start">数据的起始值，默认为0</param>
        </member>
        <member name="M:Communication.BasicFramework.SoftIncrementCount.GetCurrentValue">
            <summary>
            获取自增信息
            </summary>
            <returns>计数自增后的值</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftIncrementCount.ResetMaxNumber(System.Int64)">
            <summary>
            重置当前序号的最大值
            </summary>
            <param name="max">最大值</param>
        </member>
        <member name="P:Communication.BasicFramework.SoftIncrementCount.IncreaseTick">
            <summary>
            增加的单元，如果设置为0，就是不增加。注意，不能小于0
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftIncrementCount.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>返回具体的值信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftIncrementCount.Dispose">
            <summary>
            释放当前对象所占用的资源
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.GraphDirection">
            <summary>
            图形的方向
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.GraphDirection.Upward">
            <summary>
            向上
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.GraphDirection.Downward">
            <summary>
            向下
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.GraphDirection.Ledtward">
            <summary>
            向左
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.GraphDirection.Rightward">
            <summary>
            向右
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.Paintdata">
            <summary>
            包含整型和字符串描述的数据类型
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.Paintdata.Count">
            <summary>
            数量
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.Paintdata.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.GraphicRender">
            <summary>
            图形的呈现方式
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.GraphicRender.Histogram">
            <summary>
            直方图
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.GraphicRender.Piechart">
            <summary>
            饼图
            </summary>
        </member>
        <member name="F:Communication.BasicFramework.GraphicRender.Linegraph">
            <summary>
            折线图
            </summary>
        </member>
        <member name="T:Communication.BasicFramework.SoftPainting">
            <summary>
            静态类，包含了几个常用的画图方法，获取字符串，绘制小三角等
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftPainting.GetGraphicFromArray(System.Int32[],System.Int32,System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            获取一个直方图
            </summary>
            <param name="array">数据数组</param>
            <param name="width">宽度</param>
            <param name="height">高度</param>
            <param name="degree">刻度划分等级</param>
            <param name="lineColor">线条颜色</param>
            <returns></returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftPainting.ComputePaintLocationY(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            计算绘图时的相对偏移值
            </summary>
            <param name="max">0-100分的最大值，就是指准备绘制的最大值</param>
            <param name="min">0-100分的最小值，就是指准备绘制的最小值</param>
            <param name="height">实际绘图区域的高度</param>
            <param name="value">需要绘制数据的当前值</param>
            <returns>相对于0的位置，还需要增加上面的偏值</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftPainting.ComputePaintLocationY(System.Single,System.Single,System.Int32,System.Single)">
            <summary>
            计算绘图时的相对偏移值
            </summary>
            <param name="max">0-100分的最大值，就是指准备绘制的最大值</param>
            <param name="min">0-100分的最小值，就是指准备绘制的最小值</param>
            <param name="height">实际绘图区域的高度</param>
            <param name="value">需要绘制数据的当前值</param>
            <returns>相对于0的位置，还需要增加上面的偏值</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftPainting.PaintCoordinateDivide(System.Drawing.Graphics,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Font,System.Drawing.Brush,System.Drawing.StringFormat,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            绘制坐标系中的刻度线
            </summary>
            <param name="g"></param>
            <param name="penLine"></param>
            <param name="penDash"></param>
            <param name="font"></param>
            <param name="brush"></param>
            <param name="sf"></param>
            <param name="degree"></param>
            <param name="max"></param>
            <param name="min"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="up"></param>
            <param name="down"></param>
        </member>
        <member name="M:Communication.BasicFramework.SoftPainting.PaintTriangle(System.Drawing.Graphics,System.Drawing.Brush,System.Drawing.Point,System.Int32,Communication.BasicFramework.GraphDirection)">
            <summary>
            根据指定的方向绘制一个箭头
            </summary>
            <param name="g"></param>
            <param name="brush"></param>
            <param name="point"></param>
            <param name="size"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Communication.BasicFramework.SoftPainting.GetGraphicFromArray(Communication.BasicFramework.Paintdata[],System.Int32,System.Int32,Communication.BasicFramework.GraphicRender)">
            <summary>
            根据数据生成一个可视化的图形
            </summary>
            <param name="array">数据集合</param>
            <param name="width">需要绘制图形的宽度</param>
            <param name="height">需要绘制图形的高度</param>
            <param name="graphic">指定绘制成什么样子的图形</param>
            <returns>返回一个bitmap对象</returns>
        </member>
        <member name="T:Communication.BasicFramework.SoftSecurity">
            <summary>
            字符串加密解密相关的自定义类
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftSecurity.MD5Encrypt(System.String)">
            <summary>
            加密数据，采用对称加密的方式
            </summary>
            <param name="pToEncrypt">待加密的数据</param>
            <returns>加密后的数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftSecurity.MD5Encrypt(System.String,System.String)">
            <summary>
            加密数据，采用对称加密的方式
            </summary>
            <param name="pToEncrypt">待加密的数据</param>
            <param name="Password">密钥，长度为8，英文或数字</param>
            <returns>加密后的数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftSecurity.MD5Decrypt(System.String)">
            <summary>
            解密过程，使用的是对称的加密
            </summary>
            <param name="pToDecrypt">等待解密的字符</param>
            <returns>返回原密码，如果解密失败，返回‘解密失败’</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftSecurity.MD5Decrypt(System.String,System.String)">
            <summary>
            解密过程，使用的是对称的加密
            </summary>
            <param name="pToDecrypt">等待解密的字符</param>
            <param name="password">密钥，长度为8，英文或数字</param>
            <returns>返回原密码，如果解密失败，返回‘解密失败’</returns>
        </member>
        <member name="T:Communication.BasicFramework.SoftSqlOperate">
            <summary>
            数据库操作的相关类，包含了常用的方法，避免大量的重复代码
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSql(System.String,System.String)">
            <summary>
            普通的执行SQL语句，并返回影响行数，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，适合插入，更新，删除</param>
            <returns>返回受影响的行数</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSql(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            普通的执行SQL语句，并返回影响行数，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，适合插入，更新，删除</param>
            <returns>返回受影响的行数</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectTable(System.String,System.String)">
            <summary>
            选择数据表的执行SQL语句，并返回最终数据表，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据表</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectTable(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            选择数据表的执行SQL语句，并返回最终数据表，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据表</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectEnumerable``1(System.String,System.String)">
            <summary>
            选择指定类型数据集合执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据集合</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectEnumerable``1(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            选择指定类型数据集合执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据集合</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectObject``1(System.String,System.String)">
            <summary>
            更新指定类型数据执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectObject``1(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            更新指定类型数据执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectCount(System.String,System.String)">
            <summary>
            用于选择聚合函数值的方法，例如Count，Average，Max，Min，Sum等最终只有一个结果值的对象
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>返回的int数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftSqlOperate.ExecuteSelectCount(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            用于选择聚合函数值的方法，例如Count，Average，Max，Min，Sum等最终只有一个结果值的对象
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>返回的int数据</returns>
        </member>
        <member name="T:Communication.BasicFramework.ISqlDataType">
            <summary>
            数据库对应类的读取接口
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.ISqlDataType.LoadBySqlDataReader(System.Data.SqlClient.SqlDataReader)">
            <summary>
            根据sdr对象初始化数据的方法
            </summary>
            <param name="sdr">数据库reader对象</param>
        </member>
        <member name="T:Communication.BasicFramework.SystemVersion">
            <summary>
            系统版本类，由三部分组成，包含了一个大版本，小版本，修订版，还有一个开发者维护的内部版
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.#ctor(System.String)">
            <summary>
            根据格式化字符串的版本号初始化
            </summary>
            <param name="VersionString">格式化的字符串，例如：1.0或1.0.0或1.0.0.0503</param>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            根据指定的数字实例化一个对象
            </summary>
            <param name="main">主版本</param>
            <param name="sec">次版本</param>
            <param name="edit">修订版</param>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            根据指定的数字实例化一个对象
            </summary>
            <param name="main">主版本</param>
            <param name="sec">次版本</param>
            <param name="edit">修订版</param>
            <param name="inner">内部版本号</param>
        </member>
        <member name="P:Communication.BasicFramework.SystemVersion.MainVersion">
            <summary>
            主版本
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SystemVersion.SecondaryVersion">
            <summary>
            次版本
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SystemVersion.EditVersion">
            <summary>
            修订版
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.SystemVersion.InnerVersion">
            <summary>
            内部版本号，或者是版本号表示为年月份+内部版本的表示方式
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.ToString(System.String)">
            <summary>
            根据格式化为支持返回的不同信息的版本号
            C返回1.0.0.0
            N返回1.0.0
            S返回1.0
            </summary>
            <param name="format">格式化信息</param>
            <returns>版本号信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.ToString">
            <summary>
            获取版本号的字符串形式，如果内部版本号为0，则显示时不携带
            </summary>
            <returns>版本号信息</returns>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.Equals(System.Object)">
            <summary>
            判断两个实例是否相等
            </summary>
            <param name="obj">版本号</param>
            <returns>是否一致</returns>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.GetHashCode">
            <summary>
            获取哈希值
            </summary>
            <returns>哈希值</returns>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.op_Equality(Communication.BasicFramework.SystemVersion,Communication.BasicFramework.SystemVersion)">
            <summary>
            判断是否相等
            </summary>
            <param name="SV1">第一个版本</param>
            <param name="SV2">第二个版本</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.op_Inequality(Communication.BasicFramework.SystemVersion,Communication.BasicFramework.SystemVersion)">
            <summary>
            判断是否不相等
            </summary>
            <param name="SV1">第一个版本号</param>
            <param name="SV2">第二个版本号</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.op_GreaterThan(Communication.BasicFramework.SystemVersion,Communication.BasicFramework.SystemVersion)">
            <summary>
            判断一个版本是否大于另一个版本
            </summary>
            <param name="SV1">第一个版本</param>
            <param name="SV2">第二个版本</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:Communication.BasicFramework.SystemVersion.op_LessThan(Communication.BasicFramework.SystemVersion,Communication.BasicFramework.SystemVersion)">
            <summary>
            判断第一个版本是否小于第二个版本
            </summary>
            <param name="SV1">第一个版本号</param>
            <param name="SV2">第二个版本号</param>
            <returns>是否小于</returns>
        </member>
        <member name="T:Communication.BasicFramework.VersionInfo">
            <summary>
            版本信息类，用于展示版本发布信息
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.VersionInfo.ReleaseDate">
            <summary>
            版本的发行日期
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.VersionInfo.UpdateDetails">
            <summary>
            版本的更新细节
            </summary>
        </member>
        <member name="P:Communication.BasicFramework.VersionInfo.VersionNum">
            <summary>
            版本号
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.VersionInfo.ToString">
            <summary>
            获取版本号
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.BasicFramework.SoftZipped">
            <summary>
            一个负责压缩解压数据字节的类
            </summary>
        </member>
        <member name="M:Communication.BasicFramework.SoftZipped.CompressBytes(System.Byte[])">
            <summary>
            压缩字节数据
            </summary>
            <param name="bytes">等待被压缩的数据</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <returns>压缩之后的字节数据</returns>
        </member>
        <member name="M:Communication.BasicFramework.SoftZipped.Decompress(System.Byte[])">
            <summary>
            解压压缩后的数据
            </summary>
            <param name="bytes">压缩后的数据</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <returns>压缩前的原始字节数据</returns>
        </member>
        <member name="T:Communication.Controls.UserBottle">
            <summary>
            瓶子控件
            </summary>
        </member>
        <member name="M:Communication.Controls.UserBottle.#ctor">
            <summary>
            实例化一个新的控件对象
            </summary>
        </member>
        <member name="P:Communication.Controls.UserBottle.Value">
            <summary>
            获取或设置瓶子的液位值。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserBottle.IsOpen">
            <summary>
            获取或设置瓶子是否处于打开的状态。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserBottle.BottleTag">
            <summary>
            获取或设置瓶子的标签信息，用于绘制在瓶子上的信息。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserBottle.HeadTag">
            <summary>
            获取或设置瓶子的备注信息，用于绘制在瓶子顶部的信息。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserBottle.WndProc(System.Windows.Forms.Message@)">
            <summary>
            重写消息处理机制
            </summary>
            <param name="m">系统消息</param>
        </member>
        <member name="M:Communication.Controls.UserBottle.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重新绘制界面图形
            </summary>
            <param name="e">绘制消息</param>
        </member>
        <member name="F:Communication.Controls.UserBottle.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserBottle.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserBottle.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserButton">
            <summary>
            一个自定义的按钮控件
            </summary>
        </member>
        <member name="M:Communication.Controls.UserButton.#ctor">
            <summary>
            实例化一个按钮对象
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.UIText">
            <summary>
            设置或获取显示的文本
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.TextColor">
            <summary>
            设置或获取显示文本的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.CornerRadius">
            <summary>
            设置按钮的圆角
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.Selected">
            <summary>
            用来设置按钮的选中状态
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.ForeColor">
            <summary>
            已经弃用
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.Text">
            <summary>
            已经弃用
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.OriginalColor">
            <summary>
            按钮的背景色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.EnableColor">
            <summary>
            按钮的背景色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.ActiveColor">
            <summary>
            鼠标挪动时的活动颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.BorderVisiable">
            <summary>
            设置按钮的边框是否可见
            </summary>
        </member>
        <member name="P:Communication.Controls.UserButton.CustomerInformation">
            <summary>
            存放用户需要保存的一些额外的信息
            </summary>
        </member>
        <member name="M:Communication.Controls.UserButton.PerformClick">
            <summary>
            触发一次点击的事件
            </summary>
        </member>
        <member name="M:Communication.Controls.UserButton.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重绘数据区
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Communication.Controls.UserButton.OnClick(System.EventArgs)">
            <summary>
            点击按钮的触发事件
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Communication.Controls.UserButton.OnMouseClick(System.Windows.Forms.MouseEventArgs)">
            <summary>
            点击的时候触发事件
            </summary>
            <param name="e"></param>
        </member>
        <member name="F:Communication.Controls.UserButton.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserButton.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserButton.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserClock">
            <summary>
            一个时钟控件
            </summary>
        </member>
        <member name="M:Communication.Controls.UserClock.#ctor">
            <summary>
            实例化一个时钟控件
            </summary>
        </member>
        <member name="P:Communication.Controls.UserClock.当前时间">
            <summary>
            获取时钟的当前时间
            </summary>
        </member>
        <member name="P:Communication.Controls.UserClock.时钟指针颜色">
            <summary>
            获取或设置时钟指针的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserClock.分钟指针颜色">
            <summary>
            获取或设置时钟分钟指针颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserClock.秒钟指针颜色">
            <summary>
            获取或设置秒钟指针颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserClock.显示文本">
            <summary>
            获取或设置时钟的个性化文本
            </summary>
        </member>
        <member name="P:Communication.Controls.UserClock.显示文本字体">
            <summary>
            字体
            </summary>
        </member>
        <member name="M:Communication.Controls.UserClock.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重绘控件显示
            </summary>
            <param name="e"></param>
        </member>
        <member name="F:Communication.Controls.UserClock.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserClock.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserClock.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserCurve">
            <summary>
            曲线控件对象
            </summary>
            <remarks>
            详细参照如下的博客:
            </remarks>
        </member>
        <member name="M:Communication.Controls.UserCurve.#ctor">
            <summary>
            实例化一个曲线显示的控件
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.ValueMaxLeft">
            <summary>
            获取或设置图形的纵坐标的最大值，该值必须大于最小值
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.ValueMinLeft">
            <summary>
            获取或设置图形的纵坐标的最小值，该值必须小于最大值
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.ValueMaxRight">
            <summary>
            获取或设置图形的纵坐标的最大值，该值必须大于最小值
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.ValueMinRight">
            <summary>
            获取或设置图形的纵坐标的最小值，该值必须小于最大值
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.ValueSegment">
            <summary>
            获取或设置图形的纵轴分段数
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.IsAbscissaStrech">
            <summary>
            获取或设置所有的数据是否强制在一个界面里显示
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.StrechDataCountMax">
            <summary>
            获取或设置拉伸模式下的最大数据量
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.IsRenderDashLine">
            <summary>
            获取或设置虚线是否进行显示
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.ColorLinesAndText">
            <summary>
            获取或设置坐标轴及相关信息文本的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.ColorDashLines">
            <summary>
            获取或设置虚线的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.IntervalAbscissaText">
            <summary>
            获取或设置纵向虚线的分隔情况，单位为多少个数据
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.TextAddFormat">
            <summary>
            获取或设置实时数据新增时文本相对应于时间的格式化字符串，默认HH:mm
            </summary>
        </member>
        <member name="P:Communication.Controls.UserCurve.Title">
            <summary>
            获取或设置图标的标题信息
            </summary>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetCurveText(System.String[])">
            <summary>
            设置曲线的横坐标文本，适用于显示一些固定的曲线信息
            </summary>
            <param name="descriptions">应该和曲线的点数一致</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetLeftCurve(System.String,System.Single[])">
            <summary>
            新增或修改一条指定关键字的左参考系曲线数据，需要指定数据，颜色随机，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data">曲线的具体数据</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetLeftCurve(System.String,System.Single[],System.Drawing.Color)">
            <summary>
            新增或修改一条指定关键字的左参考系曲线数据，需要指定数据，颜色，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
            <param name="lineColor"></param>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetRightCurve(System.String,System.Single[])">
            <summary>
            新增或修改一条指定关键字的右参考系曲线数据，需要指定数据，颜色随机，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetRightCurve(System.String,System.Single[],System.Drawing.Color)">
            <summary>
            新增或修改一条指定关键字的右参考系曲线数据，需要指定数据，颜色，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
            <param name="lineColor"></param>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetCurve(System.String,System.Boolean,System.Single[],System.Drawing.Color,System.Single)">
            <summary>
            新增或修改一条指定关键字的曲线数据，需要指定参考系及数据，颜色，线条宽度
            </summary>
            <param name="key">曲线关键字</param>
            <param name="isLeft">是否以左侧坐标轴为参照系</param>
            <param name="data">数据</param>
            <param name="lineColor">线条颜色</param>
            <param name="thickness">线条宽度</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.RemoveCurve(System.String)">
            <summary>
            移除指定关键字的曲线
            </summary>
            <param name="key">曲线关键字</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.RemoveAllCurve">
            <summary>
            移除指定关键字的曲线
            </summary>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddCurveData(System.String,System.Single[],System.Boolean)">
            <summary>
            新增指定关键字曲线的一个数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">新增曲线的关键字</param>
            <param name="values"></param>
            <param name="isUpdateUI">是否刷新界面</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddCurveData(System.String,System.Single)">
            <summary>
            新增指定关键字曲线的一个数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">曲线的关键字</param>
            <param name="value">数据值</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddCurveData(System.String,System.Single[])">
            <summary>
            新增指定关键字曲线的一组数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">曲线的关键字</param>
            <param name="values">数组值</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddCurveData(System.String[],System.Single[])">
            <summary>
            新增指定关键字数组曲线的一组数据，注意该关键字的曲线必须存在，否则无效，一个数据对应一个数组
            </summary>
            <param name="keys">曲线的关键字数组</param>
            <param name="values">数组值</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetCurveVisible(System.String,System.Boolean)">
            <summary>
            设置一条曲线是否是可见的，如果该曲线不存在，则无效。
            </summary>
            <param name="key">关键字</param>
            <param name="visible">是否可见</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.SetCurveVisible(System.String[],System.Boolean)">
            <summary>
            设置多条曲线是否是可见的，如果该曲线不存在，则无效。
            </summary>
            <param name="keys">关键字</param>
            <param name="visible">是否可见</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddLeftAuxiliary(System.Single)">
            <summary>
            新增一条左侧的辅助线，使用默认的文本颜色
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddLeftAuxiliary(System.Single,System.Drawing.Color)">
            <summary>
            新增一条左侧的辅助线，使用指定的颜色
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddLeftAuxiliary(System.Single,System.Drawing.Color,System.Single)">
            <summary>
            新增一条左侧的辅助线
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
            <param name="lineThickness">线条宽度</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddRightAuxiliary(System.Single)">
            <summary>
            新增一条右侧的辅助线，使用默认的文本颜色
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddRightAuxiliary(System.Single,System.Drawing.Color)">
            <summary>
            新增一条右侧的辅助线，使用指定的颜色
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.AddRightAuxiliary(System.Single,System.Drawing.Color,System.Single)">
            <summary>
            新增一条右侧的辅助线
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
            <param name="lineThickness">线条宽度</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.RemoveAuxiliary(System.Single)">
            <summary>
            移除所有的指定值的辅助曲线，包括左边的和右边的
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Communication.Controls.UserCurve.RemoveAllAuxiliary">
            <summary>
            移除所有的辅助线
            </summary>
        </member>
        <member name="F:Communication.Controls.UserCurve.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserCurve.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserCurve.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.HslCurveItem">
            <summary>
            曲线数据对象
            </summary>
        </member>
        <member name="M:Communication.Controls.HslCurveItem.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:Communication.Controls.HslCurveItem.Data">
            <summary>
            数据
            </summary>
        </member>
        <member name="P:Communication.Controls.HslCurveItem.LineThickness">
            <summary>
            线条的宽度
            </summary>
        </member>
        <member name="P:Communication.Controls.HslCurveItem.LineColor">
            <summary>
            曲线颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.HslCurveItem.IsLeftFrame">
            <summary>
            是否左侧参考系，True为左侧，False为右侧
            </summary>
        </member>
        <member name="P:Communication.Controls.HslCurveItem.Visible">
            <summary>
            本曲线是否显示出来，默认为显示
            </summary>
        </member>
        <member name="T:Communication.Controls.AuxiliaryLine">
            <summary>
            辅助线对象
            </summary>
        </member>
        <member name="P:Communication.Controls.AuxiliaryLine.Value">
            <summary>
            实际的数据值
            </summary>
        </member>
        <member name="P:Communication.Controls.AuxiliaryLine.PaintValue">
            <summary>
            实际的数据绘制
            </summary>
        </member>
        <member name="P:Communication.Controls.AuxiliaryLine.LineColor">
            <summary>
            辅助线的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.AuxiliaryLine.PenDash">
            <summary>
            辅助线的画笔资源
            </summary>
        </member>
        <member name="P:Communication.Controls.AuxiliaryLine.LineThickness">
            <summary>
            辅助线的宽度
            </summary>
        </member>
        <member name="P:Communication.Controls.AuxiliaryLine.LineTextBrush">
            <summary>
            辅助线文本的画刷
            </summary>
        </member>
        <member name="P:Communication.Controls.AuxiliaryLine.IsLeftFrame">
            <summary>
            是否左侧参考系，True为左侧，False为右侧
            </summary>
        </member>
        <member name="M:Communication.Controls.AuxiliaryLine.Dispose">
            <summary>
            释放内存信息
            </summary>
        </member>
        <member name="T:Communication.Controls.UserDrum">
            <summary>
            一个罐子形状的控件
            </summary>
        </member>
        <member name="M:Communication.Controls.UserDrum.#ctor">
            <summary>
            实例化一个罐子形状的控件
            </summary>
        </member>
        <member name="P:Communication.Controls.UserDrum.DrumBackColor">
            <summary>
            获取或设置容器罐的背景色。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserDrum.BorderColor">
            <summary>
            获取或设置容器罐的边框色。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserDrum.Text">
            <summary>
            获取或设置显示的文本信息
            </summary>
        </member>
        <member name="P:Communication.Controls.UserDrum.ForeColor">
            <summary>
            获取或设置文本的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserDrum.TextBackColor">
            <summary>
            获取或设置文本的背景色
            </summary>
        </member>
        <member name="F:Communication.Controls.UserDrum.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserDrum.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserDrum.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserGaugeChart">
            <summary>
            仪表盘控件类
            </summary>
        </member>
        <member name="M:Communication.Controls.UserGaugeChart.#ctor">
            <summary>
            实例化一个仪表盘控件
            </summary>
        </member>
        <member name="M:Communication.Controls.UserGaugeChart.GetCenterPoint">
            <summary>
            获取中心点的坐标
            </summary>
            <returns></returns>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.GaugeBorder">
            <summary>
            获取或设置仪表盘的背景色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.PointerColor">
            <summary>
            获取或设置指针的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.ValueStart">
            <summary>
            获取或设置数值的起始值，默认为0
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.ValueMax">
            <summary>
            获取或设置数值的最大值，默认为100
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.Value">
            <summary>
            获取或设置数值的当前值，应该处于最小值和最大值之间
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.ValueAlarmMax">
            <summary>
            获取或设置数值的上限报警值，设置为超过最大值则无上限报警
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.ValueAlarmMin">
            <summary>
            获取或设置数值的下限报警值，设置为超过最大值则无上限报警
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.SegmentCount">
            <summary>
            获取或设置仪表盘的分割段数，最小为2，最大1000
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.UnitText">
            <summary>
            获取或设置仪表盘的单位描述文本
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.IsTextUnderPointer">
            <summary>
            获取或设置文本是否是指针的下面
            </summary>
        </member>
        <member name="P:Communication.Controls.UserGaugeChart.IsBigSemiCircle">
            <summary>
            通常情况，仪表盘不会大于半个圆，除非本属性设置为 True
            </summary>
        </member>
        <member name="F:Communication.Controls.UserGaugeChart.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserGaugeChart.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserGaugeChart.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserLantern">
            <summary>
            信号灯的控件类
            </summary>
        </member>
        <member name="M:Communication.Controls.UserLantern.#ctor">
            <summary>
            实例化一个信号灯控件的对象
            </summary>
        </member>
        <member name="P:Communication.Controls.UserLantern.LanternBackground">
            <summary>
            获取或设置开关按钮的背景色
            </summary>
        </member>
        <member name="F:Communication.Controls.UserLantern.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserLantern.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserLantern.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserPieChart">
            <summary>
            一个饼图的控件
            </summary>
        </member>
        <member name="M:Communication.Controls.UserPieChart.#ctor">
            <summary>
            实例化一个饼图的控件
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPieChart.IsRenderPercent">
            <summary>
            是否显示百分比信息
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPieChart.IsRenderSmall">
            <summary>
            是否在图形上显示占比非常小的文本信息
            </summary>
        </member>
        <member name="M:Communication.Controls.UserPieChart.GetRandomColor">
            <summary>
            随机生成颜色，该颜色相对于白色为深色颜色
            </summary>
            <returns></returns>
        </member>
        <member name="M:Communication.Controls.UserPieChart.SetDataSource(Communication.Core.HslPieItem[])">
            <summary>
            设置显示的数据源
            </summary>
            <param name="source">特殊的显示对象</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Communication.Controls.UserPieChart.SetDataSource(System.String[],System.Int32[])">
            <summary>
            根据名称和值进行数据源的显示，两者的长度需要一致
            </summary>
            <param name="names">名称</param>
            <param name="values">值</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="F:Communication.Controls.UserPieChart.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserPieChart.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserPieChart.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserPipe">
            <summary>
            
            </summary>
        </member>
        <member name="M:Communication.Controls.UserPipe.#ctor">
            <summary>
            管道控件信息
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPipe.LineWidth">
            <summary>
            获取或设置管道线的宽度。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPipe.IsActive">
            <summary>
            获取或设置管道线是否处于活动状态。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPipe.ActiveColor">
            <summary>
            获取或设置管道活动状态的颜色。
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPipe.LineColor">
            <summary>
            获取或设置管道的背景色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPipe.MoveSpeed">
            <summary>
            获取或设置管道线的移动速度。该速度和管道的宽度有关
            </summary>
        </member>
        <member name="P:Communication.Controls.UserPipe.LinePoints">
            <summary>
            获取或设置管道线的坐标。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserPipe.OnPaintMainWindow(System.Drawing.Graphics)">
            <summary>
            绘制
            </summary>
            <param name="g"></param>
        </member>
        <member name="F:Communication.Controls.UserPipe.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserPipe.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserPipe.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserSwitch">
            <summary>
            一个开关按钮类
            </summary>
        </member>
        <member name="M:Communication.Controls.UserSwitch.#ctor">
            <summary>
            实例化一个开关按钮对象
            </summary>
        </member>
        <member name="E:Communication.Controls.UserSwitch.OnSwitchChanged">
            <summary>
            开关按钮发生变化的事件
            </summary>
        </member>
        <member name="P:Communication.Controls.UserSwitch.SwitchBackground">
            <summary>
            获取或设置开关按钮的背景色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserSwitch.SwitchForeground">
            <summary>
            获取或设置开关按钮的前景色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserSwitch.SwitchStatus">
            <summary>
            获取或设置开关按钮的开合状态
            </summary>
        </member>
        <member name="P:Communication.Controls.UserSwitch.SwitchStatusDescription">
            <summary>
            获取或设置两种开关状态的文本描述，例如：new string[]{"Off","On"}
            </summary>
        </member>
        <member name="F:Communication.Controls.UserSwitch.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserSwitch.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserSwitch.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.UserVerticalProgress">
            <summary>
            一个直立的进度条控件，满足不同的情况使用
            </summary>
        </member>
        <member name="M:Communication.Controls.UserVerticalProgress.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.Cursor">
            <summary>
            获取或设置光标在控件上显示的信息
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.BackColor">
            <summary>
            获取或设置控件的背景颜色值
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.ProgressColor">
            <summary>
            获取或设置进度的颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.Max">
            <summary>
            进度条的最大值，默认为100
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.Value">
            <summary>
            当前进度条的值，不能大于最大值或小于0
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.IsTextRender">
            <summary>
            是否显示进度
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.BorderColor">
            <summary>
            设置进度条的边框颜色
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.ValueChangeSpeed">
            <summary>
            设置进度变更的速度
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.UseAnimation">
            <summary>
            获取或设置进度条变化的时候是否采用动画效果
            </summary>
        </member>
        <member name="P:Communication.Controls.UserVerticalProgress.ProgressStyle">
            <summary>
            进度条的样式
            </summary>
        </member>
        <member name="F:Communication.Controls.UserVerticalProgress.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.Controls.UserVerticalProgress.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.Controls.UserVerticalProgress.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.Controls.ProgressStyle">
            <summary>
            进度条的样式
            </summary>
        </member>
        <member name="F:Communication.Controls.ProgressStyle.Vertical">
            <summary>
            竖直的，纵向的进度条
            </summary>
        </member>
        <member name="F:Communication.Controls.ProgressStyle.Horizontal">
            <summary>
            水平进度条
            </summary>
        </member>
        <member name="T:Communication.Core.Address.DeviceAddressBase">
            <summary>
            所有设备通信类的地址基础类
            </summary>
        </member>
        <member name="P:Communication.Core.Address.DeviceAddressBase.Address">
            <summary>
            起始地址
            </summary>
        </member>
        <member name="M:Communication.Core.Address.DeviceAddressBase.AnalysisAddress(System.String)">
            <summary>
            解析字符串的地址
            </summary>
            <param name="address">地址信息</param>
        </member>
        <member name="M:Communication.Core.Address.DeviceAddressBase.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串数据</returns>
        </member>
        <member name="T:Communication.Core.Address.ModbusAddress">
            <summary>
            Modbus协议地址格式，可以携带站号，功能码，地址信息
            </summary>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.#ctor(System.String)">
            <summary>
            实例化一个默认的对象，使用默认的地址初始化
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.#ctor(System.String,System.Byte)">
            <summary>
            实例化一个默认的对象，使用默认的地址初始化
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
            <param name="function">默认的功能码信息</param>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.#ctor(System.Byte,System.Byte,System.UInt16)">
            <summary>
            实例化一个默认的对象，使用默认的地址初始化
            </summary>
            <param name="station">站号信息</param>
            <param name="function">功能码信息</param>
            <param name="address">地址信息</param>
        </member>
        <member name="P:Communication.Core.Address.ModbusAddress.Station">
            <summary>
            站号信息
            </summary>
        </member>
        <member name="P:Communication.Core.Address.ModbusAddress.Function">
            <summary>
            功能码
            </summary>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.AnalysisAddress(System.String)">
            <summary>
            解析Modbus的地址码
            </summary>
            <param name="address">地址数据信息</param>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.CreateReadCoils(System.Byte,System.UInt16)">
            <summary>
            创建一个读取线圈的字节对象
            </summary>
            <param name="station">读取的站号</param>
            <param name="length">读取数据的长度</param>
            <returns>原始的modbus指令</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.CreateReadDiscrete(System.Byte,System.UInt16)">
            <summary>
            创建一个读取离散输入的字节对象
            </summary>
            <param name="station">读取的站号</param>
            <param name="length">读取数据的长度</param>
            <returns>原始的modbus指令</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.CreateReadRegister(System.Byte,System.UInt16)">
            <summary>
            创建一个读取寄存器的字节对象
            </summary>
            <param name="station">读取的站号</param>
            <param name="length">读取数据的长度</param>
            <returns>原始的modbus指令</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.CreateWriteOneCoil(System.Byte,System.Boolean)">
            <summary>
            创建一个写入单个线圈的指令
            </summary>
            <param name="station">站号</param>
            <param name="value">值</param>
            <returns>原始的modbus指令</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.CreateWriteOneRegister(System.Byte,System.Byte[])">
            <summary>
            创建一个写入单个寄存器的指令
            </summary>
            <param name="station">站号</param>
            <param name="values">值</param>
            <returns>原始的modbus指令</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.CreateWriteCoil(System.Byte,System.Boolean[])">
            <summary>
            创建一个写入批量线圈的指令
            </summary>
            <param name="station">站号</param>
            <param name="values">值</param>
            <returns>原始的modbus指令</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.CreateWriteRegister(System.Byte,System.Byte[])">
            <summary>
            创建一个写入批量寄存器的指令
            </summary>
            <param name="station">站号</param>
            <param name="values">值</param>
            <returns>原始的modbus指令</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.AddressAdd(System.Int32)">
            <summary>
            地址新增指定的数
            </summary>
            <param name="value">数据值信息</param>
            <returns>新增后的地址信息</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.AddressAdd">
            <summary>
            地址新增1
            </summary>
            <returns>新增后的地址信息</returns>
        </member>
        <member name="M:Communication.Core.Address.ModbusAddress.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>地址表示形式</returns>
        </member>
        <member name="T:Communication.Core.IMessage.AlienMessage">
            <summary>
            异形消息对象，用于异形客户端的注册包接收以及验证使用
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.AlienMessage.ProtocolHeadBytesLength">
            <summary>
            本协议的消息头长度
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.AlienMessage.HeadBytes">
            <summary>
            头子节信息
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.AlienMessage.ContentBytes">
            <summary>
            内容字节信息
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.AlienMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查接收的数据是否合法
            </summary>
            <param name="token">令牌</param>
            <returns>是否合法</returns>
        </member>
        <member name="M:Communication.Core.IMessage.AlienMessage.GetContentLengthByHeadBytes">
            <summary>
            从头子节信息中解析出接下来需要接收的数据长度
            </summary>
            <returns>接下来的数据长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.AlienMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的特殊标识
            </summary>
            <returns>标识信息</returns>
        </member>
        <member name="P:Communication.Core.IMessage.AlienMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.AllenBradleyMessage">
            <summary>
            用于和 AllenBradley PLC 交互的消息协议类
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.AllenBradleyMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.AllenBradleyMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.AllenBradleyMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.IMessage.AllenBradleyMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息id</returns>
        </member>
        <member name="P:Communication.Core.IMessage.AllenBradleyMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.AllenBradleyMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.AllenBradleyMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.EFORTMessage">
            <summary>
            埃夫特机器人的消息对象
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.EFORTMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.EFORTMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.IMessage.EFORTMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.EFORTMessagePrevious">
            <summary>
            旧版的机器人的消息类对象，保留此类为了实现兼容
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessagePrevious.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.EFORTMessagePrevious.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.EFORTMessagePrevious.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否合法</returns>
        </member>
        <member name="M:Communication.Core.IMessage.EFORTMessagePrevious.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>标识信息</returns>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessagePrevious.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessagePrevious.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.EFORTMessagePrevious.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.FetchWriteMessage">
            <summary>
            西门子Fetch/Write消息解析协议
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.FetchWriteMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.FetchWriteMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.FetchWriteMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否合法</returns>
        </member>
        <member name="M:Communication.Core.IMessage.FetchWriteMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.FetchWriteMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.FetchWriteMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.FetchWriteMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.FinsMessage">
            <summary>
            用于欧姆龙通信的Fins协议的消息解析规则
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.FinsMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.FinsMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.FinsMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.IMessage.FinsMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息id</returns>
        </member>
        <member name="P:Communication.Core.IMessage.FinsMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.FinsMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.FinsMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.HslMessage">
            <summary>
            本组件系统使用的默认的消息规则，说明解析和反解析规则的
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.HslMessage.ProtocolHeadBytesLength">
            <summary>
            本协议的消息头长度
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.HslMessage.HeadBytes">
            <summary>
            头子节信息
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.HslMessage.ContentBytes">
            <summary>
            内容字节信息
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.HslMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查接收的数据是否合法
            </summary>
            <param name="token">令牌</param>
            <returns>是否合法</returns>
        </member>
        <member name="M:Communication.Core.IMessage.HslMessage.GetContentLengthByHeadBytes">
            <summary>
            从头子节信息中解析出接下来需要接收的数据长度
            </summary>
            <returns>接下来的数据长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.HslMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的特殊标识
            </summary>
            <returns>标识信息</returns>
        </member>
        <member name="P:Communication.Core.IMessage.HslMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.INetMessage">
            <summary>
            本系统的消息类，包含了各种解析规则，数据信息提取规则
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.INetMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.IMessage.INetMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.INetMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.INetMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.INetMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.KukaVarProxyMessage">
            <summary>
            Kuka机器人的 KRC4 控制器中的服务器KUKAVARPROXY
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.KukaVarProxyMessage.ProtocolHeadBytesLength">
            <summary>
            本协议的消息头长度
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.KukaVarProxyMessage.HeadBytes">
            <summary>
            头子节信息
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.KukaVarProxyMessage.ContentBytes">
            <summary>
            内容字节信息
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.KukaVarProxyMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查接收的数据是否合法
            </summary>
            <param name="token">令牌</param>
            <returns>是否合法</returns>
        </member>
        <member name="M:Communication.Core.IMessage.KukaVarProxyMessage.GetContentLengthByHeadBytes">
            <summary>
            从头子节信息中解析出接下来需要接收的数据长度
            </summary>
            <returns>接下来的数据长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.KukaVarProxyMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的特殊标识
            </summary>
            <returns>标识信息</returns>
        </member>
        <member name="P:Communication.Core.IMessage.KukaVarProxyMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.LsisFastEnetMessage">
            <summary>
            LSIS的PLC的FastEnet的消息定义
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.LsisFastEnetMessage.ProtocolHeadBytesLength">
            <summary>
            西门子头字节的长度
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.LsisFastEnetMessage.HeadBytes">
            <summary>
            头子节的数据
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.LsisFastEnetMessage.ContentBytes">
            <summary>
            内容字节的数据
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.LsisFastEnetMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节是否合法的判断
            </summary>
            <param name="token">令牌</param>
            <returns>是否合法的</returns>
        </member>
        <member name="M:Communication.Core.IMessage.LsisFastEnetMessage.GetContentLengthByHeadBytes">
            <summary>
            获取剩余的内容长度
            </summary>
            <returns>数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.LsisFastEnetMessage.GetHeadBytesIdentity">
            <summary>
            获取消息号，此处无效
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.LsisFastEnetMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.MelsecA1EBinaryMessage">
            <summary>
            三菱的A兼容1E帧协议解析规则
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecA1EBinaryMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecA1EBinaryMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecA1EBinaryMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecA1EBinaryMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns></returns>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecA1EBinaryMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecA1EBinaryMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecA1EBinaryMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.MelsecQnA3EAsciiMessage">
            <summary>
            基于MC协议的Qna兼容3E帧协议的ASCII通讯消息机制
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EAsciiMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecQnA3EAsciiMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecQnA3EAsciiMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecQnA3EAsciiMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EAsciiMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EAsciiMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EAsciiMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.MelsecQnA3EBinaryMessage">
            <summary>
            三菱的Qna兼容3E帧协议解析规则
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EBinaryMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecQnA3EBinaryMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecQnA3EBinaryMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.IMessage.MelsecQnA3EBinaryMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EBinaryMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EBinaryMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.MelsecQnA3EBinaryMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.ModbusTcpMessage">
            <summary>
            Modbus-Tcp协议支持的消息解析类
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.ModbusTcpMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.ModbusTcpMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.ModbusTcpMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.IMessage.ModbusTcpMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.ModbusTcpMessage.HeadBytes">
            <summary>
            消息头字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.ModbusTcpMessage.ContentBytes">
            <summary>
            消息内容字节
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.ModbusTcpMessage.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IMessage.S7Message">
            <summary>
            西门子S7协议的消息解析规则
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.S7Message.ProtocolHeadBytesLength">
            <summary>
            西门子头字节的长度
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.S7Message.HeadBytes">
            <summary>
            头子节的数据
            </summary>
        </member>
        <member name="P:Communication.Core.IMessage.S7Message.ContentBytes">
            <summary>
            内容字节的数据
            </summary>
        </member>
        <member name="M:Communication.Core.IMessage.S7Message.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节是否合法的判断
            </summary>
            <param name="token">令牌</param>
            <returns>是否合法的</returns>
        </member>
        <member name="M:Communication.Core.IMessage.S7Message.GetContentLengthByHeadBytes">
            <summary>
            获取剩余的内容长度
            </summary>
            <returns>数据内容长度</returns>
        </member>
        <member name="M:Communication.Core.IMessage.S7Message.GetHeadBytesIdentity">
            <summary>
            获取消息号，此处无效
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:Communication.Core.IMessage.S7Message.SendBytes">
            <summary>
            发送的字节信息
            </summary>
        </member>
        <member name="T:Communication.Core.IReadWriteNet">
            <summary>
            所有的和设备或是交互类统一读写标准
            </summary>
            <remarks>
            Modbus类，PLC类均实现了本接口，可以基于本接口实现统一所有的不同种类的设备的数据交互
            </remarks>
            <example>
            此处举例实现modbus，三菱，西门子三种设备的统一的数据交互
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\IReadWriteNet.cs" region="IReadWriteNetExample" title="IReadWriteNet示例" />
            </example>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Read(System.String,System.UInt16)">
            <summary>
            批量读取底层的数据信息，需要指定地址和长度，具体的结果取决于实现
            </summary>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadInt16(System.String)">
            <summary>
            读取16位的有符号整型
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的short数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取16位的有符号整型数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的short数组</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadUInt16(System.String)">
            <summary>
            读取16位的无符号整型
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ushort数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取16位的无符号整型数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的ushort数组</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadInt32(System.String)">
            <summary>
            读取32位的有符号整型
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的int数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取32位有符号整型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadUInt32(System.String)">
            <summary>
            读取32位的无符号整型
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的uint数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取设备的uint类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadInt64(System.String)">
            <summary>
            读取64位的有符号整型
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的long数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取64位的有符号整型数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadUInt64(System.String)">
            <summary>
            读取64位的无符号整型
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ulong数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取64位的无符号整型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadFloat(System.String)">
            <summary>
            读取单浮点精度的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的float数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取单浮点精度的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadDouble(System.String)">
            <summary>
            读取双浮点精度的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的double数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取双浮点精度的数据的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)">
            <summary>
            读取字符串数据，
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的string数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.ReadCustomer``1(System.String)">
            <summary>
            读取自定义的数据类型，需要继承自IDataTransfer接口
            </summary>
            <typeparam name="T">自定义的类型</typeparam>
            <param name="address">起始地址</param>
            <returns>带有成功标识的自定义类型数据</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Byte[])">
            <summary>
            写入byte数组数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Int16)">
            <summary>
            写入short数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Int16[])">
            <summary>
            写入short数据
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Int32)">
            <summary>
            写入int数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Int32[])">
            <summary>
            写入int[]数组
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Int64)">
            <summary>
            写入long数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Int64[])">
            <summary>
            写入long数组
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Single)">
            <summary>
            写入float数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Single[])">
            <summary>
            写入float数组
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Double)">
            <summary>
            写入double数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.Double[])">
            <summary>
            写入double数组
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.String)">
            <summary>
            写入字符串信息，编码为ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)">
            <summary>
            写入指定长度的字符串信息，编码为ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="length">字符串的长度</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:Communication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)">
            <summary>
            写入自定义类型的数据，该类型必须继承自IDataTransfer接口
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="T:Communication.Core.Net.IRobotNet">
            <summary>
            所有的机器人的统一读写标准
            </summary>
        </member>
        <member name="M:Communication.Core.Net.IRobotNet.Read(System.String)">
            <summary>
            根据地址读取机器人的原始的字节数据信息
            </summary>
            <param name="address">指定的地址信息，对于某些机器人无效</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:Communication.Core.Net.IRobotNet.ReadString(System.String)">
            <summary>
            根据地址读取机器人的字符串的数据信息
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:Communication.Core.Net.IRobotNet.Write(System.String,System.Byte[])">
            <summary>
            根据地址，来写入设备的相关的数据
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Core.Net.IRobotNet.Write(System.String,System.String)">
            <summary>
            根据地址，来写入设备相关的数据
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkAlienClient">
            <summary>
            异形客户端的基类，提供了基础的异形操作
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.#ctor">
            <summary>
            默认的无参构造方法
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.ThreadPoolLogin(System.Object)">
            <summary>
            登录的回调方法
            </summary>
            <param name="obj">传入的异步对象</param>
        </member>
        <member name="E:Communication.Core.Net.NetworkAlienClient.OnClientConnected">
            <summary>
            当有服务器连接上来的时候触发
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.GetResponse(System.Byte)">
            <summary>
            获取返回的命令信息
            </summary>
            <param name="status">状态</param>
            <returns>回发的指令信息</returns>
        </member>
        <member name="F:Communication.Core.Net.NetworkAlienClient.StatusOk">
            <summary>
            状态登录成功
            </summary>
        </member>
        <member name="F:Communication.Core.Net.NetworkAlienClient.StatusLoginRepeat">
            <summary>
            重复登录
            </summary>
        </member>
        <member name="F:Communication.Core.Net.NetworkAlienClient.StatusLoginForbidden">
            <summary>
            禁止登录
            </summary>
        </member>
        <member name="F:Communication.Core.Net.NetworkAlienClient.StatusPasswodWrong">
            <summary>
            密码错误
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.IsClientOnline(Communication.Core.Net.AlienSession)">
            <summary>
            检测当前的DTU是否在线
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.IsClientPermission(Communication.Core.Net.AlienSession)">
            <summary>
            检测当前的dtu是否允许登录
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.SetPassword(System.Byte[])">
            <summary>
            设置密码，长度为6
            </summary>
            <param name="password"></param>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.SetTrustClients(System.String[])">
            <summary>
            设置可信任的客户端列表
            </summary>
            <param name="clients"></param>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.AlienSessionLoginOut(Communication.Core.Net.AlienSession)">
            <summary>
            退出异形客户端
            </summary>
            <param name="session">异形客户端的会话</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkAlienClient.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns></returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkBase">
            <summary>
            本系统所有网络类的基类，该类为抽象类，无法进行实例化
            </summary>
            <remarks>
            network base class, support basic operation with socket
            </remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.#ctor">
            <summary>
            实例化一个NetworkBase对象
            </summary>
            <remarks>
            令牌的默认值为空，都是0x00
            </remarks>
        </member>
        <member name="P:Communication.Core.Net.NetworkBase.LogNet">
            <summary>
            组件的日志工具，支持日志记录
            </summary>
            <remarks>
            只要实例化即可以记录日志，实例化的对象需要实现接口 <see cref="T:Communication.LogNet.ILogNet"/> ，本组件提供了三个日志记录类，你可以实现基于 <see cref="T:Communication.LogNet.ILogNet"/>  的对象。</remarks>
            <example>
            如下的实例化适用于所有的Network及其派生类，以下举两个例子，三菱的设备类及服务器类
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample1" title="LogNet示例" />
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample2" title="LogNet示例" />
            </example>
        </member>
        <member name="P:Communication.Core.Net.NetworkBase.Token">
            <summary>
            网络类的身份令牌
            </summary>
            <remarks>
            适用于Hsl协议相关的网络通信类，不适用于设备交互类。
            </remarks>
            <example>
            此处以 <see cref="T:Communication.Enthernet.NetSimplifyServer"/> 服务器类及 <see cref="T:Communication.Enthernet.NetSimplifyClient"/> 客户端类的令牌设置举例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="TokenClientExample" title="Client示例" />
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="TokenServerExample" title="Server示例" />
            </example>
        </member>
        <member name="P:Communication.Core.Net.NetworkBase.UseSynchronousNet">
            <summary>
            是否使用同步的网络通讯
            </summary>
        </member>
        <member name="F:Communication.Core.Net.NetworkBase.CoreSocket">
            <summary>
            通讯类的核心套接字
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.ThreadPoolCheckTimeOut(System.Object)">
            <summary>
            检查网络套接字是否操作超时，需要对套接字进行封装
            </summary>
            <param name="obj">通常是 <see cref="T:Communication.HslTimeOut"/> 对象 </param>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.Receive(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            接收固定长度的字节数组
            </summary>
            <remarks>
            Receive Special Length Bytes
            </remarks>
            <param name="socket">网络通讯的套接字</param>
            <param name="length">准备接收的数据长度</param>
            <returns>包含了字节数据的结果类</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.ReceiveByMessage(System.Net.Sockets.Socket,System.Int32,Communication.Core.IMessage.INetMessage)">
            <summary>
            接收一条完整的 <seealso cref="T:Communication.Core.IMessage.INetMessage"/> 数据内容 ->
            Receive a complete <seealso cref="T:Communication.Core.IMessage.INetMessage"/> data content
            </summary>
            <param name="socket">网络的套接字</param>
            <param name="timeOut">超时时间</param>
            <param name="netMessage">消息的格式定义</param>
            <returns>带有是否成功的byte数组对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.Send(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            发送消息给套接字，直到完成的时候返回
            </summary>
            <param name="socket">网络套接字</param>
            <param name="data">字节数据</param>
            <returns>发送是否成功的结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.SendCallBack(System.IAsyncResult)">
            <summary>
            发送数据异步返回的方法
            </summary>
            <param name="ar">异步对象</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，默认超时时间为10秒钟
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="timeOut">连接的超时时间</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.CreateSocketAndConnect(System.Net.IPEndPoint,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址
            </summary>
            <param name="endPoint">连接的目标终结点</param>
            <param name="timeOut">连接的超时时间</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.ConnectCallBack(System.IAsyncResult)">
            <summary>
            当连接的结果返回
            </summary>
            <param name="ar">异步对象</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.ReadStream(System.IO.Stream,System.Byte[])">
            <summary>
            读取流中的数据到缓存区
            </summary>
            <param name="stream">数据流</param>
            <param name="buffer">缓冲区</param>
            <returns>带有成功标志的读取数据长度</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.WriteStream(System.IO.Stream,System.Byte[])">
            <summary>
            将缓冲区的数据写入到流里面去
            </summary>
            <param name="stream">数据流</param>
            <param name="buffer">缓冲区</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkBase.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkDataServerBase">
            <summary>
            所有虚拟的数据服务器的基类
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.#ctor">
            <summary>
            实例化一个默认的数据服务器的对象
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Read(System.String,System.UInt16)">
            <summary>
            从设备读取原始数据
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Byte[])">
            <summary>
            将原始数据写入设备
            </summary>
            <param name="address">起始地址</param>
            <param name="value">原始数据</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.LoadFromBytes(System.Byte[])">
            <summary>
            从字节数据加载数据信息
            </summary>
            <param name="content">字节数据</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.SaveToBytes">
            <summary>
            将数据信息存储到字节数组去
            </summary>
            <returns>所有的内容</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.SaveDataPool(System.String)">
            <summary>
            将本系统的数据池数据存储到指定的文件
            </summary>
            <param name="path">指定文件的路径</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.LoadDataPool(System.String)">
            <summary>
            从文件加载数据池信息
            </summary>
            <param name="path">文件路径</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="P:Communication.Core.Net.NetworkDataServerBase.ByteTransform">
            <summary>
            系统的数据转换接口
            </summary>
        </member>
        <member name="T:Communication.Core.Net.NetworkDataServerBase.DataReceivedDelegate">
            <summary>
            当接收到来自客户的数据信息时触发的对象，该数据可能来自tcp或是串口
            </summary>
            <param name="sender">本服务器对象</param>
            <param name="data">实际的数据信息</param>
        </member>
        <member name="E:Communication.Core.Net.NetworkDataServerBase.OnDataReceived">
            <summary>
            接收到数据的时候就行触发
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.RaiseDataReceived(System.Byte[])">
            <summary>
            触发一个数据接收的事件信息
            </summary>
            <param name="receive">接收数据信息</param>
        </member>
        <member name="P:Communication.Core.Net.NetworkDataServerBase.WordLength">
            <summary>
            单个数据字节的长度，西门子为2，三菱，欧姆龙，modbusTcp就为1，AB PLC无效
            </summary>
            <remarks>对设备来说，一个地址的数据对应的字节数，或是1个字节或是2个字节</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端登录后，进行Ip信息的过滤，然后触发本方法，也就是说之后的客户端需要
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endPoint">终端节点</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ThreadPoolLogin(System.Object)">
            <summary>
            当接收到了新的请求的时候执行的操作
            </summary>
            <param name="obj">异步对象</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.SetTrustedIpAddress(System.Collections.Generic.List{System.String})">
            <summary>
            设置并启动受信任的客户端登录并读写，如果为null，将关闭对客户端的ip验证
            </summary>
            <param name="clients">受信任的客户端列表</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.CheckIpAddressTrusted(System.String)">
            <summary>
            检查该Ip地址是否是受信任的
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <returns>是受信任的返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.GetTrustedClients">
            <summary>
            获取受信任的客户端列表
            </summary>
            <returns>字符串数据信息</returns>
        </member>
        <member name="P:Communication.Core.Net.NetworkDataServerBase.OnlineCount">
            <summary>
            在线的客户端的数量
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.AddClient(Communication.Core.Net.AppSession)">
            <summary>
            新增一个在线的客户端信息
            </summary>
            <param name="session">会话内容</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.RemoveClient(Communication.Core.Net.AppSession)">
            <summary>
            移除在线的客户端信息
            </summary>
            <param name="session">会话内容</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.CloseAction">
            <summary>
            关闭之后进行的操作
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadCustomer``1(System.String)">
            <summary>
            读取自定义类型的数据，需要规定解析规则
            </summary>
            <typeparam name="T">类型名称</typeparam>
            <param name="address">起始地址</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的ByteTransform实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:Communication.IDataTransfer"/>接口
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.WriteCustomer``1(System.String,``0)">
            <summary>
            写入自定义类型的数据到设备去，需要规定生成字节的方法
            </summary>
            <typeparam name="T">自定义类型</typeparam>
            <param name="address">起始地址</param>
            <param name="data">实例对象</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的<see cref="T:Communication.IDataTransfer"/>实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:Communication.IDataTransfer"/>接口
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteCustomerExample" title="WriteCustomer示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadInt16(System.String)">
            <summary>
            读取设备的short类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取设备的short类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadUInt16(System.String)">
            <summary>
            读取设备的ushort数据类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取设备的ushort类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadInt32(System.String)">
            <summary>
            读取设备的int类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取设备的int类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadUInt32(System.String)">
            <summary>
            读取设备的uint类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取设备的uint类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadFloat(System.String)">
            <summary>
            读取设备的float类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取设备的float类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadInt64(System.String)">
            <summary>
            读取设备的long类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取设备的long类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadUInt64(System.String)">
            <summary>
            读取设备的ulong类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取设备的ulong类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadDouble(System.String)">
            <summary>
            读取设备的double类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取设备的double类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ReadString(System.String,System.UInt16)">
            <summary>
            读取设备的字符串数据，编码为ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int16[])">
            <summary>
            向设备中写入short数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int16)">
            <summary>
            向设备中写入short数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt16[])">
            <summary>
            向设备中写入ushort数组，返回是否写入成功
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt16)">
            <summary>
            向设备中写入ushort数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int32[])">
            <summary>
            向设备中写入int数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int32)">
            <summary>
            向设备中写入int数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt32[])">
            <summary>
            向设备中写入uint数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt32)">
            <summary>
            向设备中写入uint数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Single[])">
            <summary>
            向设备中写入float数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Single)">
            <summary>
            向设备中写入float数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int64[])">
            <summary>
            向设备中写入long数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int64)">
            <summary>
            向设备中写入long数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt64[])">
            <summary>
            向P设备中写入ulong数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt64)">
            <summary>
            向设备中写入ulong数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Double[])">
            <summary>
            向设备中写入double数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.Double)">
            <summary>
            向设备中写入double数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.Write(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString2" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.WriteUnicodeString(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.WriteUnicodeString(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDataServerBase.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串数据</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkDeviceBase`2">
            <summary>
            设备类的基类，提供了基础的字节读写方法
            </summary>
            <typeparam name="TNetMessage">指定了消息的解析规则</typeparam>
            <typeparam name="TTransform">指定了数据转换的规则</typeparam>
            <remarks>需要继承实现采用使用。</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Read(System.String,System.UInt16)">
            <summary>
            从设备读取原始数据
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Byte[])">
            <summary>
            将原始数据写入设备
            </summary>
            <param name="address">起始地址</param>
            <param name="value">原始数据</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="P:Communication.Core.Net.NetworkDeviceBase`2.WordLength">
            <summary>
            单个数据字节的长度，西门子为2，三菱，欧姆龙，modbusTcp就为1，AB PLC无效
            </summary>
            <remarks>对设备来说，一个地址的数据对应的字节数，或是1个字节或是2个字节</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadCustomer``1(System.String)">
            <summary>
            读取自定义类型的数据，需要规定解析规则
            </summary>
            <typeparam name="T">类型名称</typeparam>
            <param name="address">起始地址</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的ByteTransform实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:Communication.IDataTransfer"/>接口
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.WriteCustomer``1(System.String,``0)">
            <summary>
            写入自定义类型的数据到设备去，需要规定生成字节的方法
            </summary>
            <typeparam name="T">自定义类型</typeparam>
            <param name="address">起始地址</param>
            <param name="data">实例对象</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的<see cref="T:Communication.IDataTransfer"/>实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:Communication.IDataTransfer"/>接口
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteCustomerExample" title="WriteCustomer示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadInt16(System.String)">
            <summary>
            读取设备的short类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取设备的short类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadUInt16(System.String)">
            <summary>
            读取设备的ushort数据类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取设备的ushort类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadInt32(System.String)">
            <summary>
            读取设备的int类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取设备的int类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadUInt32(System.String)">
            <summary>
            读取设备的uint类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取设备的uint类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadFloat(System.String)">
            <summary>
            读取设备的float类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取设备的float类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadInt64(System.String)">
            <summary>
            读取设备的long类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取设备的long类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadUInt64(System.String)">
            <summary>
            读取设备的ulong类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取设备的ulong类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadDouble(System.String)">
            <summary>
            读取设备的double类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取设备的double类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadString(System.String,System.UInt16)">
            <summary>
            读取设备的字符串数据，编码为ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <summary>
            读取设备的字符串数据，编码为指定的编码信息
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <param name="encoding">编码机制</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Int16[])">
            <summary>
            向设备中写入short数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Int16)">
            <summary>
            向设备中写入short数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.UInt16[])">
            <summary>
            向设备中写入ushort数组，返回是否写入成功
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.UInt16)">
            <summary>
            向设备中写入ushort数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Int32[])">
            <summary>
            向设备中写入int数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Int32)">
            <summary>
            向设备中写入int数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.UInt32[])">
            <summary>
            向设备中写入uint数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.UInt32)">
            <summary>
            向设备中写入uint数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Single[])">
            <summary>
            向设备中写入float数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Single)">
            <summary>
            向设备中写入float数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Int64[])">
            <summary>
            向设备中写入long数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Int64)">
            <summary>
            向设备中写入long数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.UInt64[])">
            <summary>
            向P设备中写入ulong数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.UInt64)">
            <summary>
            向设备中写入ulong数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Double[])">
            <summary>
            向设备中写入double数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.Double)">
            <summary>
            向设备中写入double数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.String,System.Text.Encoding)">
            <summary>
            向设备中写入指定编码的字符串
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="encoding">字节编码</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString2" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <summary>
            向设备中写入指定长度并且指定编码的字符串,超出截断，不够补0
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的长度，按照转换后的字节计算</param>
            <param name="encoding">字符编码</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString2" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.WriteUnicodeString(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.WriteUnicodeString(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDeviceBase`2.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串数据</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkDoubleBase`2">
            <summary>
            支持长连接，短连接两个模式的通用客户端基类 ->
            Universal client base class that supports long connections and short connections to two modes
            </summary>
            <example>
            无，请使用继承类实例化，然后进行数据交互。
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.#ctor">
            <summary>
            默认的无参构造函数 -> Default no-parameter constructor
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkDoubleBase`2.ByteTransform">
            <summary>
            当前客户端的数据变换机制，当你需要从字节数据转换类型数据的时候需要。->
            The current client's data transformation mechanism is required when you need to convert type data from byte data.
            </summary>
            <example>
            主要是用来转换数据类型的，下面仅仅演示了2个方法，其他的类型转换，类似处理。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ByteTransform" title="ByteTransform示例" />
            </example>
        </member>
        <member name="P:Communication.Core.Net.NetworkDoubleBase`2.ConnectTimeOut">
            <summary>
            获取或设置连接的超时时间，单位是毫秒 -> Gets or sets the timeout for the connection, in milliseconds
            </summary>
            <example>
            设置1秒的超时的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ConnectTimeOutExample" title="ConnectTimeOut示例" />
            </example>
            <remarks>
            不适用于异形模式的连接。
            </remarks>
        </member>
        <member name="P:Communication.Core.Net.NetworkDoubleBase`2.ReceiveTimeOut">
            <summary>
            获取或设置接收服务器反馈的时间，如果为负数，则不接收反馈 -> 
            Gets or sets the time to receive server feedback, and if it is a negative number, does not receive feedback
            </summary>
            <example>
            设置1秒的接收超时的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReceiveTimeOutExample" title="ReceiveTimeOut示例" />
            </example>
            <remarks>
            超时的通常原因是服务器端没有配置好，导致访问失败，为了不卡死软件，所以有了这个超时的属性。
            </remarks>
        </member>
        <member name="P:Communication.Core.Net.NetworkDoubleBase`2.IpAddress">
            <summary>
            获取或是设置服务器的IP地址
            </summary>
            <remarks>
            最好实在初始化的时候进行指定，当使用短连接的时候，支持动态更改，切换；当使用长连接后，无法动态更改
            </remarks>
            <example>
            以下举例modbus-tcp的短连接及动态更改ip地址的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="IpAddressExample" title="IpAddress示例" />
            </example>
        </member>
        <member name="P:Communication.Core.Net.NetworkDoubleBase`2.Port">
            <summary>
            获取或设置服务器的端口号
            </summary>
            <remarks>
            最好实在初始化的时候进行指定，当使用短连接的时候，支持动态更改，切换；当使用长连接后，无法动态更改
            </remarks>
            <example>
            动态更改请参照IpAddress属性的更改。
            </example>
        </member>
        <member name="P:Communication.Core.Net.NetworkDoubleBase`2.ConnectionId">
            <summary>
            当前连接的唯一ID号，默认为长度20的guid码加随机数组成，方便列表管理，也可以自己指定
            </summary>
            <remarks>
            Current Connection ID, conclude guid and random data, also, you can spcified
            </remarks>
        </member>
        <member name="P:Communication.Core.Net.NetworkDoubleBase`2.AlienSession">
            <summary>
            当前的异形连接对象，如果设置了异形连接的话
            </summary>
            <remarks>
            具体的使用方法请参照Demo项目中的异形modbus实现。
            </remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.SetPersistentConnection">
            <summary>
            在读取数据之前可以调用本方法将客户端设置为长连接模式，相当于跳过了ConnectServer的结果验证，对异形客户端无效
            </summary>
            <example>
            以下的方式演示了另一种长连接的机制
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="SetPersistentConnectionExample" title="SetPersistentConnection示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.ConnectServer">
            <summary>
            切换短连接模式到长连接模式，后面的每次请求都共享一个通道
            </summary>
            <returns>返回连接结果，如果失败的话（也即IsSuccess为False），包含失败信息</returns>
            <example>
              简单的连接示例，调用该方法后，连接设备，创建一个长连接的对象，后续的读写操作均公用一个连接对象。
              <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="Connect1" title="连接设备" />
              如果想知道是否连接成功，请参照下面的代码。
              <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="Connect2" title="判断连接结果" />
            </example> 
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.ConnectServer(Communication.Core.Net.AlienSession)">
            <summary>
            使用指定的套接字创建异形客户端
            </summary>
            <param name="session">异形客户端对象，查看<seealso cref="T:Communication.Core.Net.NetworkAlienClient"/>类型创建的客户端</param>
            <returns>通常都为成功</returns>
            <example>
              简单的创建示例。
              <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="AlienConnect1" title="连接设备" />
              如果想知道是否创建成功。通常都是成功。
              <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="AlienConnect2" title="判断连接结果" />
            </example> 
            <remarks>
            不能和之前的长连接和短连接混用，详细参考 Demo程序 
            </remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.ConnectClose">
            <summary>
            在长连接模式下，断开服务器的连接，并切换到短连接模式
            </summary>
            <returns>关闭连接，不需要查看IsSuccess属性查看</returns>
            <example>
            直接关闭连接即可，基本上是不需要进行成功的判定
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ConnectCloseExample" title="关闭连接结果" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            连接上服务器后需要进行的初始化操作
            </summary>
            <param name="socket">网络套接字</param>
            <returns>是否初始化成功，依据具体的协议进行重写</returns>
            <example>
            有些协议不需要握手信号，比如三菱的MC协议，Modbus协议，西门子和欧姆龙就存在握手信息，此处的例子是继承本类后重写的西门子的协议示例
            <code lang="cs" source="Communication_Net45\Profinet\Siemens\SiemensS7Net.cs" region="NetworkDoubleBase Override" title="西门子重连示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <summary>
            在将要和服务器进行断开的情况下额外的操作，需要根据对应协议进行重写
            </summary>
            <param name="socket">网络套接字</param>
            <example>
            目前暂无相关的示例，组件支持的协议都不用实现这个方法。
            </example>
            <returns>当断开连接时额外的操作结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.GetAvailableSocket">
            <summary>
            获取本次操作的可用的网络套接字
            </summary>
            <returns>是否成功，如果成功，使用这个套接字</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.CreateSocketAndInitialication">
            <summary>
            连接并初始化网络套接字
            </summary>
            <returns>带有socket的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.GetNewNetMessage">
            <summary>
            指示如何创建一个新的消息对象
            </summary>
            <returns>消息对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            在其他指定的套接字上，使用报文来通讯，传入需要发送的消息，返回一条完整的数据指令
            </summary>
            <param name="socket">指定的套接字</param>
            <param name="send">发送的完整的报文信息</param>
            <remarks>
            无锁的基于套接字直接进行叠加协议的操作。
            </remarks>
            <example>
            假设你有一个自己的socket连接了设备，本组件可以直接基于该socket实现modbus读取，三菱读取，西门子读取等等操作，前提是该服务器支持多协议，虽然这个需求听上去比较变态，但本组件支持这样的操作。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReadFromCoreServerExample1" title="ReadFromCoreServer示例" />
            </example>
            <returns>接收的完整的报文信息</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.ReadFromCoreServer(System.Byte[])">
            <summary>
            使用底层的数据报文来通讯，传入需要发送的消息，返回一条完整的数据指令
            </summary>
            <param name="send">发送的完整的报文信息</param>
            <returns>接收的完整的报文信息</returns>
            <remarks>
            本方法用于实现本组件还未实现的一些报文功能，例如有些modbus服务器会有一些特殊的功能码支持，需要收发特殊的报文，详细请看示例
            </remarks>
            <example>
            此处举例有个modbus服务器，有个特殊的功能码0x09，后面携带子数据0x01即可，发送字节为 0x00 0x00 0x00 0x00 0x00 0x03 0x01 0x09 0x01
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReadFromCoreServerExample2" title="ReadFromCoreServer示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkDoubleBase`2.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkFileServerBase">
            <summary>
            文件服务器类的基类，为直接映射文件模式和间接映射文件模式提供基础的方法支持
            </summary>
        </member>
        <member name="F:Communication.Core.Net.NetworkFileServerBase.m_dictionary_files_marks">
            <summary>
            所有文件操作的词典锁
            </summary>
        </member>
        <member name="F:Communication.Core.Net.NetworkFileServerBase.dict_hybirdLock">
            <summary>
            词典的锁
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.GetFileMarksFromDictionaryWithFileName(System.String)">
            <summary>
            获取当前文件的读写锁，如果没有会自动创建
            </summary>
            <param name="filename">完整的文件路径</param>
            <returns>读写锁</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.ReceiveInformationHead(System.Net.Sockets.Socket,System.Int32@,System.String@,System.String@,System.String@,System.String@)">
            <summary>
            接收本次操作的信息头数据
            </summary>
            <param name="socket">网络套接字</param>
            <param name="command">命令</param>
            <param name="fileName">文件名</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.CreateRandomFileName">
            <summary>
            获取一个随机的文件名，由GUID码和随机数字组成
            </summary>
            <returns>文件名</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.ReturnAbsoluteFilePath(System.String,System.String,System.String)">
            <summary>
            返回服务器的绝对路径
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.ReturnAbsoluteFileName(System.String,System.String,System.String,System.String)">
            <summary>
            返回服务器的绝对路径
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.ReturnRelativeFileName(System.String,System.String,System.String,System.String)">
            <summary>
            返回相对路径的名称
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.MoveFileToNewFile(System.String,System.String)">
            <summary>
            移动一个文件到新的文件去
            </summary>
            <param name="fileNameOld">旧的文件名称</param>
            <param name="fileNameNew">新的文件名称</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.DeleteFileAndCheck(System.Net.Sockets.Socket,System.String)">
            <summary>
            删除文件并回发确认信息，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="fullname">完整路径的文件名称</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.StartInitialization">
            <summary>
            服务器启动时的操作
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.CheckFolderAndCreate">
            <summary>
            检查文件夹是否存在，不存在就创建
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkFileServerBase.FilesDirectoryPath">
            <summary>
            文件所存储的路径
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.GetDirectoryFiles(System.String,System.String,System.String)">
            <summary>
            获取文件夹的所有文件列表
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>文件列表</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.GetDirectories(System.String,System.String,System.String)">
            <summary>
            获取文件夹的所有文件夹列表
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>文件夹列表</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkFileServerBase.ToString">
            <summary>
            获取本对象的字符串标识形式
            </summary>
            <returns>对象信息</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkServerBase">
            <summary>
            服务器程序的基础类
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkServerBase.IsStarted">
            <summary>
            服务器引擎是否启动
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkServerBase.Port">
            <summary>
            服务器的端口号
            </summary>
            <remarks>需要在服务器启动之前设置为有效</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.AsyncAcceptCallback(System.IAsyncResult)">
            <summary>
            异步传入的连接申请请求
            </summary>
            <param name="iar"></param>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.ThreadPoolLogin(System.Object)">
            <summary>
            用于登录的回调方法
            </summary>
            <param name="obj">socket对象</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.StartInitialization">
            <summary>
            服务器启动时额外的初始化信息
            </summary>
            <remarks>需要在派生类中重写</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.ServerStart(System.Int32)">
            <summary>
            启动服务器的引擎
            </summary>
            <param name="port">指定一个端口号</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.ServerStart">
            <summary>
            使用已经配置好的端口启动服务器的引擎
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.CloseAction">
            <summary>
            服务器关闭的时候需要做的事情
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.ServerClose">
            <summary>
            关闭服务器的引擎
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkServerBase.ConnectHslAlientClient(System.String,System.Int32,System.String)">
            <summary>
            创建一个指定的异形客户端连接，使用Hsl协议来发送注册包
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="dtuId">设备唯一ID号，最长11</param>
            <returns>是否成功连接</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkUdpBase">
            <summary>
            基础的Udp的通信对象
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpBase.#ctor">
            <summary>
            实例化一个默认的方法
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkUdpBase.IpAddress">
            <summary>
            Ip地址
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkUdpBase.Port">
            <summary>
            端口号信息
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkUdpBase.ReceiveTimeout">
            <summary>
            接收反馈的超时时间
            </summary>
        </member>
        <member name="P:Communication.Core.Net.NetworkUdpBase.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度，特殊情况的时候需要调整
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Byte[])">
            <summary>
            核心的数据交互读取
            </summary>
            <param name="value">完整的报文内容</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkUdpDeviceBase`1">
            <summary>
            Udp报文协议的内容传送
            </summary>
            <typeparam name="TTransform">数据转换类型对象</typeparam>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Read(System.String,System.UInt16)">
            <summary>
            从设备读取原始数据
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Byte[])">
            <summary>
            将原始数据写入设备
            </summary>
            <param name="address">起始地址</param>
            <param name="value">原始数据</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="P:Communication.Core.Net.NetworkUdpDeviceBase`1.WordLength">
            <summary>
            单个数据字节的长度，西门子为2，三菱，欧姆龙，modbusTcp就为1
            </summary>
            <remarks>对设备来说，一个地址的数据对应的字节数，或是1个字节或是2个字节</remarks>
        </member>
        <member name="P:Communication.Core.Net.NetworkUdpDeviceBase`1.ByteTransform">
            <summary>
            当前客户端的数据变换机制，当你需要从字节数据转换类型数据的时候需要。
            </summary>
            <example>
            主要是用来转换数据类型的，下面仅仅演示了2个方法，其他的类型转换，类似处理。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ByteTransform" title="ByteTransform示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadCustomer``1(System.String)">
            <summary>
            读取自定义类型的数据，需要规定解析规则
            </summary>
            <typeparam name="T">类型名称</typeparam>
            <param name="address">起始地址</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的ByteTransform实例，才能调用该方法。
            </remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.WriteCustomer``1(System.String,``0)">
            <summary>
            写入自定义类型的数据到设备去，需要规定生成字节的方法
            </summary>
            <typeparam name="T">自定义类型</typeparam>
            <param name="address">起始地址</param>
            <param name="data">实例对象</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的<see cref="T:Communication.IDataTransfer"/>实例，才能调用该方法。
            </remarks>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadInt16(System.String)">
            <summary>
            读取设备的short类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取设备的short类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadUInt16(System.String)">
            <summary>
            读取设备的ushort数据类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取设备的ushort类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadInt32(System.String)">
            <summary>
            读取设备的int类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取设备的int类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadUInt32(System.String)">
            <summary>
            读取设备的uint类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取设备的uint类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadFloat(System.String)">
            <summary>
            读取设备的float类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取设备的float类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadInt64(System.String)">
            <summary>
            读取设备的long类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取设备的long类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadUInt64(System.String)">
            <summary>
            读取设备的ulong类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取设备的ulong类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadDouble(System.String)">
            <summary>
            读取设备的double类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取设备的double类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ReadString(System.String,System.UInt16)">
            <summary>
            读取设备的字符串数据，编码为ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Int16[])">
            <summary>
            向设备中写入short数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Int16)">
            <summary>
            向设备中写入short数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.UInt16[])">
            <summary>
            向设备中写入ushort数组，返回是否写入成功
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.UInt16)">
            <summary>
            向设备中写入ushort数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Int32[])">
            <summary>
            向设备中写入int数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Int32)">
            <summary>
            向设备中写入int数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.UInt32[])">
            <summary>
            向设备中写入uint数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.UInt32)">
            <summary>
            向设备中写入uint数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Single[])">
            <summary>
            向设备中写入float数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Single)">
            <summary>
            向设备中写入float数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Int64[])">
            <summary>
            向设备中写入long数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Int64)">
            <summary>
            向设备中写入long数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.UInt64[])">
            <summary>
            向P设备中写入ulong数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.UInt64)">
            <summary>
            向设备中写入ulong数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Double[])">
            <summary>
            向设备中写入double数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.Double)">
            <summary>
            向设备中写入double数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.Write(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.WriteUnicodeString(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.WriteUnicodeString(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkUdpDeviceBase`1.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Core.Net.NetworkXBase">
            <summary>
            包含了主动异步接收的方法实现和文件类异步读写的实现
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.#ctor">
            <summary>
            默认的无参构造方法
            </summary>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendBytesAsync(Communication.Core.Net.AppSession,System.Byte[])">
            <summary>
            发送数据的方法
            </summary>
            <param name="session">通信用的核心对象</param>
            <param name="content">完整的字节信息</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendCallBack(System.IAsyncResult)">
            <summary>
            发送回发方法
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReBeginReceiveHead(Communication.Core.Net.AppSession,System.Boolean)">
            <summary>
            重新开始接收下一次的数据传递
            </summary>
            <param name="session">网络状态</param>
            <param name="isProcess">是否触发数据处理</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.HeadBytesReceiveCallback(System.IAsyncResult)">
            <summary>
            指令头接收方法
            </summary>
            <param name="ar">异步状态信息</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ContentReceiveCallback(System.IAsyncResult)">
            <summary>
            数据内容接收方法
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.CheckRemoteToken(System.Byte[])">
            <summary>
            检查当前的头子节信息的令牌是否是正确的
            </summary>
            <param name="headBytes">头子节数据</param>
            <returns>令牌是验证成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendBaseAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Byte[])">
            <summary>
            [自校验] 发送字节数据并确认对方接收完成数据，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="headcode">头指令</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendBytesAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Byte[])">
            <summary>
            [自校验] 发送字节数据并确认对方接收完成数据，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendStringAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String)">
            <summary>
            [自校验] 直接发送字符串数据并确认对方接收完成数据，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendFileStreamToSocket(System.Net.Sockets.Socket,System.String,System.Int64,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将文件数据发送至套接字，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="filename">完整的文件路径</param>
            <param name="filelength">文件的长度</param>
            <param name="report">进度报告器</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将文件数据发送至套接字，具体发送细节将在继承类中实现，如果结果异常，则结束通讯
            </summary>
            <param name="socket">套接字</param>
            <param name="filename">文件名称，文件必须存在</param>
            <param name="servername">远程端的文件名称</param>
            <param name="filetag">文件的额外标签</param>
            <param name="fileupload">文件的上传人</param>
            <param name="sendReport">发送进度报告</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将流数据发送至套接字，具体发送细节将在继承类中实现，如果结果异常，则结束通讯
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">文件名称，文件必须存在</param>
            <param name="servername">远程端的文件名称</param>
            <param name="filetag">文件的额外标签</param>
            <param name="fileupload">文件的上传人</param>
            <param name="sendReport">发送进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReceiveAndCheckBytes(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 接收一条完整的同步数据，包含头子节和内容字节，基础的数据，如果结果异常，则结束通讯
            </summary>
            <param name="socket">套接字</param>
            <param name="timeout">超时时间设置，如果为负数，则不检查超时</param>
            <returns>包含是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException">result</exception>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReceiveStringContentFromSocket(System.Net.Sockets.Socket)">
            <summary>
            [自校验] 从网络中接收一个字符串数据，如果结果异常，则结束通讯
            </summary>
            <param name="socket">套接字</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReceiveBytesContentFromSocket(System.Net.Sockets.Socket)">
            <summary>
            [自校验] 从网络中接收一串字节数据，如果结果异常，则结束通讯
            </summary>
            <param name="socket">套接字的网络</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReceiveFileHeadFromSocket(System.Net.Sockets.Socket)">
            <summary>
            [自校验] 从套接字中接收文件头信息
            </summary>
            <param name="socket">套接字的网络</param>
            <returns>包含文件信息的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 从网络中接收一个文件，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="savename">接收文件后保存的文件名</param>
            <param name="receiveReport">接收进度报告</param>
            <returns>包含文件信息的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 从网络中接收一个文件，写入数据流，如果结果异常，则结束通讯，参数顺序文件名，文件大小，文件标识，上传人
            </summary>
            <param name="socket">网络套接字</param>
            <param name="stream">等待写入的数据流</param>
            <param name="receiveReport">接收进度报告</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.DeleteFileByName(System.String)">
            <summary>
            删除文件的操作
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.PreprocessFolderName(System.String)">
            <summary>
            预处理文件夹的名称，除去文件夹名称最后一个'\'，如果有的话
            </summary>
            <param name="folder">文件夹名称</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.DataProcessingCenter(Communication.Core.Net.AppSession,System.Int32,System.Int32,System.Byte[])">
            <summary>
            数据处理中心，应该继承重写
            </summary>
            <param name="session">连接状态</param>
            <param name="protocol">协议头</param>
            <param name="customer">用户自定义</param>
            <param name="content">数据内容</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SocketReceiveException(Communication.Core.Net.AppSession,System.Exception)">
            <summary>
            接收出错的时候进行处理
            </summary>
            <param name="session">会话内容</param>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.AppSessionRemoteClose(Communication.Core.Net.AppSession)">
            <summary>
            当远端的客户端关闭连接时触发
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ReceiveLong(System.Net.Sockets.Socket)">
            <summary>
            从网络中接收Long数据
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendLong(System.Net.Sockets.Socket,System.Int64)">
            <summary>
            将long数据发送到套接字
            </summary>
            <param name="socket"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.SendStream(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            发送一个流的所有数据到网络套接字
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">内存流</param>
            <param name="receive">发送的数据长度</param>
            <param name="report">进度报告的委托</param>
            <param name="reportByPercent">进度报告是否按照百分比报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.WriteStream(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            从套接字中接收所有的数据然后写入到流当中去
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">数据流</param>
            <param name="totalLength">所有数据的长度</param>
            <param name="report">进度报告</param>
            <param name="reportByPercent">进度报告是否按照百分比</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Core.Net.NetworkXBase.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Core.Net.AlienSession">
            <summary>
            异形客户端的异步对象
            </summary>
        </member>
        <member name="M:Communication.Core.Net.AlienSession.#ctor">
            <summary>
            实例化一个默认的参数
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AlienSession.Socket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AlienSession.DTU">
            <summary>
            唯一的标识
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AlienSession.IsStatusOk">
            <summary>
            指示当前的网络状态
            </summary>
        </member>
        <member name="T:Communication.Core.Net.AppSession">
            <summary>
            网络会话信息
            </summary>
        </member>
        <member name="M:Communication.Core.Net.AppSession.#ctor">
            <summary>
            实例化一个构造方法
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.WorkSocket">
            <summary>
            传输数据的对象
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.IpAddress">
            <summary>
            IP地址
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.IpEndPoint">
            <summary>
            此连接对象连接的远程客户端
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.LoginAlias">
            <summary>
            远程对象的别名
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.HeartTime">
            <summary>
            心跳验证的时间点
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.ClientType">
            <summary>
            客户端的类型
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.ClientUniqueID">
            <summary>
            客户端唯一的标识
            </summary>
        </member>
        <member name="F:Communication.Core.Net.AppSession.UdpEndPoint">
            <summary>
            UDP通信中的远程端
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.BytesHead">
            <summary>
            指令头缓存
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.AlreadyReceivedHead">
            <summary>
            已经接收的指令头长度
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.BytesContent">
            <summary>
            数据内容缓存
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.AlreadyReceivedContent">
            <summary>
            已经接收的数据内容长度
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AppSession.KeyGroup">
            <summary>
            用于关键字分类使用
            </summary>
        </member>
        <member name="M:Communication.Core.Net.AppSession.Clear">
            <summary>
            清除本次的接收内容
            </summary>
        </member>
        <member name="M:Communication.Core.Net.AppSession.ToString">
            <summary>
            返回表示当前对象的字符串，以IP，端口，客户端名称组成
            </summary>
            <returns>字符串数据</returns>
        </member>
        <member name="P:Communication.Core.Net.AsyncStateSend.WorkSocket">
            <summary>
            传输数据的对象
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AsyncStateSend.Content">
            <summary>
            发送的数据内容
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AsyncStateSend.AlreadySendLength">
            <summary>
            已经发送长度
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AsyncStateSend.Key">
            <summary>
            关键字
            </summary>
        </member>
        <member name="P:Communication.Core.Net.AsyncStateSend.ClientId">
            <summary>
            客户端的标识
            </summary>
        </member>
        <member name="T:Communication.Core.Net.FileStateObject">
            <summary>
            文件传送的异步对象
            </summary>
        </member>
        <member name="P:Communication.Core.Net.FileStateObject.Stream">
            <summary>
            操作的流
            </summary>
        </member>
        <member name="T:Communication.Core.Net.StateObject">
            <summary>
            网络中的异步对象
            </summary>
        </member>
        <member name="M:Communication.Core.Net.StateObject.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:Communication.Core.Net.StateObject.#ctor(System.Int32)">
            <summary>
            实例化一个对象，指定接收或是发送的数据长度
            </summary>
            <param name="length">数据长度</param>
        </member>
        <member name="P:Communication.Core.Net.StateObject.UniqueId">
            <summary>
            唯一的一串信息
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateObject.WorkSocket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateObject.IsClose">
            <summary>
            是否关闭了通道
            </summary>
        </member>
        <member name="M:Communication.Core.Net.StateObject.Clear">
            <summary>
            清空旧的数据
            </summary>
        </member>
        <member name="T:Communication.Core.Net.StateOneBase">
            <summary>
            异步消息的对象
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateOneBase.DataLength">
            <summary>
            本次接收或是发送的数据长度
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateOneBase.AlreadyDealLength">
            <summary>
            已经处理的字节长度
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateOneBase.WaitDone">
            <summary>
            操作完成的信号
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateOneBase.Buffer">
            <summary>
            缓存器
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateOneBase.IsError">
            <summary>
            是否发生了错误
            </summary>
        </member>
        <member name="P:Communication.Core.Net.StateOneBase.ErrerMsg">
            <summary>
            错误消息
            </summary>
        </member>
        <member name="T:Communication.Core.NetSupport">
            <summary>
            静态的方法支持类，提供一些网络的静态支持，支持从套接字从同步接收指定长度的字节数据，并支持报告进度。
            </summary>
            <remarks>
            在接收指定数量的字节数据的时候，如果一直接收不到，就会发生假死的状态。接收的数据时保存在内存里的，不适合大数据块的接收。
            </remarks>
            <example>
            一个接收的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetSupport.cs" region="ReadBytesFromSocketExample2" title="ReadBytesFromSocket示例" />
            </example>
        </member>
        <member name="F:Communication.Core.NetSupport.SocketBufferSize">
            <summary>
            Socket传输中的缓冲池大小
            </summary>
        </member>
        <member name="M:Communication.Core.NetSupport.ThreadPoolCheckConnect(Communication.HslTimeOut,System.Int32)">
            <summary>
            检查是否超时的静态方法
            </summary>
            <param name="timeout">数据封送对象</param>
            <param name="millisecond">超时的时间</param>
        </member>
        <member name="M:Communication.Core.NetSupport.ThreadPoolCheckTimeOut(System.Object)">
            <summary>
            检查是否超时的方法信息
            </summary>
            <param name="obj">socket对象</param>
        </member>
        <member name="M:Communication.Core.NetSupport.ReadBytesFromSocket(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            读取socket数据的基础方法，只适合用来接收指令头，或是同步数据
            </summary>
            <param name="socket">通信对象</param>
            <param name="receive">接收的长度</param>
            <returns>接收到的字节数据</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Net.Sockets.SocketException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <example>
            接收数据的举例，简单的接收20个字节长度的数据。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetSupport.cs" region="ReadBytesFromSocketExample1" title="ReadBytesFromSocket示例" />
            如何接收不定长度的数据呢？我们可以将一条数据拆分成2次接收，第一次是接收8个固定的字节，解析成长度，再接收真实的数据。
             <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetSupport.cs" region="ReadBytesFromSocketExample3" title="ReadBytesFromSocket示例" />
            </example>
        </member>
        <member name="M:Communication.Core.NetSupport.ReadBytesFromSocket(System.Net.Sockets.Socket,System.Int32,System.Action{System.Int64,System.Int64},System.Boolean,System.Boolean)">
            <summary>
            读取socket数据的基础方法，只适合用来接收指令头，或是同步数据
            </summary>
            <param name="socket">通信对象</param>
            <param name="receive">接收的长度</param>
            <param name="report">用于报告接收进度的对象</param>
            <param name="reportByPercent">是否按照百分比报告进度</param>
            <param name="response">是否回发接收数据长度</param>
            <returns>接收到的字节数据</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Net.Sockets.SocketException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <example>
            接收数据的举例，输出报告，不根据百分比来产生报告，不回复接收进度。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetSupport.cs" region="ReadBytesFromSocketExample2" title="ReadBytesFromSocket示例" />
            </example>
        </member>
        <member name="M:Communication.Core.NetSupport.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte)">
            <summary>
            接收一行命令数据，需要自己指定这个结束符
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endCode">结束符信息</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:Communication.Core.NetSupport.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte,System.Byte)">
            <summary>
            接收一行命令数据，需要自己指定这个结束符
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endCode1">结束符1信息</param>
            <param name="endCode2">结束符2信息</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:Communication.Core.NetSupport.WriteStreamFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            从socket套接字读取数据并写入流中，必然报告进度
            </summary>
            <param name="socket">通信对象</param>
            <param name="stream">stream</param>
            <param name="receive">接收的长度</param>
            <param name="report">用于报告接收进度的对象</param>
            <param name="reportByPercent">是否按照百分比报告进度</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Net.Sockets.SocketException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <example>
            举例从socket读取数据，然后写入到文件流中
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetSupport.cs" region="WriteStreamFromSocketExample" title="WriteStreamFromSocket示例" />
            </example>
        </member>
        <member name="M:Communication.Core.NetSupport.WriteSocketFromStream(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            读取流并将数据写入socket
            </summary>
            <param name="stream">文件流</param>
            <param name="socket">连接的套接字</param>
            <param name="length">返回的文件长度</param>
            <param name="report">发送的进度报告</param>
            <param name="reportByPercent">是否按照百分比报告进度</param>
            <exception cref="T:System.Net.Sockets.SocketException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <example>
            举例从文件读取数据，然后写入到套接字中，相当于发送文件到socket
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetSupport.cs" region="WriteSocketFromStreamExample" title="WriteSocketFromStream示例" />
            </example>
        </member>
        <member name="T:Communication.Core.CoordinationStatus">
            <summary>
            线程的协调逻辑状态
            </summary>
        </member>
        <member name="F:Communication.Core.CoordinationStatus.AllDone">
            <summary>
            所有项完成
            </summary>
        </member>
        <member name="F:Communication.Core.CoordinationStatus.Timeout">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:Communication.Core.CoordinationStatus.Cancel">
            <summary>
            任务取消
            </summary>
        </member>
        <member name="T:Communication.Core.AsyncCoordinator">
            <summary>
            一个线程协调逻辑类，详细参考书籍《CLR Via C#》page:681
            这个类可惜没有报告进度的功能
            </summary>
        </member>
        <member name="M:Communication.Core.AsyncCoordinator.AboutToBegin(System.Int32)">
            <summary>
            每次的操作任务开始前必须调用该方法
            </summary>
            <param name="opsToAdd"></param>
        </member>
        <member name="M:Communication.Core.AsyncCoordinator.JustEnded">
            <summary>
            在一次任务处理好操作之后，必须调用该方法
            </summary>
        </member>
        <member name="M:Communication.Core.AsyncCoordinator.AllBegun(System.Action{Communication.Core.CoordinationStatus},System.Int32)">
            <summary>
            该方法必须在发起所有的操作之后调用
            </summary>
            <param name="callback">回调方法</param>
            <param name="timeout">超时时间</param>
        </member>
        <member name="M:Communication.Core.AsyncCoordinator.TimeExpired(System.Object)">
            <summary>
            超时的方法
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Communication.Core.AsyncCoordinator.Cancel">
            <summary>
            取消任务的执行
            </summary>
        </member>
        <member name="M:Communication.Core.AsyncCoordinator.ReportStatus(Communication.Core.CoordinationStatus)">
            <summary>
            生成一次报告
            </summary>
            <param name="status">报告的状态</param>
        </member>
        <member name="M:Communication.Core.AsyncCoordinator.Maxinum(System.Int32@,System.Func{System.Int32,System.Int32})">
            <summary>
            乐观的并发方法模型，具体参照《CLR Via C#》page:686
            </summary>
            <param name="target">唯一的目标数据</param>
            <param name="change">修改数据的算法</param>
            <returns></returns>
        </member>
        <member name="T:Communication.Core.HslAsyncCoordinator">
            <summary>
            一个用于高性能，乐观并发模型控制操作的类，允许一个方法(隔离方法)的安全单次执行
            </summary>
        </member>
        <member name="M:Communication.Core.HslAsyncCoordinator.#ctor(System.Action)">
            <summary>
            实例化一个对象，需要传入隔离执行的方法
            </summary>
            <param name="operater">隔离执行的方法</param>
        </member>
        <member name="F:Communication.Core.HslAsyncCoordinator.OperaterStatus">
            <summary>
            操作状态，0是未操作，1是操作中
            </summary>
        </member>
        <member name="F:Communication.Core.HslAsyncCoordinator.Target">
            <summary>
            需要操作的次数
            </summary>
        </member>
        <member name="M:Communication.Core.HslAsyncCoordinator.StartOperaterInfomation">
            <summary>
            启动线程池执行隔离方法
            </summary>
        </member>
        <member name="T:Communication.Core.HslReadWriteLock">
            <summary>
            一个高性能的读写锁，支持写锁定，读灵活，读时写锁定，写时读锁定
            </summary>
        </member>
        <member name="M:Communication.Core.HslReadWriteLock.ToString">
            <summary>
            返回本对象的描述字符串
            </summary>
            <returns>对象的描述字符串</returns>
        </member>
        <member name="M:Communication.Core.HslReadWriteLock.#ctor">
            <summary>
            实例化一个读写锁的对象
            </summary>
        </member>
        <member name="M:Communication.Core.HslReadWriteLock.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:Communication.Core.HslReadWriteLock.Enter(System.Boolean)">
            <summary>
            根据读写情况请求锁
            </summary>
            <param name="exclusive">True为写请求，False为读请求</param>
        </member>
        <member name="M:Communication.Core.HslReadWriteLock.Leave">
            <summary>
            释放锁，将根据锁状态自动区分读写锁
            </summary>
        </member>
        <member name="T:Communication.Core.SimpleHybirdLock">
            <summary>
            一个简单的混合线程同步锁，采用了基元用户加基元内核同步构造实现
            </summary>
            <example>
            以下演示常用的锁的使用方式，还包含了如何优雅的处理异常锁
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\ThreadLock.cs" region="SimpleHybirdLockExample1" title="SimpleHybirdLock示例" />
            </example>
        </member>
        <member name="M:Communication.Core.SimpleHybirdLock.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="F:Communication.Core.SimpleHybirdLock.m_waiters">
            <summary>
            基元用户模式构造同步锁
            </summary>
        </member>
        <member name="F:Communication.Core.SimpleHybirdLock.m_waiterLock">
            <summary>
            基元内核模式构造同步锁
            </summary>
        </member>
        <member name="M:Communication.Core.SimpleHybirdLock.Enter">
            <summary>
            获取锁
            </summary>
        </member>
        <member name="M:Communication.Core.SimpleHybirdLock.Leave">
            <summary>
            离开锁
            </summary>
        </member>
        <member name="P:Communication.Core.SimpleHybirdLock.IsWaitting">
            <summary>
            获取当前锁是否在等待当中
            </summary>
        </member>
        <member name="T:Communication.Core.SoftMultiTask`1">
            <summary>
            一个用于多线程并发处理数据的模型类，适用于处理数据量非常庞大的情况
            </summary>
            <typeparam name="T">等待处理的数据类型</typeparam>
        </member>
        <member name="M:Communication.Core.SoftMultiTask`1.#ctor(`0[],System.Func{`0,System.Boolean},System.Int32)">
            <summary>
            实例化一个数据处理对象
            </summary>
            <param name="dataList">数据处理列表</param>
            <param name="operater">数据操作方法，应该是相对耗时的任务</param>
            <param name="threadCount">需要使用的线程数</param>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_opCount">
            <summary>
            操作总数，判定操作是否完成
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_opThreadCount">
            <summary>
            判断是否所有的线程是否处理完成
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_threadCount">
            <summary>
            准备启动的处理数据的线程数量
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_runStatus">
            <summary>
            指示多线程处理是否在运行中，防止冗余调用
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_dataList">
            <summary>
            列表数据
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_operater">
            <summary>
            需要操作的方法
            </summary>
        </member>
        <member name="T:Communication.Core.SoftMultiTask`1.MultiInfo">
            <summary>
            一个双参数委托
            </summary>
            <param name="item"></param>
            <param name="ex"></param>
        </member>
        <member name="T:Communication.Core.SoftMultiTask`1.MultiInfoTwo">
            <summary>
            用于报告进度的委托，当finish等于count时，任务完成
            </summary>
            <param name="finish">已完成操作数量</param>
            <param name="count">总数量</param>
            <param name="success">成功数量</param>
            <param name="failed">失败数量</param>
        </member>
        <member name="E:Communication.Core.SoftMultiTask`1.OnExceptionOccur">
            <summary>
            异常发生时事件
            </summary>
        </member>
        <member name="E:Communication.Core.SoftMultiTask`1.OnReportProgress">
            <summary>
            报告处理进度时发生
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_finishCount">
            <summary>
            已处理完成数量，无论是否异常
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_successCount">
            <summary>
            处理完成并实现操作数量
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_failedCount">
            <summary>
            处理过程中异常数量
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.HybirdLock">
            <summary>
            用于触发事件的混合线程锁
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_isRunningStop">
            <summary>
            指示处理状态是否为暂停状态
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_isQuit">
            <summary>
            指示系统是否需要强制退出
            </summary>
        </member>
        <member name="F:Communication.Core.SoftMultiTask`1.m_isQuitAfterException">
            <summary>
            在发生错误的时候是否强制退出后续的操作
            </summary>
        </member>
        <member name="M:Communication.Core.SoftMultiTask`1.StartOperater">
            <summary>
            启动多线程进行数据处理
            </summary>
        </member>
        <member name="M:Communication.Core.SoftMultiTask`1.StopOperater">
            <summary>
            暂停当前的操作
            </summary>
        </member>
        <member name="M:Communication.Core.SoftMultiTask`1.ResumeOperater">
            <summary>
            恢复暂停的操作
            </summary>
        </member>
        <member name="M:Communication.Core.SoftMultiTask`1.EndedOperater">
            <summary>
            直接手动强制结束操作
            </summary>
        </member>
        <member name="P:Communication.Core.SoftMultiTask`1.IsQuitAfterException">
            <summary>
            在发生错误的时候是否强制退出后续的操作
            </summary>
        </member>
        <member name="T:Communication.Core.ByteTransformBase">
            <summary>
            数据转换类的基础，提供了一些基础的方法实现.
            </summary>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.#ctor(Communication.Core.DataFormat)">
            <summary>
            使用指定的数据解析来实例化对象
            </summary>
            <param name="dataFormat">数据规则</param>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransBool(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取出bool结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <returns>bool对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransBool(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取出bool数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <param name="length">bool长度</param>
            <returns>bool数组</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取byte结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>byte对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取byte数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>byte数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取short结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>short对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取short数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>short数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransUInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ushort结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ushort对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransUInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ushort数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ushort数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取int结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>int对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取int数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>int数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransUInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取uint结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>uint对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransUInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取uint数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>uint数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取long结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>long对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取long数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>long数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransUInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ulong结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ulong对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransUInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ulong数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ulong数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransSingle(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取float结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>float对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransSingle(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取float数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>float数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransDouble(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取double结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>double对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取double数组结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>double数组对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            从缓存中提取string结果，使用指定的编码
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">byte数组长度</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Boolean)">
            <summary>
            bool变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Boolean[])">
            <summary>
            bool数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Byte)">
            <summary>
            byte变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Int16)">
            <summary>
            short变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Int16[])">
            <summary>
            short数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.UInt16)">
            <summary>
            ushort变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.UInt16[])">
            <summary>
            ushort数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Int32)">
            <summary>
            int变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Int32[])">
            <summary>
            int数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.UInt32)">
            <summary>
            uint变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.UInt32[])">
            <summary>
            uint数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Int64)">
            <summary>
            long变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Int64[])">
            <summary>
            long数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.UInt64)">
            <summary>
            ulong变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.UInt64[])">
            <summary>
            ulong数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Single)">
            <summary>
            float变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Single[])">
            <summary>
            float数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Double)">
            <summary>
            double变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.Double[])">
            <summary>
            double数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.TransByte(System.String,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.ByteTransDataFormat4(System.Byte[],System.Int32)">
            <summary>
            反转多字节的数据信息
            </summary>
            <param name="value">数据字节</param>
            <param name="index">起始索引，默认值为0</param>
            <returns>实际字节信息</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformBase.ByteTransDataFormat8(System.Byte[],System.Int32)">
            <summary>
            反转多字节的数据信息
            </summary>
            <param name="value">数据字节</param>
            <param name="index">起始索引，默认值为0</param>
            <returns>实际字节信息</returns>
        </member>
        <member name="P:Communication.Core.ByteTransformBase.DataFormat">
            <summary>
            获取或设置数据解析的格式，默认DCBA，也即是无修改，可选ABCD,BADC，CDAB，DCBA格式，对于Modbus协议来说，默认ABCD
            </summary>
        </member>
        <member name="T:Communication.Core.ByteTransformHelper">
            <summary>
            所有数据转换类的静态辅助方法
            Static helper method for all data conversion classes
            </summary>
        </member>
        <member name="M:Communication.Core.ByteTransformHelper.GetResultFromBytes``1(Communication.OperateResult{System.Byte[]},System.Func{System.Byte[],``0})">
            <summary>
            结果转换操作的基础方法，需要支持类型，及转换的委托
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <param name="result">源</param>
            <param name="translator">实际转换的委托</param>
            <returns>转换结果</returns>
        </member>
        <member name="M:Communication.Core.ByteTransformHelper.GetResultFromArray``1(Communication.OperateResult{``0[]})">
            <summary>
            结果转换操作的基础方法，需要支持类型，及转换的委托
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <param name="result">源结果</param>
            <returns>转换结果</returns>
        </member>
        <member name="T:Communication.Core.DataFormat">
            <summary>
            应用于多字节数据的解析或是生成格式
            </summary>
        </member>
        <member name="F:Communication.Core.DataFormat.ABCD">
            <summary>
            按照顺序排序
            </summary>
        </member>
        <member name="F:Communication.Core.DataFormat.BADC">
            <summary>
            按照单字反转
            </summary>
        </member>
        <member name="F:Communication.Core.DataFormat.CDAB">
            <summary>
            按照双字反转
            </summary>
        </member>
        <member name="F:Communication.Core.DataFormat.DCBA">
            <summary>
            按照倒序排序
            </summary>
        </member>
        <member name="T:Communication.Core.IByteTransform">
            <summary>
            支持转换器的基础接口
            </summary>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransBool(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取出bool结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <returns>bool对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransBool(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取出bool数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <param name="length">bool长度</param>
            <returns>bool数组</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取byte结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>byte对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取byte数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取short结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>short对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取short数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>short数组对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ushort结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ushort对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ushort数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ushort数组对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取int结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>int对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取int数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>int数组对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取uint结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>uint对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取uint数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>uint数组对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取long结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>long对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取long数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>long数组对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ulong结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ulong对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ulong数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ulong数组对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取float结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>float对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取float数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取double结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>double对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取double数组结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            从缓存中提取string结果，使用指定的编码
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">byte数组长度</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Boolean)">
            <summary>
            bool变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Boolean[])">
            <summary>
            bool数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Byte)">
            <summary>
            byte变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Int16)">
            <summary>
            short变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Int16[])">
            <summary>
            short数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.UInt16)">
            <summary>
            ushort变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.UInt16[])">
            <summary>
            ushort数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Int32)">
            <summary>
            int变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Int32[])">
            <summary>
            int数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.UInt32)">
            <summary>
            uint变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.UInt32[])">
            <summary>
            uint数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Int64)">
            <summary>
            long变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Int64[])">
            <summary>
            long数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.UInt64)">
            <summary>
            ulong变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.UInt64[])">
            <summary>
            ulong数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Single)">
            <summary>
            float变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Single[])">
            <summary>
            float数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Double)">
            <summary>
            double变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.Double[])">
            <summary>
            double数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.IByteTransform.TransByte(System.String,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="P:Communication.Core.IByteTransform.DataFormat">
            <summary>
            获取或设置数据解析的格式，默认ABCD，可选BADC，CDAB，DCBA格式
            </summary>
        </member>
        <member name="T:Communication.Core.RegularByteTransform">
            <summary>
            常规的字节转换类
            </summary>
        </member>
        <member name="M:Communication.Core.RegularByteTransform.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Core.RegularByteTransform.#ctor(Communication.Core.DataFormat)">
            <summary>
            使用指定的解析规则来初始化对象
            </summary>
            <param name="dataFormat">解析规则</param>
        </member>
        <member name="T:Communication.Core.ReverseBytesTransform">
            <summary>
            字节倒序的转换类
            </summary>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.#ctor(Communication.Core.DataFormat)">
            <summary>
            使用指定的数据解析来实例化对象
            </summary>
            <param name="dataFormat">数据规则</param>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取short结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>short对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransUInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ushort结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ushort对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取int结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>int对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransUInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取uint结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>uint对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取long结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>long对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransUInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ulong结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ulong对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransSingle(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取float结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>float对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransDouble(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取double结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>double对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.Int16[])">
            <summary>
            short数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.UInt16[])">
            <summary>
            ushort数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.Int32[])">
            <summary>
            int数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.UInt32[])">
            <summary>
            uint数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.Int64[])">
            <summary>
            long数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.UInt64[])">
            <summary>
            ulong数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.Single[])">
            <summary>
            float数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseBytesTransform.TransByte(System.Double[])">
            <summary>
            double数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="T:Communication.Core.ReverseWordTransform">
            <summary>
            按照字节错位的数据转换类
            </summary>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.#ctor(Communication.Core.DataFormat)">
            <summary>
            使用指定的数据解析来实例化对象
            </summary>
            <param name="dataFormat">数据规则</param>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.ReverseBytesByWord(System.Byte[],System.Int32,System.Int32)">
            <summary>
            按照字节错位的方法
            </summary>
            <param name="buffer">实际的字节数据</param>
            <param name="index">起始字节位置</param>
            <param name="length">数据长度</param>
            <returns>处理过的数据信息</returns>
        </member>
        <member name="P:Communication.Core.ReverseWordTransform.IsStringReverse">
            <summary>
            字符串数据是否按照字来反转
            </summary>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.TransInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取short结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>short对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.TransUInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ushort结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ushort对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            从缓存中提取string结果，使用指定的编码
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">byte数组长度</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.TransByte(System.Int16[])">
            <summary>
            short数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.TransByte(System.UInt16[])">
            <summary>
            ushort数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Core.ReverseWordTransform.TransByte(System.String,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="T:Communication.Core.HslPieItem">
            <summary>
            饼图的基本元素
            </summary>
        </member>
        <member name="M:Communication.Core.HslPieItem.#ctor">
            <summary>
            实例化一个饼图基本元素的对象
            </summary>
        </member>
        <member name="P:Communication.Core.HslPieItem.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:Communication.Core.HslPieItem.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="P:Communication.Core.HslPieItem.Back">
            <summary>
            背景颜色
            </summary>
        </member>
        <member name="T:Communication.NetHandle">
            <summary>
            用于网络传递的信息头，使用上等同于int
            </summary>
            <remarks>
            通常用于<see cref="T:Communication.Enthernet.NetComplexServer"/>和<see cref="T:Communication.Enthernet.NetComplexClient"/>之间的通信，以及<see cref="T:Communication.Enthernet.NetSimplifyServer"/>和<see cref="T:Communication.Enthernet.NetSimplifyClient"/>通讯
            </remarks>
            <example>
            使用上等同于int，只是本结构体允许将4字节的int拆分成3部分单独访问
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetHandle.cs" region="NetHandleExample" title="NetHandle示例" />
            </example>
        </member>
        <member name="M:Communication.NetHandle.op_Implicit(System.Int32)~Communication.NetHandle">
            <summary>
            赋值操作，可以直接赋值int数据
            </summary>
            <param name="value">int数值</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:Communication.NetHandle.op_Implicit(Communication.NetHandle)~System.Int32">
            <summary>
            也可以赋值给int数据
            </summary>
            <param name="netHandle">netHandle对象</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:Communication.NetHandle.op_Equality(Communication.NetHandle,Communication.NetHandle)">
            <summary>
            判断是否相等
            </summary>
            <param name="netHandle1">第一个数</param>
            <param name="netHandle2">第二个数</param>
            <returns>等于返回<c>True</c>，否则<c>False</c></returns>
        </member>
        <member name="M:Communication.NetHandle.op_Inequality(Communication.NetHandle,Communication.NetHandle)">
            <summary>
            判断是否不相等
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>等于返回<c>False</c>，否则<c>True</c></returns>
        </member>
        <member name="M:Communication.NetHandle.op_Addition(Communication.NetHandle,Communication.NetHandle)">
            <summary>
            两个数值相加
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>返回两个指令的和</returns>
        </member>
        <member name="M:Communication.NetHandle.op_Subtraction(Communication.NetHandle,Communication.NetHandle)">
            <summary>
            两个数值相减
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>返回两个指令的差</returns>
        </member>
        <member name="M:Communication.NetHandle.op_LessThan(Communication.NetHandle,Communication.NetHandle)">
            <summary>
            判断是否小于另一个数值
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>小于则返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:Communication.NetHandle.op_GreaterThan(Communication.NetHandle,Communication.NetHandle)">
            <summary>
            判断是否大于另一个数值
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>大于则返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:Communication.NetHandle.#ctor(System.Int32)">
            <summary>
            初始化一个暗号对象
            </summary>
            <param name="value">使用一个默认的数值进行初始化</param>
        </member>
        <member name="M:Communication.NetHandle.#ctor(System.Byte,System.Byte,System.UInt16)">
            <summary>
            根据三个值来初始化暗号对象
            </summary>
            <param name="major">主暗号</param>
            <param name="minor">次暗号</param>
            <param name="identifier">暗号编号</param>
        </member>
        <member name="F:Communication.NetHandle.m_CodeValue">
            <summary>
            完整的暗号值
            </summary>
        </member>
        <member name="F:Communication.NetHandle.m_CodeMajor">
            <summary>
            主暗号分类0-255
            </summary>
        </member>
        <member name="F:Communication.NetHandle.m_CodeMinor">
            <summary>
            次要的暗号分类0-255
            </summary>
        </member>
        <member name="F:Communication.NetHandle.m_CodeIdentifier">
            <summary>
            暗号的编号分类0-65535
            </summary>
        </member>
        <member name="P:Communication.NetHandle.CodeValue">
            <summary>
            完整的暗号值
            </summary>
        </member>
        <member name="P:Communication.NetHandle.CodeMajor">
            <summary>
            主暗号分类0-255
            </summary>
        </member>
        <member name="P:Communication.NetHandle.CodeMinor">
            <summary>
            次要的暗号分类0-255
            </summary>
        </member>
        <member name="P:Communication.NetHandle.CodeIdentifier">
            <summary>
            暗号的编号分类0-65535
            </summary>
        </member>
        <member name="M:Communication.NetHandle.ToString">
            <summary>
            获取完整的暗号数据
            </summary>
            <returns>返回暗号的字符串表示形式</returns>
        </member>
        <member name="M:Communication.NetHandle.Equals(System.Object)">
            <summary>
            判断两个实例是否相同
            </summary>
            <param name="obj">对比的对象</param>
            <returns>相同返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:Communication.NetHandle.GetHashCode">
            <summary>
            获取哈希值
            </summary>
            <returns>返回当前对象的哈希值</returns>
        </member>
        <member name="T:Communication.HslProtocol">
            <summary>
            用于本程序集访问通信的暗号说明
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.HeadByteLength">
            <summary>
            规定所有的网络传输指令头都为32字节
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolBufferSize">
            <summary>
            所有网络通信中的缓冲池数据信息
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolCheckSecends">
            <summary>
            用于心跳程序的暗号信息
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolClientQuit">
            <summary>
            客户端退出消息
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolClientRefuseLogin">
            <summary>
            因为客户端达到上限而拒绝登录
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolClientAllowLogin">
            <summary>
            允许客户端登录到服务器
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolUserString">
            <summary>
            说明发送的只是文本信息
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolUserBytes">
            <summary>
            发送的数据就是普通的字节数组
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolUserBitmap">
            <summary>
            发送的数据就是普通的图片数据
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolUserException">
            <summary>
            发送的数据是一条异常的数据，字符串为异常消息
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileDownload">
            <summary>
            请求文件下载的暗号
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileUpload">
            <summary>
            请求文件上传的暗号
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileDelete">
            <summary>
            请求删除文件的暗号
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileCheckRight">
            <summary>
            文件校验成功
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileCheckError">
            <summary>
            文件校验失败
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileSaveError">
            <summary>
            文件保存失败
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileDirectoryFiles">
            <summary>
            请求文件列表的暗号
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolFileDirectories">
            <summary>
            请求子文件的列表暗号
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolProgressReport">
            <summary>
            进度返回暗号
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolNoZipped">
            <summary>
            不压缩数据字节
            </summary>
        </member>
        <member name="F:Communication.HslProtocol.ProtocolZipped">
            <summary>
            压缩数据字节
            </summary>
        </member>
        <member name="M:Communication.HslProtocol.CommandBytes(System.Int32,System.Int32,System.Guid,System.Byte[])">
            <summary>
            生成终极传送指令的方法，所有的数据均通过该方法出来
            </summary>
            <param name="command">命令头</param>
            <param name="customer">自用自定义</param>
            <param name="token">令牌</param>
            <param name="data">字节数据</param>
            <returns>包装后的数据信息</returns>
        </member>
        <member name="M:Communication.HslProtocol.CommandAnalysis(System.Byte[],System.Byte[])">
            <summary>
            解析接收到数据，先解压缩后进行解密
            </summary>
            <param name="head">指令头</param>
            <param name="content">指令的内容</param>
            <return>真实的数据内容</return>
        </member>
        <member name="M:Communication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.Byte[])">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字节信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:Communication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.String)">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字符串数据信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:Communication.HslSecurity.ByteEncrypt(System.Byte[])">
            <summary>
            加密方法，只对当前的程序集开放
            </summary>
            <param name="enBytes">等待加密的数据</param>
            <returns>加密后的字节数据</returns>
        </member>
        <member name="M:Communication.HslSecurity.ByteDecrypt(System.Byte[])">
            <summary>
            解密方法，只对当前的程序集开放
            </summary>
            <param name="deBytes">等待解密的数据</param>
            <returns>解密后的字节数据</returns>
        </member>
        <member name="T:Communication.HslTimeOut">
            <summary>
            超时操作的类 [a class use to indicate the time-out of the connection]
            </summary>
        </member>
        <member name="M:Communication.HslTimeOut.#ctor">
            <summary>
            实例化对象
            </summary>
        </member>
        <member name="P:Communication.HslTimeOut.StartTime">
            <summary>
            操作的开始时间
            </summary>
        </member>
        <member name="P:Communication.HslTimeOut.IsSuccessful">
            <summary>
            操作是否成功
            </summary>
        </member>
        <member name="P:Communication.HslTimeOut.DelayTime">
            <summary>
            延时的时间，单位毫秒
            </summary>
        </member>
        <member name="P:Communication.HslTimeOut.WorkSocket">
            <summary>
            连接超时用的Socket
            </summary>
        </member>
        <member name="P:Communication.HslTimeOut.Operator">
            <summary>
            用于超时执行的方法
            </summary>
        </member>
        <member name="P:Communication.HslTimeOut.HybirdLock">
            <summary>
            当前对象判断的同步锁
            </summary>
        </member>
        <member name="T:Communication.IDataTransfer">
            <summary>
            用于PLC通讯及ModBus自定义数据类型的读写操作
            </summary>
            <remarks>
            主要应用于设备实现设备类的自定义的数据类型读写，以此达到简化代码的操作，但是有一个前提，该数据处于连续的数据区块
            </remarks>
            <example>
            此处举例读取三菱的自定义的数据，先实现接口，然后再读写操作
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="P:Communication.IDataTransfer.ReadCount">
            <summary>
            读取的数据长度，对于西门子，等同于字节数，对于三菱和Modbus为字节数的一半
            </summary>
        </member>
        <member name="M:Communication.IDataTransfer.ParseSource(System.Byte[])">
            <summary>
            从字节数组进行解析实际的对象
            </summary>
            <param name="Content">从远程读取的数据源</param>
        </member>
        <member name="M:Communication.IDataTransfer.ToSource">
            <summary>
            将对象生成字符源，写入PLC中
            </summary>
            <returns>准备写入到远程的数据</returns>
        </member>
        <member name="T:Communication.OperateResult">
            <summary>
            操作结果的类，只带有成功标志和错误信息 -> The class that operates the result, with only success flags and error messages
            </summary>
            <remarks>
            当 <see cref="P:Communication.OperateResult.IsSuccess"/> 为 True 时，忽略 <see cref="P:Communication.OperateResult.Message"/> 及 <see cref="P:Communication.OperateResult.ErrorCode"/> 的值
            </remarks>
        </member>
        <member name="M:Communication.OperateResult.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult.IsSuccess">
            <summary>
            指示本次访问是否成功
            </summary>
        </member>
        <member name="P:Communication.OperateResult.Message">
            <summary>
            具体的错误描述
            </summary>
        </member>
        <member name="P:Communication.OperateResult.ErrorCode">
            <summary>
            具体的错误代码
            </summary>
        </member>
        <member name="M:Communication.OperateResult.ToMessageShowString">
            <summary>
            获取错误代号及文本描述
            </summary>
            <returns>包含错误码及错误消息</returns>
        </member>
        <member name="M:Communication.OperateResult.CopyErrorFromOther``1(``0)">
            <summary>
            从另一个结果类中拷贝错误信息
            </summary>
            <typeparam name="TResult">支持结果类及派生类</typeparam>
            <param name="result">结果类及派生类的对象</param>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``1(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T">目标数据类型</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``2(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``3(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``4(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``5(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``6(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``7(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``8(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``9(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <typeparam name="T9">目标数据类型九</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateFailedResult``10(Communication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <typeparam name="T9">目标数据类型九</typeparam>
            <typeparam name="T10">目标数据类型十</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult">
            <summary>
            创建并返回一个成功的结果对象
            </summary>
            <returns>成功的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``1(``0)">
            <summary>
            创建并返回一个成功的结果对象，并带有一个参数对象
            </summary>
            <typeparam name="T">参数类型</typeparam>
            <param name="value">类型的值对象</param>
            <returns>成功的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``2(``0,``1)">
            <summary>
            创建并返回一个成功的结果对象，并带有两个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``3(``0,``1,``2)">
            <summary>
            创建并返回一个成功的结果对象，并带有三个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``4(``0,``1,``2,``3)">
            <summary>
            创建并返回一个成功的结果对象，并带有四个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``5(``0,``1,``2,``3,``4)">
            <summary>
            创建并返回一个成功的结果对象，并带有五个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            创建并返回一个成功的结果对象，并带有六个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            创建并返回一个成功的结果对象，并带有七个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            创建并返回一个成功的结果对象，并带有八个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``9(``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            创建并返回一个成功的结果对象，并带有九个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <typeparam name="T9">第九个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <param name="value9">类型九对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:Communication.OperateResult.CreateSuccessResult``10(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            创建并返回一个成功的结果对象，并带有十个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <typeparam name="T9">第九个参数类型</typeparam>
            <typeparam name="T10">第十个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <param name="value9">类型九对象</param>
            <param name="value10">类型十对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="T:Communication.OperateResult`1">
            <summary>
            操作结果的泛型类，允许带一个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`1.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`1.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`1.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`1.Content">
            <summary>
            用户自定义的泛型数据
            </summary>
        </member>
        <member name="T:Communication.OperateResult`2">
            <summary>
            操作结果的泛型类，允许带两个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`2.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`2.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`2.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`2.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`2.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="T:Communication.OperateResult`3">
            <summary>
            操作结果的泛型类，允许带三个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`3.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`3.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`3.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`3.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`3.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`3.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="T:Communication.OperateResult`4">
            <summary>
            操作结果的泛型类，允许带四个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`4.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`4.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`4.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`4.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`4.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`4.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:Communication.OperateResult`4.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="T:Communication.OperateResult`5">
            <summary>
            操作结果的泛型类，允许带五个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`5.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`5.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`5.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`5.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`5.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`5.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:Communication.OperateResult`5.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:Communication.OperateResult`5.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="T:Communication.OperateResult`6">
            <summary>
            操作结果的泛型类，允许带六个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`6.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`6.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`6.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`6.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`6.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`6.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:Communication.OperateResult`6.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:Communication.OperateResult`6.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:Communication.OperateResult`6.Content6">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="T:Communication.OperateResult`7">
            <summary>
            操作结果的泛型类，允许带七个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`7.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`7.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`7.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`7.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`7.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`7.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:Communication.OperateResult`7.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:Communication.OperateResult`7.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:Communication.OperateResult`7.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:Communication.OperateResult`7.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="T:Communication.OperateResult`8">
            <summary>
            操作结果的泛型类，允许带八个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`8.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`8.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`8.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`8.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`8.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`8.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:Communication.OperateResult`8.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:Communication.OperateResult`8.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:Communication.OperateResult`8.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:Communication.OperateResult`8.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:Communication.OperateResult`8.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="T:Communication.OperateResult`9">
            <summary>
            操作结果的泛型类，允许带九个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
            <typeparam name="T9">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`9.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`9.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`9.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`9.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="P:Communication.OperateResult`9.Content9">
            <summary>
            用户自定义的泛型数据9
            </summary>
        </member>
        <member name="T:Communication.OperateResult`10">
            <summary>
            操作结果的泛型类，允许带十个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
            <typeparam name="T9">泛型类</typeparam>
            <typeparam name="T10">泛型类</typeparam>
        </member>
        <member name="M:Communication.OperateResult`10.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:Communication.OperateResult`10.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:Communication.OperateResult`10.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:Communication.OperateResult`10.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content9">
            <summary>
            用户自定义的泛型数据9
            </summary>
        </member>
        <member name="P:Communication.OperateResult`10.Content10">
            <summary>
            用户自定义的泛型数据10
            </summary>
        </member>
        <member name="T:Communication.Enthernet.NetComplexClient">
            <summary>
            一个基于异步高性能的客户端网络类，支持主动接收服务器的消息
            </summary>
            <remarks>
            
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\CommunicationDemo\FormComplexNet.cs" region="NetComplexClient" title="NetComplexClient示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexClient.IsClientStart">
            <summary>
            客户端系统是否启动
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexClient.ConnectFailedCount">
            <summary>
            重连接失败的次数
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexClient.ClientAlias">
            <summary>
            客户端登录的标识名称，可以为ID号，也可以为登录名
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexClient.EndPointServer">
            <summary>
            远程服务器的IP地址和端口
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexClient.ServerTime">
            <summary>
            服务器的时间，自动实现和服务器同步
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexClient.DelayTime">
            <summary>
            系统与服务器的延时时间，单位毫秒
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexClient.LoginSuccess">
            <summary>
            客户端启动成功的事件，重连成功也将触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexClient.LoginFailed">
            <summary>
            连接失败时触发的事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexClient.MessageAlerts">
            <summary>
            服务器的异常，启动，等等一般消息产生的时候，出发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexClient.BeforReConnected">
            <summary>
            在客户端断开后并在重连服务器之前触发，用于清理系统资源
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexClient.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexClient.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.ClientClose">
            <summary>
            关闭该客户端引擎
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.ClientStart">
            <summary>
            启动客户端引擎，连接服务器系统
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.AwaitToConnect">
            <summary>
            连接服务器之前的消息提示，如果是重连的话，就提示10秒等待信息
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.SocketReceiveException(Communication.Core.Net.AppSession,System.Exception)">
            <summary>
            通信出错后的处理
            </summary>
            <param name="receive">接收的会话</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.Send(Communication.NetHandle,System.String)">
            <summary>
            服务器端用于数据发送文本的方法
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">发送的文本</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.Send(Communication.NetHandle,System.Byte[])">
            <summary>
            服务器端用于发送字节的方法
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="bytes">实际发送的数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.DataProcessingCenter(Communication.Core.Net.AppSession,System.Int32,System.Int32,System.Byte[])">
            <summary>
            客户端的数据处理中心
            </summary>
            <param name="session">会话</param>
            <param name="protocol">消息暗号</param>
            <param name="customer">用户消息</param>
            <param name="content">数据内容</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.ThreadHeartCheck">
            <summary>
            心跳线程的方法
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexClient.ToString">
            <summary>
            返回对象的字符串表示形式
            </summary>
            <returns></returns>
        </member>
        <member name="T:Communication.Enthernet.NetComplexServer">
             <summary>
             高性能的异步网络服务器类，适合搭建局域网聊天程序，消息推送程序
             </summary>
             <remarks>
            
             </remarks>
             <example>
             此处贴上了Demo项目的服务器配置的示例代码
             <code lang="cs" source="TestProject\ComplexNetServer\FormServer.cs" region="NetComplexServer" title="NetComplexServer示例" />
             </example>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.#ctor">
            <summary>
            实例化一个网络服务器类对象
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexServer.ConnectMax">
            <summary>
            所支持的同时在线客户端的最大数量，商用限制1000个，最小10个
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexServer.IsSaveLogClientLineChange">
            <summary>
            获取或设置服务器是否记录客户端上下线信息
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetComplexServer.ClientCount">
            <summary>
            所有在线客户端的数量
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.StartInitialization">
            <summary>
            初始化操作
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.CloseAction">
            <summary>
            关闭网络时的操作
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.SocketReceiveException(Communication.Core.Net.AppSession,System.Exception)">
            <summary>
            异常下线
            </summary>
            <param name="session">会话信息</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.AppSessionRemoteClose(Communication.Core.Net.AppSession)">
            <summary>
            正常下线
            </summary>
            <param name="session">会话信息</param>
        </member>
        <member name="E:Communication.Enthernet.NetComplexServer.AllClientsStatusChange">
            <summary>
            客户端的上下限状态变更时触发，仅作为在线客户端识别
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexServer.ClientOnline">
            <summary>
            当客户端上线的时候，触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexServer.ClientOffline">
            <summary>
            当客户端下线的时候，触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexServer.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetComplexServer.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.ThreadPoolLogin(System.Object)">
            <summary>
            登录后的处理方法
            </summary>
            <param name="obj">异步的接收socket对象</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.Send(Communication.Core.Net.AppSession,Communication.NetHandle,System.String)">
            <summary>
            服务器端用于数据发送文本的方法
            </summary>
            <param name="session">数据发送对象</param>
            <param name="customer">用户自定义的数据对象，如不需要，赋值为0</param>
            <param name="str">发送的文本</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.Send(Communication.Core.Net.AppSession,Communication.NetHandle,System.Byte[])">
            <summary>
            服务器端用于发送字节的方法
            </summary>
            <param name="session">数据发送对象</param>
            <param name="customer">用户自定义的数据对象，如不需要，赋值为0</param>
            <param name="bytes">实际发送的数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.SendAllClients(Communication.NetHandle,System.String)">
            <summary>
            服务端用于发送所有数据到所有的客户端
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">需要传送的实际的数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.SendAllClients(Communication.NetHandle,System.Byte[])">
            <summary>
            服务端用于发送所有数据到所有的客户端
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="data">需要群发客户端的字节数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.SendClientByAlias(System.String,Communication.NetHandle,System.String)">
            <summary>
            根据客户端设置的别名进行发送消息
            </summary>
            <param name="Alias">客户端上线的别名</param>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">需要传送的实际的数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.SendClientByAlias(System.String,Communication.NetHandle,System.Byte[])">
            <summary>
            根据客户端设置的别名进行发送消息
            </summary>
            <param name="Alias">客户端上线的别名</param>
            <param name="customer">用户自定义的命令头</param>
            <param name="data">需要传送的实际的数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.DataProcessingCenter(Communication.Core.Net.AppSession,System.Int32,System.Int32,System.Byte[])">
            <summary>
            数据处理中心
            </summary>
            <param name="session">会话对象</param>
            <param name="protocol">消息的代码</param>
            <param name="customer">用户消息</param>
            <param name="content">数据内容</param>
        </member>
        <member name="M:Communication.Enthernet.NetComplexServer.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Enthernet.DeviceNet">
            <summary>
            通用设备的基础网络信息
            </summary>
        </member>
        <member name="M:Communication.Enthernet.DeviceNet.#ctor">
            <summary>
            实例化一个通用的设备类
            </summary>
        </member>
        <member name="E:Communication.Enthernet.DeviceNet.ClientOnline">
            <summary>
            当客户端上线的时候，触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.DeviceNet.ClientOffline">
            <summary>
            当客户端下线的时候，触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.DeviceNet.AcceptString">
            <summary>
            按照ASCII文本的方式进行触发接收的数据
            </summary>
        </member>
        <member name="E:Communication.Enthernet.DeviceNet.AcceptBytes">
            <summary>
            按照字节的方式进行触发接收的数据
            </summary>
        </member>
        <member name="M:Communication.Enthernet.DeviceNet.ThreadPoolLogin(System.Object)">
            <summary>
            登录后的处理方法
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:Communication.Enthernet.DeviceState">
            <summary>
            通用设备的基础状态
            </summary>
        </member>
        <member name="P:Communication.Enthernet.DeviceState.DeviceEndPoint">
            <summary>
            设备的连接地址
            </summary>
        </member>
        <member name="P:Communication.Enthernet.DeviceState.ConnectTime">
            <summary>
            设备的连接时间
            </summary>
        </member>
        <member name="P:Communication.Enthernet.DeviceState.WorkSocket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:Communication.Enthernet.DeviceState.ReceiveTime">
            <summary>
            上次接收到信息的时间
            </summary>
        </member>
        <member name="P:Communication.Enthernet.DeviceState.IpAddress">
            <summary>
            设备的ip地址
            </summary>
        </member>
        <member name="F:Communication.Enthernet.DeviceState.Buffer">
            <summary>
            缓冲内存块
            </summary>
        </member>
        <member name="T:Communication.Enthernet.AdvancedFileServer">
            <summary>
            文件管理类服务器，负责服务器所有分类文件的管理，特点是不支持文件附加数据，但是支持直接访问文件名
            </summary>
            <remarks>
            本文件的服务器不支持存储文件携带的额外信息，是直接将文件存放在服务器指定目录下的，文件名不更改，特点是服务器查看方便。
            </remarks>
            <example>
            以下的示例来自Demo项目，创建了一个简单的服务器对象。
            <code lang="cs" source="TestProject\FileNetServer\FormFileServer.cs" region="Advanced Server" title="AdvancedFileServer示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.AdvancedFileServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:Communication.Enthernet.AdvancedFileServer.ThreadPoolLogin(System.Object)">
            <summary>
            处理数据
            </summary>
            <param name="obj">异步的socket对象</param>
        </member>
        <member name="M:Communication.Enthernet.AdvancedFileServer.StartInitialization">
            <summary>
            初始化数据
            </summary>
        </member>
        <member name="M:Communication.Enthernet.AdvancedFileServer.CheckFolderAndCreate">
            <summary>
            检查文件夹
            </summary>
        </member>
        <member name="M:Communication.Enthernet.AdvancedFileServer.ReceiveFileFromSocketAndMoveFile(System.Net.Sockets.Socket,System.String,System.String,System.String@,System.Int64@,System.String@,System.String@)">
            <summary>
            从网络套接字接收文件并移动到目标的文件夹中，如果结果异常，则结束通讯
            </summary>
            <param name="socket"></param>
            <param name="savename"></param>
            <param name="fileNameNew"></param>
            <param name="filename"></param>
            <param name="size"></param>
            <param name="filetag"></param>
            <param name="fileupload"></param>
            <returns></returns>
        </member>
        <member name="P:Communication.Enthernet.AdvancedFileServer.FilesDirectoryPathTemp">
            <summary>
            用于接收上传文件时的临时文件夹，临时文件使用结束后会被删除
            </summary>
        </member>
        <member name="M:Communication.Enthernet.AdvancedFileServer.ToString">
            <summary>
            获取本对象的字符串标识形式
            </summary>
            <returns>字符串对象</returns>
        </member>
        <member name="T:Communication.Enthernet.FileBaseInfo">
            <summary>
            文件的基础信息
            </summary>
        </member>
        <member name="P:Communication.Enthernet.FileBaseInfo.Name">
            <summary>
            文件名称
            </summary>
        </member>
        <member name="P:Communication.Enthernet.FileBaseInfo.Size">
            <summary>
            文件大小
            </summary>
        </member>
        <member name="P:Communication.Enthernet.FileBaseInfo.Tag">
            <summary>
            文件的标识，注释
            </summary>
        </member>
        <member name="P:Communication.Enthernet.FileBaseInfo.Upload">
            <summary>
            文件上传人的名称
            </summary>
        </member>
        <member name="T:Communication.Enthernet.FileClientBase">
            <summary>
            文件传输客户端基类，提供上传，下载，删除的基础服务
            </summary>
        </member>
        <member name="P:Communication.Enthernet.FileClientBase.ServerIpEndPoint">
            <summary>
            服务器端的文件管理引擎终结点
            </summary>
        </member>
        <member name="P:Communication.Enthernet.FileClientBase.ConnectTimeOut">
            <summary>
            获取或设置连接的超时时间，默认10秒
            </summary>
        </member>
        <member name="M:Communication.Enthernet.FileClientBase.SendFactoryGroupId(System.Net.Sockets.Socket,System.String,System.String,System.String)">
            <summary>
            发送三个文件分类到服务器端
            </summary>
            <param name="socket">套接字对象</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.FileClientBase.DeleteFileBase(System.String,System.String,System.String,System.String)">
            <summary>
            删除服务器上的文件
            </summary>
            <param name="fileName">文件的名称</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.FileClientBase.DownloadFileBase(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.Object)">
            <summary>
            基础下载信息
            </summary>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <param name="fileName">服务器的文件名称</param>
            <param name="processReport">下载的进度报告</param>
            <param name="source">数据源信息，决定最终存储到哪里去</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.FileClientBase.UploadFileBase(System.Object,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传文件给服务器
            </summary>
            <param name="source">数据源，可以是文件名，也可以是数据流</param>
            <param name="serverName">在服务器保存的文件名，不包含驱动器路径</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <param name="fileTag">文件的描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">汇报进度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.FileClientBase.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Enthernet.FileMarkId">
            <summary>
            文件标记对象类
            </summary>
        </member>
        <member name="M:Communication.Enthernet.FileMarkId.#ctor(Communication.LogNet.ILogNet,System.String)">
            <summary>
            实例化一个文件标记对象
            </summary>
            <param name="logNet">日志对象</param>
            <param name="fileName">完整的文件名称</param>
        </member>
        <member name="M:Communication.Enthernet.FileMarkId.AddOperation(System.Action)">
            <summary>
            新增一个文件的操作，仅仅是删除文件
            </summary>
            <param name="action">对当前文件的操作内容</param>
        </member>
        <member name="M:Communication.Enthernet.FileMarkId.CanClear">
            <summary>
            指示该对象是否能被清除
            </summary>
            <returns>是否能够删除</returns>
        </member>
        <member name="M:Communication.Enthernet.FileMarkId.EnterReadOperator">
            <summary>
            进入文件的读取状态
            </summary>
        </member>
        <member name="M:Communication.Enthernet.FileMarkId.LeaveReadOperator">
            <summary>
            离开本次的文件读取状态
            </summary>
        </member>
        <member name="T:Communication.Enthernet.GroupFileContainer">
            <summary>
            文件集容器，绑定一个文件夹的文件信息组
            </summary>
        </member>
        <member name="M:Communication.Enthernet.GroupFileContainer.#ctor(Communication.LogNet.ILogNet,System.String)">
            <summary>
            实例化一个新的数据管理容器
            </summary>
            <param name="logNet">日志记录对象，可以为空</param>
            <param name="path">文件的路径</param>
        </member>
        <member name="P:Communication.Enthernet.GroupFileContainer.JsonArrayContent">
            <summary>
            包含所有文件列表信息的json文本缓存
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileContainer.FileCount">
            <summary>
            获取文件的数量
            </summary>
        </member>
        <member name="E:Communication.Enthernet.GroupFileContainer.FileCountChanged">
            <summary>
            当文件数量发生变化的时候触发的事件
            </summary>
        </member>
        <member name="M:Communication.Enthernet.GroupFileContainer.GetCurrentFileMappingName(System.String)">
            <summary>
            下载文件时调用
            </summary>
            <param name="fileName">文件的实际名称</param>
            <returns>文件名映射过去的实际的文件名字</returns>
        </member>
        <member name="M:Communication.Enthernet.GroupFileContainer.UpdateFileMappingName(System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            上传文件时掉用
            </summary>
            <param name="fileName">文件名，带后缀，不带任何的路径</param>
            <param name="fileSize">文件的大小</param>
            <param name="mappingName">文件映射名称</param>
            <param name="owner">文件的拥有者</param>
            <param name="description">文件的额外描述</param>
            <returns>映射的文件名称</returns>
        </member>
        <member name="M:Communication.Enthernet.GroupFileContainer.DeleteFile(System.String)">
            <summary>
            删除一个文件信息
            </summary>
            <param name="fileName">实际的文件名称</param>
            <returns>映射之后的文件名</returns>
        </member>
        <member name="M:Communication.Enthernet.GroupFileContainer.CacheJsonArrayContent">
            <summary>
            缓存JSON文本的方法，该机制使用乐观并发模型完成
            </summary>
        </member>
        <member name="M:Communication.Enthernet.GroupFileContainer.GroupFileContainerLoadByPath(System.String)">
            <summary>
            从目录进行加载数据，必须实例化的时候加载，加载失败会导致系统异常，旧的文件丢失
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:Communication.Enthernet.GroupFileItem">
            <summary>
            单个文件的存储
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileItem.FileName">
            <summary>
            文件的名称
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileItem.FileSize">
            <summary>
            文件的大小
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileItem.MappingName">
            <summary>
            文件的映射名称
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileItem.DownloadTimes">
            <summary>
            文件的下载次数
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileItem.UploadTime">
            <summary>
            文件的上传时间
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileItem.Owner">
            <summary>
            文件的上传人，拥有者
            </summary>
        </member>
        <member name="P:Communication.Enthernet.GroupFileItem.Description">
            <summary>
            文件的额外描述
            </summary>
        </member>
        <member name="M:Communication.Enthernet.GroupFileItem.GetTextFromFileSize">
            <summary>
            获取大小
            </summary>
            <returns>文件大小的字符串描述形式</returns>
        </member>
        <member name="T:Communication.Enthernet.IntegrationFileClient">
            <summary>
            与服务器文件引擎交互的客户端类，支持操作Advanced引擎和Ultimate引擎
            </summary>
            <remarks>
            这里需要需要的是，本客户端支持Advanced引擎和Ultimate引擎文件服务器，服务的类型需要您根据自己的需求来选择。
            </remarks>
            <example>
            此处只演示创建实例，具体的上传，下载，删除的例子请参照对应的方法
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="Intergration File Client" title="IntegrationFileClient示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.DeleteFile(System.String,System.String,System.String,System.String)">
            <summary>
            删除服务器的文件操作
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)">
            <summary>
            下载服务器的文件到本地的文件操作
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="processReport">下载的进度报告</param>
            <param name="fileSaveName">准备本地保存的名称</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是服务器不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="Download File" title="DownloadFile示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream)">
            <summary>
            下载服务器的文件到本地的数据流中
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="processReport">下载的进度报告</param>
            <param name="stream">流数据</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是服务器不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="Download File" title="DownloadFile示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.Drawing.Bitmap@)">
            <summary>
            下载服务器的文件到本地的数据流中
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="processReport">下载的进度报告</param>
            <param name="bitmap">内存文件</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是服务器不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="Download File" title="DownloadFile示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.UploadFile(System.IO.Stream,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传数据流到服务器操作
            </summary>
            <param name="stream">数据流内容</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.UploadFile(System.Drawing.Bitmap,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传内存图片到服务器操作
            </summary>
            <param name="bitmap">内存图片，不能为空</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.TranslateFileName(System.String,System.String,System.String,System.String)">
            <summary>
            根据三种分类信息，还原成在服务器的相对路径，包含文件
            </summary>
            <param name="fileName">文件名称，包含后缀名</param>
            <param name="factory">第一类</param>
            <param name="group">第二类</param>
            <param name="id">第三类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.TranslatePathName(System.String,System.String,System.String)">
            <summary>
            根据三种分类信息，还原成在服务器的相对路径，仅仅路径
            </summary>
            <param name="factory">第一类</param>
            <param name="group">第二类</param>
            <param name="id">第三类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.DownloadPathFileNames(Communication.Enthernet.GroupFileItem[]@,System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的文档
            </summary>
            <param name="fileNames">获取得到的文件合集</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="DownloadPathFileNames" title="DownloadPathFileNames示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.DownloadPathFolders(System.String[]@,System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的文档
            </summary>
            <param name="folders">输出结果</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\CommunicationDemo\FormFileClient.cs" region="DownloadPathFolders" title="DownloadPathFolders示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.IntegrationFileClient.DownloadStringArrays``1(``0[]@,System.Int32,System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的文档
            </summary>
            <param name="arrays">想要获取的队列</param>
            <param name="protocol">指令</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <typeparam name="T">数组的类型</typeparam>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:Communication.Enthernet.UltimateFileServer">
            <summary>
            终极文件管理服务器，实现所有的文件分类管理，读写分离，不支持直接访问文件名
            </summary>
            <remarks>
            本文件的服务器支持存储文件携带的额外信息，文件名被映射成了新的名称，无法在服务器直接查看文件信息。
            </remarks>
            <example>
            以下的示例来自Demo项目，创建了一个简单的服务器对象。
            <code lang="cs" source="TestProject\FileNetServer\FormFileServer.cs" region="Ultimate Server" title="UltimateFileServer示例" />
            </example>
        </member>
        <member name="M:Communication.Enthernet.UltimateFileServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:Communication.Enthernet.UltimateFileServer.m_dictionary_group_marks">
            <summary>
            所有文件组操作的词典锁
            </summary>
        </member>
        <member name="F:Communication.Enthernet.UltimateFileServer.hybirdLock">
            <summary>
            词典的锁
            </summary>
        </member>
        <member name="M:Communication.Enthernet.UltimateFileServer.GetGroupFromFilePath(System.String)">
            <summary>
            获取当前目录的读写锁，如果没有会自动创建
            </summary>
            <param name="filePath">相对路径名</param>
            <returns>读写锁</returns>
        </member>
        <member name="M:Communication.Enthernet.UltimateFileServer.ReceiveFileFromSocketAndUpdateGroup(System.Net.Sockets.Socket,System.String)">
            <summary>
            从套接字接收文件并保存，更新文件列表
            </summary>
            <param name="socket">套接字</param>
            <param name="savename">保存的文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.UltimateFileServer.TransformFactFileName(System.String,System.String,System.String,System.String)">
            <summary>
            根据文件的显示名称转化为真实存储的名称
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件显示名称</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.UltimateFileServer.DeleteExsistingFile(System.String,System.String)">
            <summary>
            删除已经存在的文件信息
            </summary>
            <param name="path">文件的路径</param>
            <param name="fileName">文件的名称</param>
        </member>
        <member name="M:Communication.Enthernet.UltimateFileServer.ThreadPoolLogin(System.Object)">
            <summary>
            处理数据
            </summary>
            <param name="obj">异步对象</param>
        </member>
        <member name="M:Communication.Enthernet.UltimateFileServer.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns>字符串对象</returns>
        </member>
        <member name="T:Communication.Enthernet.NetPushClient">
             <summary>
             发布订阅类的客户端，使用指定的关键订阅相关的数据推送信息
             </summary>
             <remarks>
            
             </remarks>
             <example>
             此处贴上了Demo项目的服务器配置的示例代码
             <code lang="cs" source="TestProject\CommunicationDemo\FormPushNet.cs" region="FormPushNet" title="NetPushClient示例" />
             </example>
        </member>
        <member name="M:Communication.Enthernet.NetPushClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="key">订阅关键字</param>
        </member>
        <member name="M:Communication.Enthernet.NetPushClient.CreatePush(System.Action{Communication.Enthernet.NetPushClient,System.String})">
            <summary>
            创建数据推送服务
            </summary>
            <param name="pushCallBack">触发数据推送的委托</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:Communication.Enthernet.NetPushClient.CreatePush">
            <summary>
            创建数据推送服务，使用事件绑定的机制实现
            </summary>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:Communication.Enthernet.NetPushClient.ClosePush">
            <summary>
            关闭消息推送的界面
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetPushClient.KeyWord">
            <summary>
            本客户端的关键字
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetPushClient.ReConnectTime">
            <summary>
            获取或设置重连服务器的间隔时间
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetPushClient.OnReceived">
            <summary>
            当接收到数据的事件信息，接收到数据的时候触发。
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetPushClient.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Enthernet.NetPushServer">
             <summary>
             发布订阅服务器的类，支持按照关键字进行数据信息的订阅
             </summary>
             <remarks>
            
             </remarks>
             <example>
             此处贴上了Demo项目的服务器配置的示例代码
             <code lang="cs" source="TestProject\PushNetServer\FormServer.cs" region="NetPushServer" title="NetPushServer示例" />
             </example>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.ThreadPoolLogin(System.Object)">
            <summary>
            处理请求接收连接后的方法
            </summary>
            <param name="obj">Accpt对象</param>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.ServerClose">
            <summary>
            关闭服务器的引擎
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.PushString(System.String,System.String)">
            <summary>
            主动推送数据内容
            </summary>
            <param name="key">关键字</param>
            <param name="content">数据内容</param>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.RemoveKey(System.String)">
            <summary>
            移除关键字信息，通常应用于一些特殊临时用途的关键字
            </summary>
            <param name="key">关键字</param>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.CreatePushRemote(System.String,System.Int32,System.String)">
            <summary>
            创建一个远程服务器的数据推送操作，以便推送给子客户端
            </summary>
            <param name="ipAddress">远程的IP地址</param>
            <param name="port">远程的端口号</param>
            <param name="key">订阅的关键字</param>
        </member>
        <member name="P:Communication.Enthernet.NetPushServer.OnlineCount">
            <summary>
            在线客户端的数量
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetPushServer.PushCacheAfterConnect">
            <summary>
            在客户端上线之后，是否推送缓存的数据，默认设置为true
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.IsPushGroupOnline(System.String)">
            <summary>
            判断当前的关键字订阅是否在服务器的词典里面
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.RemoveGroupOnlien(System.String,System.String)">
            <summary>
            移除客户端的数据信息
            </summary>
            <param name="key">指定的客户端</param>
            <param name="clientID">指定的客户端唯一的id信息</param>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.PushSendAsync(Communication.Core.Net.AppSession,System.Byte[])">
            <summary>
            发送数据的方法
            </summary>
            <param name="session">通信用的核心对象</param>
            <param name="content">完整的字节信息</param>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.PushSendCallBack(System.IAsyncResult)">
            <summary>
            发送回发方法
            </summary>
            <param name="ar">异步数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetPushServer.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Enthernet.PushGroupClient">
            <summary>
            订阅分类的核心组织对象
            </summary>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.AddPushClient(Communication.Core.Net.AppSession)">
            <summary>
            新增一个订阅的会话
            </summary>
            <param name="session">会话</param>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.RemovePushClient(System.String)">
            <summary>
            移除一个订阅的会话
            </summary>
            <param name="clientID">客户端唯一的ID信息</param>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.PushString(System.String,System.Action{Communication.Core.Net.AppSession,System.String})">
            <summary>
            使用固定的发送方法将数据发送出去
            </summary>
            <param name="content">数据内容</param>
            <param name="send">指定的推送方法</param>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.RemoveAllClient">
            <summary>
            移除并关闭所有的客户端
            </summary>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.HasPushedContent">
            <summary>
            获取是否推送过数据
            </summary>
            <returns>True代表有，False代表没有</returns>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.Dispose(System.Boolean)">
            <summary>
            释放当前的程序所占用的资源
            </summary>
            <param name="disposing">是否释放资源</param>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.Dispose">
            <summary>
            释放当前的对象所占用的资源
            </summary>
        </member>
        <member name="M:Communication.Enthernet.PushGroupClient.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns></returns>
        </member>
        <member name="T:Communication.Enthernet.Redis.RedisClient">
            <summary>
            这是一个redis的客户端类，支持读取，写入，发布订阅，但是不支持订阅，如果需要订阅，请使用另一个类
            </summary>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="password">密码，如果服务器没有设置，密码设置为null</param>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.#ctor(System.String)">
            <summary>
            实例化一个客户端对象，需要手动指定Ip地址和端口
            </summary>
            <param name="password">密码，如果服务器没有设置，密码设置为null</param>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            如果设置了密码，对密码进行验证
            </summary>
            <param name="socket">网络的套接字服务</param>
            <returns>是否成功的对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            在其他指定的套接字上，使用报文来通讯，传入需要发送的消息，返回一条完整的数据指令
            </summary>
            <param name="socket">指定的套接字</param>
            <param name="send">发送的完整的报文信息</param>
            <remarks>
            无锁的基于套接字直接进行叠加协议的操作。
            </remarks>
            <example>
            假设你有一个自己的socket连接了设备，本组件可以直接基于该socket实现modbus读取，三菱读取，西门子读取等等操作，前提是该服务器支持多协议，虽然这个需求听上去比较变态，但本组件支持这样的操作。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReadFromCoreServerExample1" title="ReadFromCoreServer示例" />
            </example>
            <returns>接收的完整的报文信息</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadCustomer(System.String)">
            <summary>
            自定义的指令交互方法，该指令用空格分割，举例：LTRIM AAAAA 0 999 就是收缩列表，GET AAA 就是获取键值，需要对返回的数据进行二次分析
            </summary>
            <param name="command">举例：LTRIM AAAAA 0 999 就是收缩列表，GET AAA 就是获取键值</param>
            <returns>从服务器返回的结果数据对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.OperateNumberFromServer(System.String[])">
            <summary>
            向服务器请求指定，并返回数字的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>数字的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.OperateLongNumberFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回long数字的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>long数字的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.OperateStringFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回字符串的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>字符串的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.OperateStringsFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回字符串数组的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>字符串数组的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.OperateStatusFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回状态的结果对象，通常用于写入的判断，或是请求类型的判断
            </summary>
            <param name="commands">命令数组</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.DeleteKey(System.String[])">
            <summary>
            删除给定的一个或多个 key 。不存在的 key 会被忽略。
            </summary>
            <param name="keys">关键字</param>
            <returns>被删除 key 的数量。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.DeleteKey(System.String)">
            <summary>
            删除给定的一个或多个 key 。不存在的 key 会被忽略。
            </summary>
            <param name="key">关键字</param>
            <returns>被删除 key 的数量。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ExistsKey(System.String)">
            <summary>
            检查给定 key 是否存在。若 key 存在，返回 1 ，否则返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>若 key 存在，返回 1 ，否则返回 0 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ExpireKey(System.String)">
            <summary>
            为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。设置成功返回 1 。当 key 不存在或者不能为 key 设置生存时间时，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>
            设置成功返回 1 。当 key 不存在或者不能为 key 设置生存时间时，返回 0 。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadAllKeys(System.String)">
            <summary>
            查找所有符合给定模式 pattern 的 key 。
            * 匹配数据库中所有 key。
            h?llo 匹配 hello ， hallo 和 hxllo 等。
            h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。
            </summary>
            <param name="pattern">给定模式</param>
            <returns>符合给定模式的 key 列表。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.MoveKey(System.String,System.Int32)">
            <summary>
            将当前数据库的 key 移动到给定的数据库 db 当中。
            如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。
            因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。
            </summary>
            <param name="key">关键字</param>
            <param name="db">数据块</param>
            <returns>是否移动成功</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.PersistKey(System.String)">
            <summary>
            移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。
            当生存时间移除成功时，返回 1 .
            如果 key 不存在或 key 没有设置生存时间，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>
            当生存时间移除成功时，返回 1 .
            如果 key 不存在或 key 没有设置生存时间，返回 0 。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadRandomKey">
            <summary>
            从当前数据库中随机返回(不删除)一个 key 。
            当数据库不为空时，返回一个 key 。
            当数据库为空时，返回 nil 。
            </summary>
            <returns>
            当数据库不为空时，返回一个 key 。
            当数据库为空时，返回 nil 。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.RenameKey(System.String,System.String)">
            <summary>
            将 key 改名为 newkey 。
            当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。
            当 newkey 已经存在时， RENAME 命令将覆盖旧值。
            </summary>
            <param name="key1">旧的key</param>
            <param name="key2">新的key</param>
            <returns>
            改名成功时提示 OK ，失败时候返回一个错误。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadKeyType(System.String)">
            <summary>
            返回 key 所储存的值的类型。none (key不存在)，string (字符串)，list (列表)，set (集合)，zset (有序集)，hash (哈希表)
            </summary>
            <param name="key">关键字</param>
            <returns>类型</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.AppendKey(System.String,System.String)">
            <summary>
            如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。
            如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。
            返回追加 value 之后， key 中字符串的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <returns>
            追加 value 之后， key 中字符串的长度。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.DecrementKey(System.String)">
            <summary>
            将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            本操作的值限制在 64 位(bit)有符号数字表示之内。
            返回执行 DECR 命令之后 key 的值。
            </summary>
            <param name="key">关键字</param>
            <returns>执行 DECR 命令之后 key 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.DecrementKey(System.String,System.Int64)">
            <summary>
            将 key 所储存的值减去减量 decrement 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            本操作的值限制在 64 位(bit)有符号数字表示之内。
            返回减去 decrement 之后， key 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="value">操作的值</param>
            <returns>返回减去 decrement 之后， key 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadKey(System.String)">
            <summary>
            返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil 。
            假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。
            </summary>
            <param name="key">关键字</param>
            <returns>当 key 不存在时，返回 nil ，否则，返回 key 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadKeyRange(System.String,System.Int32,System.Int32)">
            <summary>
            返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。
            负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。
            返回截取得出的子字符串。
            </summary>
            <param name="key">关键字</param>
            <param name="start">截取开始的位置</param>
            <param name="end">截取结束的位置</param>
            <returns>返回截取得出的子字符串。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadAndWriteKey(System.String,System.String)">
            <summary>
            将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">新的值</param>
            <returns>返回给定 key 的旧值。当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.IncrementKey(System.String)">
            <summary>
            将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            返回执行 INCR 命令之后 key 的值。
            </summary>
            <param name="key">关键字</param>
            <returns>返回执行 INCR 命令之后 key 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Int64)">
            <summary>
            将 key 所储存的值加上增量 increment 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">增量数据</param>
            <returns>加上 increment 之后， key 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Single)">
            <summary>
            将 key 所储存的值加上增量 increment 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBYFLOAT 操作。
            如果命令执行成功，那么 key 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者
            </summary>
            <param name="key">关键字</param>
            <param name="value">增量数据</param>
            <returns>执行命令之后 key 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadKey(System.String[])">
            <summary>
            返回所有(一个或多个)给定 key 的值。
            如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 null 。因此，该命令永不失败。
            </summary>
            <param name="keys">关键字数组</param>
            <returns>一个包含所有给定 key 的值的列表。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteKey(System.String[],System.String[])">
            <summary>
            同时设置一个或多个 key-value 对。
            如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。
            </summary>
            <param name="keys">关键字数组</param>
            <param name="values">值数组</param>
            <returns>总是返回 OK (因为 MSET 不可能失败)</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteKey(System.String,System.String)">
            <summary>
            将字符串值 value 关联到 key 。
            如果 key 已经持有其他值， SET 就覆写旧值，无视类型。
            对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns> SET 在设置操作成功完成时，才返回 OK 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteAndPublishKey(System.String,System.String)">
            <summary>
            将字符串值 value 关联到 key 。并发布一个订阅的频道数据，都成功时，才返回成功
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteExpireKey(System.String,System.String,System.Int64)">
            <summary>
            将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX 命令将覆写旧值。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="seconds">生存时间，单位秒</param>
            <returns>设置成功时返回 OK 。当 seconds 参数不合法时，返回一个错误。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteKeyIfNotExists(System.String,System.String)">
            <summary>
            将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。设置成功，返回 1 。设置失败，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns>设置成功，返回 1 。设置失败，返回 0 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteKeyRange(System.String,System.String,System.Int32)">
            <summary>
            用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。不存在的 key 当作空白字符串处理。返回被 SETRANGE 修改之后，字符串的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="offset">起始的偏移量</param>
            <returns>被 SETRANGE 修改之后，字符串的长度。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadKeyLength(System.String)">
            <summary>
            返回 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。返回符串值的长度。当 key 不存在时，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>字符串值的长度。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListInsertBefore(System.String,System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 当中，位于值 pivot 之前。
            当 pivot 不存在于列表 key 时，不执行任何操作。
            当 key 不存在时， key 被视为空列表，不执行任何操作。
            如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="pivot">原先的值</param>
            <returns>
            如果命令执行成功，返回插入操作完成之后，列表的长度。
            如果没有找到 pivot ，返回 -1 。
            如果 key 不存在或为空列表，返回 0 。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListInsertAfter(System.String,System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 当中，位于值 pivot 之后。
            当 pivot 不存在于列表 key 时，不执行任何操作。
            当 key 不存在时， key 被视为空列表，不执行任何操作。
            如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="pivot">原先的值</param>
            <returns>
            如果命令执行成功，返回插入操作完成之后，列表的长度。
            如果没有找到 pivot ，返回 -1 。
            如果 key 不存在或为空列表，返回 0 。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.GetListLength(System.String)">
            <summary>
            返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 .如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <returns>列表 key 的长度。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadListByIndex(System.String,System.Int64)">
            <summary>
            返回列表 key 中，下标为 index 的元素。下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="index">索引位置</param>
            <returns>列表中下标为 index 的元素。如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListLeftPop(System.String)">
            <summary>
            移除并返回列表 key 的头元素。列表的头元素。当 key 不存在时，返回 nil 。
            </summary>
            <param name="key">关键字信息</param>
            <returns>列表的头元素。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String)">
            <summary>
            将一个或多个值 value 插入到列表 key 的表头，如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。返回执行 LPUSH 命令后，列表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>执行 LPUSH 命令后，列表的长度。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String[])">
            <summary>
            将一个或多个值 value 插入到列表 key 的表头，如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。返回执行 LPUSH 命令后，列表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="values">值</param>
            <returns>执行 LPUSH 命令后，列表的长度。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListLeftPushX(System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。
            返回LPUSHX 命令执行之后，表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>是否插入数据成功</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListRange(System.String,System.Int64,System.Int64)">
            <summary>
            返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。
            下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
            返回一个列表，包含指定区间内的元素。
            </summary>
            <param name="key">关键字</param>
            <param name="start">开始的索引</param>
            <param name="stop">结束的索引</param>
            <returns>返回一个列表，包含指定区间内的元素。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListRemoveElementMatch(System.String,System.Int64,System.String)">
            <summary>
            根据参数 count 的值，移除列表中与参数 value 相等的元素。count 的值可以是以下几种：
            count > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。
            count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。
            count = 0 : 移除表中所有与 value 相等的值。
            返回被移除的数量。
            </summary>
            <param name="key">关键字</param>
            <param name="count">移除参数</param>
            <param name="value">匹配的值</param>
            <returns>被移除元素的数量。因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListSet(System.String,System.Int64,System.String)">
            <summary>
            设置数组的某一个索引的数据信息，当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="index">索引位置</param>
            <param name="value">值</param>
            <returns>操作成功返回 ok ，否则返回错误信息。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListTrim(System.String,System.Int64,System.Int64)">
            <summary>
            对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
            举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。
            下标( index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
            当 key 不是列表类型时，返回一个错误。
            </summary>
            <param name="key">关键字信息</param>
            <param name="start">起始的索引信息</param>
            <param name="end">结束的索引信息</param>
            <returns>操作成功返回 ok ，否则返回错误信息。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListRightPop(System.String)">
            <summary>
            移除并返回列表 key 的尾元素。当 key 不存在时，返回 nil 。
            </summary>
            <param name="key">关键字信息</param>
            <returns>列表的尾元素。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListRightPopLeftPush(System.String,System.String)">
            <summary>
            命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：
            1. 将列表 source 中的最后一个元素( 尾元素)弹出，并返回给客户端。
            2. 将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。
            举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。
            如果 source 不存在，值 nil 被返回，并且不执行其他动作。
            如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转( rotation)操作。
            </summary>
            <param name="key1">第一个关键字</param>
            <param name="key2">第二个关键字</param>
            <returns>返回的移除的对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String)">
            <summary>
            将一个或多个值 value 插入到列表 key 的表尾(最右边)。
            如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>返回执行 RPUSH 操作后，表的长度。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String[])">
            <summary>
            将一个或多个值 value 插入到列表 key 的表尾(最右边)。
            如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，
            如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。
            返回执行 RPUSH 操作后，表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="values">值</param>
            <returns>返回执行 RPUSH 操作后，表的长度。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ListRightPushX(System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。
            和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>RPUSHX 命令执行之后，表的长度。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String)">
            <summary>
            删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <returns>被成功移除的域的数量，不包括被忽略的域。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String[])">
            <summary>
            删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。返回被成功移除的域的数量，不包括被忽略的域。
            </summary>
            <param name="key">关键字</param>
            <param name="fields">所有的域</param>
            <returns>返回被成功移除的域的数量，不包括被忽略的域。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ExistsHashKey(System.String,System.String)">
            <summary>
            查看哈希表 key 中，给定域 field 是否存在。如果哈希表含有给定域，返回 1 。
            如果哈希表不含有给定域，或 key 不存在，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <returns>如果哈希表含有给定域，返回 1 。如果哈希表不含有给定域，或 key 不存在，返回 0 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String)">
            <summary>
            返回哈希表 key 中给定域 field 的值。当给定域不存在或是给定 key 不存在时，返回 nil 
            </summary>
            <param name="key">关键值</param>
            <param name="field">域</param>
            <returns>
            给定域的值。
            当给定域不存在或是给定 key 不存在时，返回 nil 。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadHashKeyAll(System.String)">
            <summary>
            返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。
            </summary>
            <param name="key">关键值</param>
            <returns>
            以列表形式返回哈希表的域和域的值。
            若 key 不存在，返回空列表。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Int64)">
            <summary>
            为哈希表 key 中的域 field 的值加上增量 increment 。增量也可以为负数，相当于对给定域进行减法操作。
            如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">增量值</param>
            <returns>返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Single)">
            <summary>
            为哈希表 key 中的域 field 的值加上增量 increment 。增量也可以为负数，相当于对给定域进行减法操作。
            如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">增量值</param>
            <returns>返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadHashKeys(System.String)">
            <summary>
            返回哈希表 key 中的所有域。当 key 不存在时，返回一个空表。
            </summary>
            <param name="key">关键值</param>
            <returns>
            一个包含哈希表中所有域的表。
            当 key 不存在时，返回一个空表。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadHashKeyLength(System.String)">
            <summary>
            返回哈希表 key 中域的数量。
            </summary>
            <param name="key">关键字</param>
            <returns>哈希表中域的数量。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String[])">
            <summary>
            返回哈希表 key 中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个 nil 值。
            因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。
            </summary>
            <param name="key">关键值</param>
            <param name="fields">指定的域</param>
            <returns>
            一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String,System.String)">
            <summary>
            将哈希表 key 中的域 field 的值设为 value 。
            如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。
            如果域 field 已经存在于哈希表中，旧值将被覆盖。
            如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。
            如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">数据值</param>
            <returns>
            如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。
            如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String[],System.String[])">
            <summary>
            同时将多个 field-value (域-值)对设置到哈希表 key 中。
            此命令会覆盖哈希表中已存在的域。
            如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。
            </summary>
            <param name="key">关键字</param>
            <param name="fields">域</param>
            <param name="values">数据值</param>
            <returns>
            如果命令执行成功，返回 OK 。
            当 key 不是哈希表(hash)类型时，返回一个错误
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.WriteHashKeyNx(System.String,System.String,System.String)">
            <summary>
            将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。若域 field 已经存在，该操作无效。
            设置成功，返回 1 。如果给定域已经存在且没有操作被执行，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">数据值</param>
            <returns>设置成功，返回 1 。如果给定域已经存在且没有操作被执行，返回 0 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadHashValues(System.String)">
            <summary>
            返回哈希表 key 中所有域的值。当 key 不存在时，返回一个空表。
            </summary>
            <param name="key">关键值</param>
            <returns>
            返回哈希表 key 中所有域的值。
            当 key 不存在时，返回一个空表。
            </returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.Save">
            <summary>
            SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。
            </summary>
            <returns>保存成功时返回 OK 。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.SaveAsync">
            <summary>
            在后台异步(Asynchronously)保存当前数据库的数据到磁盘。
            BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。
            </summary>
            <returns>反馈信息。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ReadServerTime">
            <summary>
            获取服务器的时间戳信息，可用于本地时间的数据同步问题
            </summary>
            <returns>带有服务器时间的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.Publish(System.String,System.String)">
            <summary>
            将信息 message 发送到指定的频道 channel，返回接收到信息 message 的订阅者数量。
            </summary>
            <param name="channel">频道，和关键字不是一回事</param>
            <param name="message">消息</param>
            <returns>接收到信息 message 的订阅者数量。</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.SelectDB(System.Int32)">
            <summary>
            切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。默认使用 0 号数据库。
            </summary>
            <param name="db">索引值</param>
            <returns>是否切换成功</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisClient.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Enthernet.Redis.RedisHelper">
            <summary>
            提供了redis辅助类的一些方法
            </summary>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.ReceiveCommandLine(System.Net.Sockets.Socket)">
            <summary>
            接收一行命令数据
            </summary>
            <param name="socket">网络套接字</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.ReceiveCommandString(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            接收一行字符串的信息
            </summary>
            <param name="socket">网络套接字</param>
            <param name="length">字符串的长度</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.ReceiveCommand(System.Net.Sockets.Socket)">
            <summary>
            从网络接收一条redis消息
            </summary>
            <param name="socket">网络套接字</param>
            <returns>接收的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.PackStringCommand(System.String[])">
            <summary>
            将字符串数组打包成一个redis的报文信息
            </summary>
            <param name="commands">字节数据信息</param>
            <returns>结果报文信息</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.GetNumberFromCommandLine(System.Byte[])">
            <summary>
            从原始的结果数据对象中提取出数字数据
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.GetLongNumberFromCommandLine(System.Byte[])">
            <summary>
            从原始的结果数据对象中提取出数字数据
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.GetStringFromCommandLine(System.Byte[])">
            <summary>
            从结果的数据对象里提取字符串的信息
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisHelper.GetStringsFromCommandLine(System.Byte[])">
            <summary>
            从redis的结果数据中分析出所有的字符串信息
            </summary>
            <param name="commandLine">结果数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="T:Communication.Enthernet.Redis.RedisSubscribe">
            <summary>
            Redis协议的订阅操作，一个对象订阅一个或是多个频道的信息
            </summary>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisSubscribe.#ctor(System.String,System.Int32,System.String[])">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="keys">订阅关键字</param>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisSubscribe.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="key">订阅关键字</param>
        </member>
        <member name="P:Communication.Enthernet.Redis.RedisSubscribe.Password">
            <summary>
            如果Redis服务器设置了密码，此处就需要进行设置。必须在CreatePush方法调用前设置
            </summary>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisSubscribe.CreatePush(System.Action{System.String,System.String})">
            <summary>
            创建数据推送服务
            </summary>
            <param name="pushCallBack">触发数据推送的委托</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:Communication.Enthernet.Redis.RedisSubscribe.ClosePush">
            <summary>
            关闭消息推送的界面
            </summary>
        </member>
        <member name="T:Communication.Enthernet.NetSimplifyClient">
             <summary>
             异步访问数据的客户端类，用于向服务器请求一些确定的数据信息
             </summary>
             <remarks>
            
             </remarks>
             <example>
             此处贴上了Demo项目的服务器配置的示例代码
             <code lang="cs" source="TestProject\CommunicationDemo\FormSimplifyNet.cs" region="FormSimplifyNet" title="FormSimplifyNet示例" />
             </example>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.#ctor">
            <summary>
            实例化一个客户端对象，需要手动指定Ip地址和端口
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.ReadFromServer(Communication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，忽略了自定义消息反馈
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.ReadFromServer(Communication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送的字节内容</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(Communication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(Communication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.ReadFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.ReadCustomerFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyClient.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Enthernet.NetSimplifyServer">
             <summary>
             同步消息处理服务器，主要用来实现接收客户端信息并进行消息反馈的操作，适用于客户端进行远程的调用，要求服务器反馈数据。
             </summary>
             <remarks>
            
             </remarks>
             <example>
             此处贴上了Demo项目的服务器配置的示例代码
             <code lang="cs" source="TestProject\SimplifyNetTest\FormServer.cs" region="Simplify Net" title="NetSimplifyServer示例" />
             </example>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.#ctor">
            <summary>
            实例化一个服务器消息请求的信息
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetSimplifyServer.ReceiveStringEvent">
            <summary>
            接收字符串信息的事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetSimplifyServer.ReceivedBytesEvent">
            <summary>
            接收字节信息的事件
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.SendMessage(Communication.Core.Net.AppSession,System.Int32,System.String)">
            <summary>
            向指定的通信对象发送字符串数据
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.SendMessage(Communication.Core.Net.AppSession,System.Int32,System.Byte[])">
            <summary>
            向指定的通信对象发送字节数据
            </summary>
            <param name="session">连接对象</param>
            <param name="customer">用户的指令头</param>
            <param name="bytes">实际的数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.CloseAction">
            <summary>
            关闭网络的操作
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.ThreadPoolLogin(System.Object)">
            <summary>
            处理请求接收连接后的方法
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.SocketReceiveException(Communication.Core.Net.AppSession,System.Exception)">
            <summary>
            处理异常的方法
            </summary>
            <param name="session"></param>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.AppSessionRemoteClose(Communication.Core.Net.AppSession)">
            <summary>
            正常下线
            </summary>
            <param name="session">会话</param>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.DataProcessingCenter(Communication.Core.Net.AppSession,System.Int32,System.Int32,System.Byte[])">
            <summary>
            数据处理中心
            </summary>
            <param name="session">当前的会话</param>
            <param name="protocol">协议指令头</param>
            <param name="customer">客户端信号</param>
            <param name="content">触发的消息内容</param>
        </member>
        <member name="P:Communication.Enthernet.NetSimplifyServer.ClientCount">
            <summary>
            当前在线的客户端数量
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetSimplifyServer.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:Communication.Enthernet.NetSoftUpdateServer">
            <summary>
            用于服务器支持软件全自动更新升级的类
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetSoftUpdateServer.#ctor(System.String)">
            <summary>
            实例化一个对象
            </summary>
            <param name="updateExeFileName">更新程序的名称</param>
        </member>
        <member name="P:Communication.Enthernet.NetSoftUpdateServer.FileUpdatePath">
            <summary>
            系统升级时客户端所在的目录，默认为C:\Communication
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetSoftUpdateServer.ThreadPoolLogin(System.Object)">
            <summary>
            系统的登录方法
            </summary>
            <param name="obj">接收的socket对象</param>
        </member>
        <member name="M:Communication.Enthernet.NetSoftUpdateServer.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Enthernet.NetUdpClient">
            <summary>
            UDP客户端的类，只负责发送数据到服务器，该数据经过封装
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.#ctor(System.String,System.Int32)">
            <summary>
            实例化对象，指定发送的服务器地址和端口号
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.ReadFromServer(Communication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，忽略了自定义消息反馈
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.ReadFromServer(Communication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送的字节内容</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.ReadCustomerFromServer(Communication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.ReadCustomerFromServer(Communication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.ReadFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.ReadCustomerFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:Communication.Enthernet.NetUdpClient.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Enthernet.NetUdpServer">
            <summary>
            Udp网络的服务器端类
            </summary>
        </member>
        <member name="P:Communication.Enthernet.NetUdpServer.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetUdpServer.ServerStart(System.Int32)">
            <summary>
            根据指定的端口启动Upd侦听
            </summary>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:Communication.Enthernet.NetUdpServer.CloseAction">
            <summary>
            关闭引擎的操作
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetUdpServer.RefreshReceive">
            <summary>
            重新开始接收数据
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Communication.Enthernet.NetUdpServer.DataProcessingCenter(Communication.Core.Net.AppSession,System.Int32,System.Int32,System.Byte[])">
            <summary>
            数据处理中心
            </summary>
            <param name="receive"></param>
            <param name="protocol"></param>
            <param name="customer"></param>
            <param name="content"></param>
        </member>
        <member name="M:Communication.Enthernet.NetUdpServer.SendMessage(Communication.Core.Net.AppSession,System.Int32,System.String)">
            <summary>
            向指定的通信对象发送字符串数据
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数据</param>
        </member>
        <member name="M:Communication.Enthernet.NetUdpServer.SendMessage(Communication.Core.Net.AppSession,System.Int32,System.Byte[])">
            <summary>
            向指定的通信对象发送字节数据
            </summary>
            <param name="session">连接对象</param>
            <param name="customer">用户的指令头</param>
            <param name="bytes">实际的数据</param>
        </member>
        <member name="E:Communication.Enthernet.NetUdpServer.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:Communication.Enthernet.NetUdpServer.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:Communication.Enthernet.NetUdpServer.ToString">
            <summary>
            获取本对象的字符串表示形式
            </summary>
            <returns></returns>
        </member>
        <member name="T:Communication.Instrument.Temperature.DAM3601">
            <summary>
            阿尔泰科技发展有限公司的DAM3601温度采集模块，基于ModbusRtu开发完成。
            </summary>
            <remarks>
            该温度采集模块是基于modbus-rtu，但不是标准的modbus协议，存在一些小误差，需要重写实现，并且提供了基础的数据转换
            </remarks>
        </member>
        <member name="M:Communication.Instrument.Temperature.DAM3601.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Instrument.Temperature.DAM3601.#ctor(System.Byte)">
            <summary>
            使用站号实例化默认的对象
            </summary>
            <param name="station">站号信息</param>
        </member>
        <member name="M:Communication.Instrument.Temperature.DAM3601.ReadAllTemperature">
            <summary>
            读取所有的温度数据，并转化成相关的信息
            </summary>
            <returns>结果数据对象</returns>
        </member>
        <member name="M:Communication.Instrument.Temperature.DAM3601.TransformValue(System.Int16)">
            <summary>
            数据转换方法，将读取的值，
            </summary>
            <param name="value">读取的值</param>
            <returns>转换后的值</returns>
        </member>
        <member name="M:Communication.Instrument.Temperature.DAM3601.Read(System.String,System.UInt16)">
            <summary>
            从Modbus服务器批量读取寄存器的信息，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"，或者是带功能码格式x=3;1234</param>
            <param name="length">读取的数量</param>
            <returns>带有成功标志的字节信息</returns>
            <example>
            此处演示批量读取的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="ReadExample2" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Instrument.Temperature.DAM3601.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Language.DefaultLanguage">
            <summary>
            系统的语言基类，默认也即是中文版本
            </summary>
        </member>
        <member name="T:Communication.Language.English">
            <summary>
            English Version Text
            </summary>
        </member>
        <member name="T:Communication.LogNet.ILogNet">
            <summary>
            一个通用的日志接口
            </summary>
            <remarks>
            本组件的日志核心机制，如果您使用了本组件却不想使用本组件的日志组件功能，可以自己实现新的日志组件，只要继承本接口接口。其他常用的日志组件如下：（都是可以实现的）
            <list type="number">
            <item>Log4Net</item>
            <item>NLog</item>
            </list>
            </remarks>
            <example>
            实现类就不放示例代码了，存储日志的使用都是一样的，就是实例化的时候不一致，以下示例代码以单文件日志为例
            <code lang="cs" source="TestProject\CommunicationDemo\FormLogNet.cs" region="ILogNet" title="ILogNet示例" />
            </example>
        </member>
        <member name="P:Communication.LogNet.ILogNet.LogSaveMode">
            <summary>
            文件存储模式，1:单文件，2:根据大小，3:根据时间
            </summary>
        </member>
        <member name="E:Communication.LogNet.ILogNet.BeforeSaveToFile">
            <summary>
            存储之前引发的事件，允许额外的操作
            </summary>
        </member>
        <member name="M:Communication.LogNet.ILogNet.RecordMessage(Communication.LogNet.HslMessageDegree,System.String,System.String)">
            <summary>
            自定义的消息记录
            </summary>
            <param name="degree">消息等级</param>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteDebug(System.String)">
            <summary>
            写入一条调试日志
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteDebug(System.String,System.String)">
            <summary>
            写入一条调试日志
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteDescrition(System.String)">
            <summary>
            写入一条解释性的信息
            </summary>
            <param name="description"></param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteError(System.String)">
            <summary>
            写入一条错误日志
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteError(System.String,System.String)">
            <summary>
            写入一条错误日志
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteException(System.String,System.Exception)">
            <summary>
            写入一条异常信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteException(System.String,System.String,System.Exception)">
            <summary>
            写入一条异常信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">内容</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteFatal(System.String)">
            <summary>
            写入一条致命日志
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteFatal(System.String,System.String)">
            <summary>
            写入一条致命日志
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteInfo(System.String)">
            <summary>
            写入一条信息日志
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteInfo(System.String,System.String)">
            <summary>
            写入一条信息日志
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteNewLine">
            <summary>
            写入一行换行符
            </summary>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteAnyString(System.String)">
            <summary>
            写入任意字符串
            </summary>
            <param name="text">文本</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteWarn(System.String)">
            <summary>
            写入一条警告日志
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.WriteWarn(System.String,System.String)">
            <summary>
            写入一条警告日志
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.SetMessageDegree(Communication.LogNet.HslMessageDegree)">
            <summary>
            设置日志的存储等级，高于该等级的才会被存储
            </summary>
            <param name="degree">登记信息</param>
        </member>
        <member name="M:Communication.LogNet.ILogNet.GetExistLogFileNames">
            <summary>
            获取已存在的日志文件名称
            </summary>
            <returns>文件列表</returns>
        </member>
        <member name="M:Communication.LogNet.ILogNet.FiltrateKeyword(System.String)">
            <summary>
            过滤掉指定的关键字的日志，该信息不存储，但仍然触发BeforeSaveToFile事件
            </summary>
            <param name="keyword">关键字</param>
        </member>
        <member name="T:Communication.LogNet.LogNetBase">
            <summary>
            日志存储类的基类，提供一些基础的服务
            </summary>
            <remarks>
            基于此类可以实现任意的规则的日志存储规则，欢迎大家补充实现，本组件实现了3个日志类
            <list type="number">
            <item>单文件日志类 <see cref="T:Communication.LogNet.LogNetSingle"/></item>
            <item>根据文件大小的类 <see cref="T:Communication.LogNet.LogNetFileSize"/></item>
            <item>根据时间进行存储的类 <see cref="T:Communication.LogNet.LogNetDateTime"/></item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.#ctor">
            <summary>
            实例化一个日志对象
            </summary>
        </member>
        <member name="F:Communication.LogNet.LogNetBase.m_fileSaveLock">
            <summary>
            文件存储的锁
            </summary>
        </member>
        <member name="E:Communication.LogNet.LogNetBase.BeforeSaveToFile">
            <summary>
            在存储到文件的时候将会触发的事件
            </summary>
        </member>
        <member name="P:Communication.LogNet.LogNetBase.LogSaveMode">
            <summary>
            日志存储模式，1:单文件，2:按大小存储，3:按时间存储
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteDebug(System.String)">
            <summary>
            写入一条调试信息
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteDebug(System.String,System.String)">
            <summary>
            写入一条调试信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteInfo(System.String)">
            <summary>
            写入一条普通信息
            </summary>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteInfo(System.String,System.String)">
            <summary>
            写入一条普通信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteWarn(System.String)">
            <summary>
            写入一条警告信息
            </summary>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteWarn(System.String,System.String)">
            <summary>
            写入一条警告信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteError(System.String)">
            <summary>
            写入一条错误消息
            </summary>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteError(System.String,System.String)">
            <summary>
            写入一条错误消息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteFatal(System.String)">
            <summary>
            写入一条致命错误信息
            </summary>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteFatal(System.String,System.String)">
            <summary>
            写入一条致命错误信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">文本内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteException(System.String,System.Exception)">
            <summary>
            写入一条异常信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteException(System.String,System.String,System.Exception)">
            <summary>
            写入一条异常信息
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">内容</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.RecordMessage(Communication.LogNet.HslMessageDegree,System.String,System.String)">
            <summary>
            记录一条自定义的消息
            </summary>
            <param name="degree">消息的等级</param>
            <param name="keyWord">关键字</param>
            <param name="text">文本</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteDescrition(System.String)">
            <summary>
            写入一条解释性的消息，不需要带有回车键
            </summary>
            <param name="description">解释性的文本</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteAnyString(System.String)">
            <summary>
            写入一条任意字符
            </summary>
            <param name="text">内容</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.WriteNewLine">
            <summary>
            写入一条换行符
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.SetMessageDegree(Communication.LogNet.HslMessageDegree)">
            <summary>
            设置日志的存储等级，高于该等级的才会被存储
            </summary>
            <param name="degree">消息等级</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.FiltrateKeyword(System.String)">
            <summary>
            过滤指定的关键字存储
            </summary>
            <param name="keyWord">关键字</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.GetFileSaveName">
            <summary>
            获取要存储的文件的名称
            </summary>
            <returns>完整的文件路径信息，带文件名</returns>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.CheckPathEndWithSprit(System.String)">
            <summary>
            返回检查的路径名称，将会包含反斜杠
            </summary>
            <param name="filePath">路径信息</param>
            <returns>检查后的结果对象</returns>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing">是否初次调用</param>
        </member>
        <member name="M:Communication.LogNet.LogNetBase.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="T:Communication.LogNet.HslEventArgs">
            <summary>
            带有日志消息的事件
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslEventArgs.HslMessage">
            <summary>
            消息信息
            </summary>
        </member>
        <member name="T:Communication.LogNet.LogNetException">
            <summary>
            日志存储回调的异常信息
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetException.#ctor(System.Exception)">
            <summary>
            使用其他的异常信息来初始化日志异常
            </summary>
            <param name="innerException">异常信息</param>
        </member>
        <member name="T:Communication.LogNet.GenerateMode">
            <summary>
            日志文件输出模式
            </summary>
        </member>
        <member name="F:Communication.LogNet.GenerateMode.ByEveryHour">
            <summary>
            按每个小时生成日志文件
            </summary>
        </member>
        <member name="F:Communication.LogNet.GenerateMode.ByEveryDay">
            <summary>
            按每天生成日志文件
            </summary>
        </member>
        <member name="F:Communication.LogNet.GenerateMode.ByEveryWeek">
            <summary>
            按每个周生成日志文件
            </summary>
        </member>
        <member name="F:Communication.LogNet.GenerateMode.ByEveryMonth">
            <summary>
            按每个月生成日志文件
            </summary>
        </member>
        <member name="F:Communication.LogNet.GenerateMode.ByEverySeason">
            <summary>
            按每季度生成日志文件
            </summary>
        </member>
        <member name="F:Communication.LogNet.GenerateMode.ByEveryYear">
            <summary>
            按每年生成日志文件
            </summary>
        </member>
        <member name="T:Communication.LogNet.HslMessageDegree">
            <summary>
            记录消息的等级
            </summary>
        </member>
        <member name="F:Communication.LogNet.HslMessageDegree.None">
            <summary>
            一条消息都不记录
            </summary>
        </member>
        <member name="F:Communication.LogNet.HslMessageDegree.FATAL">
            <summary>
            记录致命等级及以上日志的消息
            </summary>
        </member>
        <member name="F:Communication.LogNet.HslMessageDegree.ERROR">
            <summary>
            记录异常等级及以上日志的消息
            </summary>
        </member>
        <member name="F:Communication.LogNet.HslMessageDegree.WARN">
            <summary>
            记录警告等级及以上日志的消息
            </summary>
        </member>
        <member name="F:Communication.LogNet.HslMessageDegree.INFO">
            <summary>
            记录信息等级及以上日志的消息
            </summary>
        </member>
        <member name="F:Communication.LogNet.HslMessageDegree.DEBUG">
            <summary>
            记录调试等级及以上日志的信息
            </summary>
        </member>
        <member name="T:Communication.LogNet.HslMessageItem">
            <summary>
            单个日志的记录信息
            </summary>
        </member>
        <member name="M:Communication.LogNet.HslMessageItem.#ctor">
            <summary>
            默认的无参构造器
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslMessageItem.Id">
            <summary>
            单个记录信息的标识ID，程序重新运行时清空
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslMessageItem.Degree">
            <summary>
            消息的等级
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslMessageItem.ThreadId">
            <summary>
            线程ID
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslMessageItem.Text">
            <summary>
            消息文本
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslMessageItem.Time">
            <summary>
            消息发生的事件
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslMessageItem.KeyWord">
            <summary>
            消息的关键字
            </summary>
        </member>
        <member name="P:Communication.LogNet.HslMessageItem.Cancel">
            <summary>
            是否取消写入到文件中去，在事件BeforeSaveToFile触发的时候捕获即可设置。
            </summary>
        </member>
        <member name="M:Communication.LogNet.HslMessageItem.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.LogNet.HslMessageItem.ToStringWithoutKeyword">
            <summary>
            返回表示当前对象的字符串，剔除了关键字
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.LogNet.LogNetManagment">
            <summary>
            日志类的管理器
            </summary>
        </member>
        <member name="F:Communication.LogNet.LogNetManagment.LogSaveModeBySingleFile">
            <summary>
            存储文件的时候指示单文件存储
            </summary>
        </member>
        <member name="F:Communication.LogNet.LogNetManagment.LogSaveModeByFileSize">
            <summary>
            存储文件的时候指示根据文件大小存储
            </summary>
        </member>
        <member name="F:Communication.LogNet.LogNetManagment.LogSaveModeByDateTime">
            <summary>
            存储文件的时候指示根据日志时间来存储
            </summary>
        </member>
        <member name="F:Communication.LogNet.LogNetManagment.LogFileHeadString">
            <summary>
            日志文件的头标志
            </summary>
        </member>
        <member name="P:Communication.LogNet.LogNetManagment.LogNet">
            <summary>
            公开的一个静态变量，允许随意的设置
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetManagment.GetSaveStringFromException(System.String,System.Exception)">
            <summary>
            通过异常文本格式化成字符串用于保存或发送
            </summary>
            <param name="text">文本消息</param>
            <param name="ex">异常</param>
            <returns>异常最终信息</returns>
        </member>
        <member name="T:Communication.LogNet.LogNetDateTime">
            <summary>
            一个日志组件，可以根据时间来区分不同的文件存储
            </summary>
            <remarks>
            此日志实例将根据日期时间来进行分类，支持的时间分类如下：
            <list type="number">
            <item>小时</item>
            <item>天</item>
            <item>周</item>
            <item>月份</item>
            <item>季度</item>
            <item>年份</item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.LogNet.LogNetDateTime.#ctor(System.String,Communication.LogNet.GenerateMode)">
            <summary>
            实例化一个根据时间存储的日志组件
            </summary>
            <param name="filePath">文件存储的路径</param>
            <param name="generateMode">存储文件的间隔</param>
        </member>
        <member name="F:Communication.LogNet.LogNetDateTime.m_fileName">
            <summary>
            当前正在存储的文件名称
            </summary>
        </member>
        <member name="F:Communication.LogNet.LogNetDateTime.m_filePath">
            <summary>
            文件的路径
            </summary>
        </member>
        <member name="F:Communication.LogNet.LogNetDateTime.m_generateMode">
            <summary>
            文件的存储模式，默认按照年份来存储
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetDateTime.GetFileSaveName">
            <summary>
            获取需要保存的日志文件
            </summary>
            <returns>完整的文件路径，含文件名</returns>
        </member>
        <member name="M:Communication.LogNet.LogNetDateTime.GetExistLogFileNames">
            <summary>
            获取所有的文件夹中的日志文件
            </summary>
            <returns>所有的文件路径集合</returns>
        </member>
        <member name="T:Communication.LogNet.LogNetFileSize">
            <summary>
            根据文件的大小来存储日志信息
            </summary>
            <remarks>
            此日志的实例是根据文件的大小储存，例如设置了2M，每隔2M，系统将生成一个新的日志文件。
            </remarks>
        </member>
        <member name="M:Communication.LogNet.LogNetFileSize.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个根据文件大小生成新文件的
            </summary>
            <param name="filePath">日志文件的保存路径</param>
            <param name="fileMaxSize">每个日志文件的最大大小，默认2M</param>
        </member>
        <member name="F:Communication.LogNet.LogNetFileSize.m_fileName">
            <summary>
            当前正在存储的文件名称
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetFileSize.GetFileSaveName">
            <summary>
            获取需要保存的日志文件
            </summary>
            <returns>字符串数据</returns>
        </member>
        <member name="M:Communication.LogNet.LogNetFileSize.GetLastAccessFileName">
            <summary>
            获取之前保存的日志文件
            </summary>
            <returns></returns>
        </member>
        <member name="M:Communication.LogNet.LogNetFileSize.GetDefaultFileName">
            <summary>
            获取一个新的默认的文件名称
            </summary>
            <returns></returns>
        </member>
        <member name="M:Communication.LogNet.LogNetFileSize.GetExistLogFileNames">
            <summary>
            返回所有的日志文件
            </summary>
            <returns>所有的日志文件信息</returns>
        </member>
        <member name="T:Communication.LogNet.LogNetSingle">
            <summary>
            单日志文件对象
            </summary>
            <remarks>
            此日志实例化需要指定一个完整的文件路径，当需要记录日志的时候调用方法，会使得日志越来越大，对于写入的性能没有太大影响，但是会影响文件读取。
            </remarks>
        </member>
        <member name="M:Communication.LogNet.LogNetSingle.#ctor(System.String)">
            <summary>
            实例化一个单文件日志的对象
            </summary>
            <param name="filePath">文件的路径</param>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:Communication.LogNet.LogNetSingle.ClearLog">
            <summary>
            单日志文件允许清空日志内容
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetSingle.GetAllSavedLog">
            <summary>
            获取单日志文件的所有保存记录
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.LogNet.LogNetSingle.GetExistLogFileNames">
            <summary>
            获取所有的日志文件数组，对于单日志文件来说就只有一个
            </summary>
            <returns>字符串数组，包含了所有的存在的日志数据</returns>
        </member>
        <member name="M:Communication.LogNet.LogNetSingle.GetFileSaveName">
            <summary>
            获取存储的文件的名称
            </summary>
            <returns>字符串数据</returns>
        </member>
        <member name="T:Communication.LogNet.FormLogNetView">
            <summary>
            日志查看器的窗口类，用于分析统计日志数据
            </summary>
        </member>
        <member name="M:Communication.LogNet.FormLogNetView.#ctor">
            <summary>
            实例化一个日志查看器的窗口
            </summary>
        </member>
        <member name="F:Communication.LogNet.FormLogNetView.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Communication.LogNet.FormLogNetView.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Communication.LogNet.FormLogNetView.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Communication.LogNet.LogNetAnalysisControl">
            <summary>
            一个用于日志分析的控件
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetAnalysisControl.#ctor">
            <summary>
            实例化一个控件信息
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetAnalysisControl.SetLogNetSource(System.String)">
            <summary>
            设置日志的数据源
            </summary>
            <param name="logSource">直接从日志文件中读到的数据或是来自网络的数据</param>
        </member>
        <member name="M:Communication.LogNet.LogNetAnalysisControl.FilterLogSource(System.String)">
            <summary>
            从现有的日志中筛选数据
            </summary>
            <param name="degree"></param>
        </member>
        <member name="M:Communication.LogNet.LogNetAnalysisControl.AnalysisLogSource(System.DateTime,System.DateTime,System.String)">
            <summary>
            底层的数据分析筛选
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="degree"></param>
        </member>
        <member name="F:Communication.LogNet.LogNetAnalysisControl.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Communication.LogNet.LogNetAnalysisControl.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Communication.LogNet.LogNetAnalysisControl.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Communication.ModBus.ModbusAscii">
            <summary>
            Modbus-Ascii通讯协议的类库，基于rtu类库完善过来
            </summary>
            <remarks>
            本客户端支持的标准的modbus-tcp协议，内置的消息号会进行自增，地址格式采用富文本表示形式
            <note type="important">
            地址共可以携带3个信息，最完整的表示方式"s=2;x=3;100"，对应的modbus报文是 02 03 00 64 00 01 的前四个字节，站号，功能码，起始地址，下面举例
            <list type="definition">
            <item>
            <term>读取线圈</term>
            <description>ReadCoil("100")表示读取线圈100的值，ReadCoil("s=2;100")表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
            <term>读取离散输入</term>
            <description>ReadDiscrete("100")表示读取离散输入100的值，ReadDiscrete("s=2;100")表示读取站号为2，离散地址为100的值</description>
            </item>
            <item>
            <term>读取寄存器</term>
            <description>ReadInt16("100")表示读取寄存器100的值，ReadInt16("s=2;100")表示读取站号为2，寄存器100的值</description>
            </item>
            <item>
            <term>读取输入寄存器</term>
            <description>ReadInt16("x=4;100")表示读取输入寄存器100的值，ReadInt16("s=2;x=4;100")表示读取站号为2，输入寄存器100的值</description>
            </item>
            </list>
            对于写入来说也是一致的
            <list type="definition">
            <item>
            <term>写入线圈</term>
            <description>WriteCoil("100",true)表示读取线圈100的值，WriteCoil("s=2;100",true)表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
            <term>写入寄存器</term>
            <description>Write("100",(short)123)表示写寄存器100的值123，Write("s=2;100",(short)123)表示写入站号为2，寄存器100的值123</description>
            </item>
            </list>
            </note>
            </remarks>
            <example>
            基本的用法请参照下面的代码示例，初始化部分的代码省略
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="Example" title="Modbus示例" />
            复杂的读取数据的代码示例如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="ReadExample" title="read示例" />
            写入数据的代码如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="WriteExample" title="write示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusAscii.#ctor">
            <summary>
            实例化一个Modbus-ascii协议的客户端对象
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModbusAscii.#ctor(System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化
            </summary>
            <param name="station">站号</param>
        </member>
        <member name="M:Communication.ModBus.ModbusAscii.CheckModbusTcpResponse(System.Byte[])">
            <summary>
            检查当前的Modbus-Ascii响应是否是正确的
            </summary>
            <param name="send">发送的数据信息</param>
            <returns>带是否成功的结果数据</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusAscii.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.ModBus.ModbusInfo">
            <summary>
            Modbus协议相关的一些信息
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.ReadCoil">
            <summary>
            读取线圈
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.ReadDiscrete">
            <summary>
            读取离散量
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.ReadRegister">
            <summary>
            读取寄存器
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.ReadInputRegister">
            <summary>
            读取输入寄存器
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.WriteOneCoil">
            <summary>
            写单个线圈
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.WriteOneRegister">
            <summary>
            写单个寄存器
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.WriteCoil">
            <summary>
            写多个线圈
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.WriteRegister">
            <summary>
            写多个寄存器
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.FunctionCodeNotSupport">
            <summary>
            不支持该功能码
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.FunctionCodeOverBound">
            <summary>
            该地址越界
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.FunctionCodeQuantityOver">
            <summary>
            读取长度超过最大值
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModbusInfo.FunctionCodeReadWriteException">
            <summary>
            读写异常
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModbusInfo.PackCommandToTcp(System.Byte[],System.UInt16)">
            <summary>
            将modbus指令打包成Modbus-Tcp指令
            </summary>
            <param name="value">Modbus指令</param>
            <param name="id">消息的序号</param>
            <returns>Modbus-Tcp指令</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusInfo.PackCommandToRtu(System.Byte[])">
            <summary>
            将modbus指令打包成Modbus-Rtu指令
            </summary>
            <param name="value">Modbus指令</param>
            <returns>Modbus-Rtu指令</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusInfo.TransRtuToAsciiPackCommand(System.Byte[])">
            <summary>
            将一个modbus-rtu的数据报文，转换成modbus-ascii的数据报文
            </summary>
            <param name="value">modbus-rtu的完整报文，携带相关的校验码</param>
            <returns>可以用于直接发送的modbus-ascii的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusInfo.TransAsciiPackCommandToRtu(System.Byte[])">
            <summary>
            将一个modbus-ascii的数据报文，转换成的modbus核心数据报文
            </summary>
            <param name="value">modbus-ascii的完整报文，携带相关的校验码</param>
            <returns>可以用于直接发送的modbus的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusInfo.AnalysisAddress(System.String,System.Boolean,System.Byte)">
            <summary>
            分析Modbus协议的地址信息，该地址适应于tcp及rtu模式
            </summary>
            <param name="address">带格式的地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码信息</param>
            <returns>转换后的地址信息</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusInfo.GetDescriptionByErrorCode(System.Byte)">
            <summary>
            通过错误码来获取到对应的文本消息
            </summary>
            <param name="code">错误码</param>
            <returns>错误的文本描述</returns>
        </member>
        <member name="T:Communication.ModBus.ModBusMonitorAddress">
            <summary>
            服务器端提供的数据监视服务
            </summary>
        </member>
        <member name="P:Communication.ModBus.ModBusMonitorAddress.Address">
            <summary>
            本次数据监视的地址
            </summary>
        </member>
        <member name="E:Communication.ModBus.ModBusMonitorAddress.OnWrite">
            <summary>
            数据写入时触发的事件
            </summary>
        </member>
        <member name="E:Communication.ModBus.ModBusMonitorAddress.OnChange">
            <summary>
            数据改变时触发的事件
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModBusMonitorAddress.SetValue(System.Int16)">
            <summary>
            强制设置触发事件
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Communication.ModBus.ModBusMonitorAddress.SetChangeValue(System.Int16,System.Int16)">
            <summary>
            强制设置触发值变更事件
            </summary>
            <param name="before">变更前的值</param>
            <param name="after">变更后的值</param>
        </member>
        <member name="T:Communication.ModBus.ModbusRtu">
            <summary>
            Modbus-Rtu通讯协议的类库，多项式码0xA001
            </summary>
            <remarks>
            本客户端支持的标准的modbus-rtu协议，自动实现了CRC16的验证，地址格式采用富文本表示形式
            <note type="important">
            地址共可以携带3个信息，最完整的表示方式"s=2;x=3;100"，对应的modbus报文是 02 03 00 64 00 01 的前四个字节，站号，功能码，起始地址，下面举例
            <list type="definition">
            <item>
            <term>读取线圈</term>
            <description>ReadCoil("100")表示读取线圈100的值，ReadCoil("s=2;100")表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
            <term>读取离散输入</term>
            <description>ReadDiscrete("100")表示读取离散输入100的值，ReadDiscrete("s=2;100")表示读取站号为2，离散地址为100的值</description>
            </item>
            <item>
            <term>读取寄存器</term>
            <description>ReadInt16("100")表示读取寄存器100的值，ReadInt16("s=2;100")表示读取站号为2，寄存器100的值</description>
            </item>
            <item>
            <term>读取输入寄存器</term>
            <description>ReadInt16("x=4;100")表示读取输入寄存器100的值，ReadInt16("s=2;x=4;100")表示读取站号为2，输入寄存器100的值</description>
            </item>
            </list>
            对于写入来说也是一致的
            <list type="definition">
            <item>
            <term>写入线圈</term>
            <description>WriteCoil("100",true)表示读取线圈100的值，WriteCoil("s=2;100",true)表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
            <term>写入寄存器</term>
            <description>Write("100",(short)123)表示写寄存器100的值123，Write("s=2;100",(short)123)表示写入站号为2，寄存器100的值123</description>
            </item>
            </list>
            </note>
            </remarks>
            <example>
            基本的用法请参照下面的代码示例，初始化部分的代码省略
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="Example2" title="Modbus示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.#ctor">
            <summary>
            实例化一个Modbus-Rtu协议的客户端对象
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.#ctor(System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="P:Communication.ModBus.ModbusRtu.AddressStartWithZero">
            <summary>
            获取或设置起始的地址是否从0开始，默认为True
            </summary>
            <remarks>
            <note type="warning">因为有些设备的起始地址是从1开始的，就要设置本属性为<c>True</c></note>
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusRtu.Station">
            <summary>
            获取或者重新修改服务器的默认站号信息
            </summary>
            <remarks>
            当你调用 ReadCoil("100") 时，对应的站号就是本属性的值，当你调用 ReadCoil("s=2;100") 时，就忽略本属性的值，读写寄存器的时候同理
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusRtu.DataFormat">
            <summary>
            获取或设置数据解析的格式，默认ABCD，可选BADC，CDAB，DCBA格式
            </summary>
            <remarks>
            对于Int32,UInt32,float,double,Int64,UInt64类型来说，存在多地址的电脑情况，需要和服务器进行匹配
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusRtu.IsStringReverse">
            <summary>
            字符串数据是否按照字来反转
            </summary>
            <remarks>
            字符串按照2个字节的排列进行颠倒，根据实际情况进行设置
            </remarks>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildReadCoilCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取线圈的指令头
            </summary>
            <param name="address">地址</param>
            <param name="count">长度</param>
            <returns>携带有命令字节</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildReadDiscreteCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取离散信息的指令头
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>携带有命令字节</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildReadRegisterCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取寄存器的指令头
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>携带有命令字节</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildReadRegisterCommand(Communication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            生成一个读取寄存器的指令头
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>携带有命令字节</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildWriteOneCoilCommand(System.String,System.Boolean)">
            <summary>
            生成一个写入单线圈的指令头
            </summary>
            <param name="address">地址</param>
            <param name="value">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildWriteOneRegisterCommand(System.String,System.Byte[])">
            <summary>
            生成一个写入单个寄存器的报文
            </summary>
            <param name="address">地址</param>
            <param name="data">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildWriteCoilCommand(System.String,System.Boolean[])">
            <summary>
            生成批量写入单个线圈的报文信息
            </summary>
            <param name="address">地址</param>
            <param name="values">实际数据值</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.BuildWriteRegisterCommand(System.String,System.Byte[])">
            <summary>
            生成批量写入寄存器的报文信息
            </summary>
            <param name="address">地址</param>
            <param name="values">实际值</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.CheckModbusTcpResponse(System.Byte[])">
            <summary>
            检查当前的Modbus-Rtu响应是否是正确的
            </summary>
            <param name="send">发送的数据信息</param>
            <returns>带是否成功的结果数据</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.CheckReceiveBytes(System.Byte[])">
            <summary>
            检查当前接收的字节数据是否正确的
            </summary>
            <param name="rBytes">从设备反馈回来的数据</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.ReadModBusBase(System.Byte,System.String,System.UInt16)">
            <summary>
            读取服务器的数据，需要指定不同的功能码
            </summary>
            <param name="code">指令</param>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>带结果信息的字节返回数据</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.ReadModBusBase(Communication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            读取服务器的数据，需要指定不同的功能码
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>带结果信息的字节返回数据</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.ReadCoil(System.String)">
            <summary>
            读取线圈，需要指定起始地址
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.ReadCoil(System.String,System.UInt16)">
            <summary>
            批量的读取线圈，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.ReadDiscrete(System.String)">
            <summary>
            读取输入线圈，需要指定起始地址
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.ReadDiscrete(System.String,System.UInt16)">
            <summary>
            批量的读取输入点，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.Read(System.String,System.UInt16)">
            <summary>
            从Modbus服务器批量读取寄存器的信息，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"，或者是带功能码格式x=3;1234</param>
            <param name="length">读取的数量</param>
            <returns>带有成功标志的字节信息</returns>
            <example>
            此处演示批量读取的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="ReadExample2" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.Byte,System.Byte)">
            <summary>
            写一个寄存器数据
            </summary>
            <param name="address">起始地址</param>
            <param name="high">高位</param>
            <param name="low">地位</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.Int16)">
            <summary>
            写一个寄存器数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.UInt16)">
            <summary>
            写一个寄存器数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到Modbus的寄存器上去，需要指定起始地址和数据内容
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="value">写入的数据，长度根据data的长度来指示</param>
            <returns>返回写入结果</returns>
            <remarks>
            富地址格式，支持携带站号信息，功能码信息，具体参照类的示例代码
            </remarks>
            <example>
            此处演示批量写入的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="WriteExample2" title="Write示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.WriteCoil(System.String,System.Boolean)">
            <summary>
            写一个线圈信息，指定是否通断
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.WriteCoil(System.String,System.Boolean[])">
            <summary>
            批量写入线圈信息，指定是否通断
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.Write(System.String,System.Boolean[])">
            <summary>
            向寄存器中写入bool数组，返回值说明，比如你写入M100,那么data[0]对应M100.0
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，长度为8的倍数</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusRtu.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.ModBus.ModBusState">
            <summary>
            ModBus的异步状态信息
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModBusState.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:Communication.ModBus.ModBusState.ConnectTime">
            <summary>
            连接的时间
            </summary>
        </member>
        <member name="P:Communication.ModBus.ModBusState.IpEndPoint">
            <summary>
            远端的地址
            </summary>
        </member>
        <member name="P:Communication.ModBus.ModBusState.IpAddress">
            <summary>
            远端的Ip地址
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModBusState.WorkSocket">
            <summary>
            工作套接字
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModBusState.HeadByte">
            <summary>
            消息头的缓存
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModBusState.HeadByteReceivedLength">
            <summary>
            消息头的接收长度
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModBusState.Content">
            <summary>
            内容数据缓存
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModBusState.ContentReceivedLength">
            <summary>
            内容数据接收长度
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModBusState.hybirdLock">
            <summary>
            回发信息的同步锁
            </summary>
        </member>
        <member name="F:Communication.ModBus.ModBusState.isSocketOffline">
            <summary>
            指示客户端是否下线，已经下线则为1
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModBusState.IsModbusOffline">
            <summary>
            判断当前的客户端是否已经下线，下线成功的话，就返回True
            </summary>
            <returns></returns>
        </member>
        <member name="M:Communication.ModBus.ModBusState.Clear">
            <summary>
            清除原先的接收状态
            </summary>
        </member>
        <member name="T:Communication.ModBus.ModbusTcpNet">
            <summary>
            Modbus-Tcp协议的客户端通讯类，方便的和服务器进行数据交互
            </summary>
            <remarks>
            本客户端支持的标准的modbus-tcp协议，内置的消息号会进行自增，地址格式采用富文本表示形式
            <note type="important">
            地址共可以携带3个信息，最完整的表示方式"s=2;x=3;100"，对应的modbus报文是 02 03 00 64 00 01 的前四个字节，站号，功能码，起始地址，下面举例
            <list type="definition">
            <item>
                <term>读取线圈</term>
                <description>ReadCoil("100")表示读取线圈100的值，ReadCoil("s=2;100")表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
                <term>读取离散输入</term>
                <description>ReadDiscrete("100")表示读取离散输入100的值，ReadDiscrete("s=2;100")表示读取站号为2，离散地址为100的值</description>
            </item>
            <item>
                <term>读取寄存器</term>
                <description>ReadInt16("100")表示读取寄存器100的值，ReadInt16("s=2;100")表示读取站号为2，寄存器100的值</description>
            </item>
            <item>
                <term>读取输入寄存器</term>
                <description>ReadInt16("x=4;100")表示读取输入寄存器100的值，ReadInt16("s=2;x=4;100")表示读取站号为2，输入寄存器100的值</description>
            </item>
            </list>
            对于写入来说也是一致的
            <list type="definition">
            <item>
                <term>写入线圈</term>
                <description>WriteCoil("100",true)表示读取线圈100的值，WriteCoil("s=2;100",true)表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
                <term>写入寄存器</term>
                <description>Write("100",(short)123)表示写寄存器100的值123，Write("s=2;100",(short)123)表示写入站号为2，寄存器100的值123</description>
            </item>
            </list>
            </note>
            </remarks>
            <example>
            基本的用法请参照下面的代码示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="Example1" title="Modbus示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.#ctor">
            <summary>
            实例化一个MOdbus-Tcp协议的客户端对象
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpNet.AddressStartWithZero">
            <summary>
            获取或设置起始的地址是否从0开始，默认为True
            </summary>
            <remarks>
            <note type="warning">因为有些设备的起始地址是从1开始的，就要设置本属性为<c>True</c></note>
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpNet.Station">
            <summary>
            获取或者重新修改服务器的默认站号信息，当然，你可以再读写的时候动态指定，参见备注
            </summary>
            <remarks>
            当你调用 ReadCoil("100") 时，对应的站号就是本属性的值，当你调用 ReadCoil("s=2;100") 时，就忽略本属性的值，读写寄存器的时候同理
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpNet.DataFormat">
            <summary>
            获取或设置数据解析的格式，默认ABCD，可选BADC，CDAB，DCBA格式
            </summary>
            <remarks>
            对于Int32,UInt32,float,double,Int64,UInt64类型来说，存在多地址的电脑情况，需要和服务器进行匹配
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpNet.IsStringReverse">
            <summary>
            字符串数据是否按照字来反转
            </summary>
            <remarks>
            字符串按照2个字节的排列进行颠倒，根据实际情况进行设置
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpNet.MessageId">
            <summary>
            获取modbus协议自增的消息号，你可以自定义消息的细节。
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildReadCoilCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取线圈的指令头
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildReadDiscreteCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取离散信息的指令头
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildReadRegisterCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取寄存器的指令头
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildReadRegisterCommand(Communication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            生成一个读取寄存器的指令头
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildWriteOneCoilCommand(System.String,System.Boolean)">
            <summary>
            生成一个写入单线圈的指令头
            </summary>
            <param name="address">地址</param>
            <param name="value">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildWriteOneRegisterCommand(System.String,System.Byte[])">
            <summary>
            生成一个写入单个寄存器的报文
            </summary>
            <param name="address">地址</param>
            <param name="values">长度</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildWriteCoilCommand(System.String,System.Boolean[])">
            <summary>
            生成批量写入单个线圈的报文信息
            </summary>
            <param name="address">地址</param>
            <param name="values">实际数据值</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.BuildWriteRegisterCommand(System.String,System.Byte[])">
            <summary>
            生成批量写入寄存器的报文信息
            </summary>
            <param name="address">地址</param>
            <param name="values">实际值</param>
            <returns>包含结果对象的报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.CheckModbusTcpResponse(System.Byte[])">
            <summary>
            检查当前的Modbus-Tcp响应是否是正确的
            </summary>
            <param name="send">发送的数据信息</param>
            <returns>带是否成功的结果数据</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.ReadModBusBase(System.Byte,System.String,System.UInt16)">
            <summary>
            读取服务器的数据，需要指定不同的功能码
            </summary>
            <param name="code">指令</param>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>带是否成功的结果数据</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.ReadModBusBase(Communication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            读取服务器的数据，需要指定不同的功能码
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>带是否成功的结果数据</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.ReadCoil(System.String)">
            <summary>
            读取线圈，需要指定起始地址
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)">
            <summary>
            批量的读取线圈，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)">
            <summary>
            读取输入线圈，需要指定起始地址
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)">
            <summary>
            批量的读取输入点，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)">
            <summary>
            从Modbus服务器批量读取寄存器的信息，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"，或者是带功能码格式x=3;1234</param>
            <param name="length">读取的数量</param>
            <returns>带有成功标志的字节信息</returns>
            <remarks>
            富地址格式，支持携带站号信息，功能码信息，具体参照类的示例代码
            </remarks>
            <example>
            此处演示批量读取的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Byte,System.Byte)">
            <summary>
            写一个寄存器数据
            </summary>
            <param name="address">起始地址</param>
            <param name="high">高位</param>
            <param name="low">地位</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Int16)">
            <summary>
            写一个寄存器数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.UInt16)">
            <summary>
            写一个寄存器数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到Modbus的寄存器上去，需要指定起始地址和数据内容
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="value">写入的数据，长度根据data的长度来指示</param>
            <returns>返回写入结果</returns>
            <remarks>
            富地址格式，支持携带站号信息，功能码信息，具体参照类的示例代码
            </remarks>
            <example>
            此处演示批量写入的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.WriteCoil(System.String,System.Boolean)">
            <summary>
            写一个线圈信息，指定是否通断
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.WriteCoil(System.String,System.Boolean[])">
            <summary>
            批量写线圈信息，指定是否通断
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])">
            <summary>
            向寄存器中写入bool数组，返回值说明，比如你写入M100,那么data[0]对应M100.0
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，长度为8的倍数</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpNet.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.ModBus.ModbusTcpServer">
            <summary>
            Modbus的虚拟服务器，同时支持Tcp和Rtu的机制，支持线圈，离散输入，寄存器和输入寄存器的读写操作，可以用来当做系统的数据交换池
            </summary>
            <remarks>
            可以基于本类实现一个功能复杂的modbus服务器，在传统的.NET版本里，还支持modbus-rtu指令的收发，.NET Standard版本服务器不支持rtu操作。服务器支持的数据池如下：
            <list type="number">
            <item>线圈，功能码对应01，05，15</item>
            <item>离散输入，功能码对应02</item>
            <item>寄存器，功能码对应03，06，16</item>
            <item>输入寄存器，功能码对应04，输入寄存器在服务器端可以实现读写的操作</item>
            </list>
            </remarks>
            <example>
            读写的地址格式为富文本地址，具体请参照下面的示例代码。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Modbus\ModbusTcpServer.cs" region="ModbusTcpServerExample" title="ModbusTcpServer示例" />
            </example>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.#ctor">
            <summary>
            实例化一个Modbus Tcp的服务器，支持数据读写操作
            </summary>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpServer.DataFormat">
            <summary>
            获取或设置数据解析的格式，默认ABCD，可选BADC，CDAB，DCBA格式
            </summary>
            <remarks>
            对于Int32,UInt32,float,double,Int64,UInt64类型来说，存在多地址的电脑情况，需要和服务器进行匹配
            </remarks>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpServer.IsStringReverse">
            <summary>
            字符串数据是否按照字来反转
            </summary>
        </member>
        <member name="P:Communication.ModBus.ModbusTcpServer.Station">
            <summary>
            获取或设置服务器的站号信息，对于rtu模式，只有站号对了，才会反馈回数据信息。默认为1。
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.SaveToBytes">
            <summary>
            将数据源的内容生成原始数据，等待缓存
            </summary>
            <returns>原始的数据内容</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.LoadFromBytes(System.Byte[])">
            <summary>
            从原始的数据复原数据
            </summary>
            <param name="content">原始的数据</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.ReadCoil(System.String)">
            <summary>
            读取地址的线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.ReadCoil(System.String,System.UInt16)">
            <summary>
            批量读取地址的线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="length">读取长度</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.WriteCoil(System.String,System.Boolean)">
            <summary>
            写入线圈的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.WriteCoil(System.String,System.Boolean[])">
            <summary>
            写入线圈数组的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.ReadDiscrete(System.String)">
            <summary>
            读取地址的离散线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.ReadDiscrete(System.String,System.UInt16)">
            <summary>
            批量读取地址的离散线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="length">读取长度</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.WriteDiscrete(System.String,System.Boolean)">
            <summary>
            写入离散线圈的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.WriteDiscrete(System.String,System.Boolean[])">
            <summary>
            写入离散线圈数组的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.Read(System.String,System.UInt16)">
            <summary>
            读取自定义的寄存器的值。按照字为单位
            </summary>
            <param name="address">起始地址，示例："100"，"x=4;100"</param>
            <param name="length">数据长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <returns>byte数组值</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.Write(System.String,System.Byte[])">
            <summary>
            写入自定义的数据到数据内存中去
            </summary>
            <param name="address">地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.Write(System.String,System.Byte,System.Byte)">
            <summary>
            写入寄存器数据，指定字节数据
            </summary>
            <param name="address">起始地址，示例："100"，如果是输入寄存器："x=4;100"</param>
            <param name="high">高位数据</param>
            <param name="low">地位数据</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端登录后，进行Ip信息的过滤，然后触发本方法，也就是说之后的客户端需要
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endPoint">终端节点</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.CreateExceptionBack(System.Byte[],System.Byte)">
            <summary>
            创建特殊的功能标识，然后返回该信息
            </summary>
            <param name="modbusCore">modbus核心报文</param>
            <param name="error">错误码</param>
            <returns>携带错误码的modbus报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.CreateReadBack(System.Byte[],System.Byte[])">
            <summary>
            创建返回消息
            </summary>
            <param name="modbusCore">modbus核心报文</param>
            <param name="content">返回的实际数据内容</param>
            <returns>携带内容的modbus报文</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.CreateWriteBack(System.Byte[])">
            <summary>
            创建写入成功的反馈信号
            </summary>
            <param name="modbus">modbus核心报文</param>
            <returns>携带成功写入的信息</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.AddSubcription(Communication.ModBus.ModBusMonitorAddress)">
            <summary>
            新增一个数据监视的任务，针对的是寄存器
            </summary>
            <param name="monitor">监视地址对象</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.RemoveSubcrption(Communication.ModBus.ModBusMonitorAddress)">
            <summary>
            移除一个数据监视的任务
            </summary>
            <param name="monitor"></param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.OnRegisterBeforWrite(System.UInt16,System.Int16,System.Int16)">
            <summary>
            在数据变更后，进行触发是否产生订阅
            </summary>
            <param name="address">数据地址</param>
            <param name="before">修改之前的数</param>
            <param name="after">修改之后的数</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.CheckModbusMessageLegal(System.Byte[])">
            <summary>
            检测当前的Modbus接收的指定是否是合法的
            </summary>
            <param name="buffer">缓存数据</param>
            <returns>是否合格</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.ReadFromModbusCore(System.Byte[])">
            <summary>
            Modbus核心数据交互方法，允许重写自己来实现，报文只剩下核心的Modbus信息，去除了MPAB报头信息
            </summary>
            <param name="modbusCore">核心的Modbus报文</param>
            <returns>进行数据交互之后的结果</returns>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.StartSerialPort(System.String)">
            <summary>
            使用默认的参数进行初始化串口，9600波特率，8位数据位，无奇偶校验，1位停止位
            </summary>
            <param name="com">串口信息</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.StartSerialPort(System.String,System.Int32)">
            <summary>
            使用默认的参数进行初始化串口，8位数据位，无奇偶校验，1位停止位
            </summary>
            <param name="com">串口信息</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.StartSerialPort(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            使用自定义的初始化方法初始化串口的参数
            </summary>
            <param name="inni">初始化信息的委托</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.CloseSerialPort">
            <summary>
            关闭串口
            </summary>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.SerialPort_DataReceived(System.Object,System.IO.Ports.SerialDataReceivedEventArgs)">
            <summary>
            接收到串口数据的时候触发
            </summary>
            <param name="sender">串口对象</param>
            <param name="e">消息</param>
        </member>
        <member name="M:Communication.ModBus.ModbusTcpServer.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.ModBus.MonitorAddress">
            <summary>
            监视使用的数据缓存
            </summary>
        </member>
        <member name="F:Communication.ModBus.MonitorAddress.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="F:Communication.ModBus.MonitorAddress.ValueOrigin">
            <summary>
            原有的值
            </summary>
        </member>
        <member name="F:Communication.ModBus.MonitorAddress.ValueNew">
            <summary>
            新的值
            </summary>
        </member>
        <member name="T:Communication.Profinet.AllenBradley.AllenBradleyHelper">
            <summary>
            AB PLC的辅助类，用来辅助生成基本的指令信息
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_DATA">
            <summary>
            CIP命令中的读取数据的服务
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_WRITE_DATA">
            <summary>
            CIP命令中的写数据的服务
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_FRAGMENT">
            <summary>
            CIP命令中的读片段的数据服务
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_WRITE_FRAGMENT">
            <summary>
            CIP命令中的写片段的数据服务
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_MULTIREAD_DATA">
            <summary>
            CIP命令中的对数据读取服务
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Bool">
            <summary>
            bool型数据，一个字节长度
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Byte">
            <summary>
            byte型数据，一个字节长度
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Word">
            <summary>
            整型，两个字节长度
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_DWord">
            <summary>
            长整型，四个字节长度
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Real">
            <summary>
            实数数据，四个字节长度
            </summary>
        </member>
        <member name="F:Communication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_BitArray">
            <summary>
            二进制数据内容
            </summary>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestHeader(System.UInt16,System.UInt32,System.Byte[])">
            <summary>
            将CommandSpecificData的命令，打包成可发送的数据指令
            </summary>
            <param name="command">实际的命令暗号</param>
            <param name="session">当前会话的id</param>
            <param name="commandSpecificData">CommandSpecificData命令</param>
            <returns>最终可发送的数据命令</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyHelper.PackRequsetRead(System.String,System.Int32)">
            <summary>
            打包生成一个请求读取数据的节点信息，CIP指令信息
            </summary>
            <param name="address">地址</param>
            <param name="length">指代数组的长度</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestWrite(System.String,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            根据指定的数据和类型，生成对应的数据
            </summary>
            <param name="address">地址信息</param>
            <param name="typeCode">数据类型</param>
            <param name="value">字节值</param>
            <param name="length">如果节点为数组，就是数组长度</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandSpecificData(System.Byte,System.Byte[][])">
            <summary>
            生成读取直接节点数据信息的内容
            </summary>
            <param name="slot">PLC所在的槽号</param>
            <param name="cips">cip指令内容</param>
            <returns>最终的指令值</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyHelper.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据解析
            </summary>
            <param name="response">PLC的反馈数据</param>
            <param name="isRead">是否是返回的操作</param>
            <returns>带有结果标识的最终数据</returns>
        </member>
        <member name="T:Communication.Profinet.AllenBradley.AllenBradleyNet">
            <summary>
            AB PLC Data communication class, support read and write PLC node data
            </summary>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.#ctor">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
            <param name="ipAddress">PLC IpAddress</param>
            <param name="port">PLC Port</param>
        </member>
        <member name="P:Communication.Profinet.AllenBradley.AllenBradleyNet.SessionHandle">
            <summary>
            The current session handle, which is determined by the PLC when communicating with the PLC handshake
            </summary>
        </member>
        <member name="P:Communication.Profinet.AllenBradley.AllenBradleyNet.Slot">
            <summary>
            Gets or sets the slot number information for the current plc, which should be set before connections
            </summary>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            After connecting the Allenbradley plc, a next step handshake protocol is required
            </summary>
            <param name="socket">socket after connectting sucessful</param>
            <returns>Success of initialization</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <summary>
            A next step handshake agreement is required before disconnecting the Allenbradley plc
            </summary>
            <param name="socket">socket befor connection close </param>
            <returns>Whether the disconnect operation was successful</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.BuildReadCommand(System.String[],System.Int32[])">
            <summary>
            Build a read command bytes
            </summary>
            <param name="address">the address of the tag name</param>
            <param name="length">Array information, if not arrays, is 1 </param>
            <returns>Message information that contains the result object </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.BuildReadCommand(System.String[])">
            <summary>
            Build a read command bytes
            </summary>
            <param name="address">The address of the tag name </param>
            <returns>Message information that contains the result object </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.BuildWriteCommand(System.String,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Create a written message instruction
            </summary>
            <param name="address">The address of the tag name </param>
            <param name="typeCode">Data type</param>
            <param name="data">Source Data </param>
            <param name="length">In the case of arrays, the length of the array </param>
            <returns>Message information that contains the result object</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String,System.UInt16)">
            <summary>
            读取数据信息，数据长度为读取的数组长度信息 -> Read data information, data length for read array length information
            </summary>
            <param name="address">节点的地址格式 -> Address format of the node</param>
            <param name="length">如果是数组，就为数组长度 -> In the case of arrays, the length of the array </param>
            <returns>带有结果对象的结果数据 -> Result data with result object </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[])">
            <summary>
            批量读取数据信息 -> Bulk read Data information
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result object </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[],System.Int32[])">
            <summary>
            批量读取数据信息，数据长度为读取的数组长度信息 -> Bulk read data information, data length for read array length information
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">如果是数组，就为数组长度 -> In the case of arrays, the length of the array </param>
            <returns>带有结果对象的结果数据 -> Result data with result object </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadBool(System.String)">
            <summary>
            读取单个的bool数据信息 -> Read a single BOOL data information
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadBoolArray(System.String)">
            <summary>
            批量读取的bool数组信息 -> Bulk read of bool array information
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadByte(System.String)">
            <summary>
            读取PLC的byte类型的数据 -> Read the byte type of PLC data
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取PLC的short类型的数组 -> Read an array of the short type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取PLC的ushort类型的数组 -> An array that reads the ushort type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取PLC的int类型的数组 -> An array that reads the int type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取PLC的uint类型的数组 -> An array that reads the UINT type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取PLC的float类型的数组 -> An array that reads the float type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取PLC的long类型的数组 -> An array that reads the long type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取PLC的ulong类型的数组 -> An array that reads the ULONG type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取PLC的double类型的数组 -> An array that reads the double type of the PLC
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">数组长度 -> Array length </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            使用指定的类型写入指定的节点数据 -> Writes the specified node data with the specified type
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="typeCode">类型代码，详细参见<see cref="T:Communication.Profinet.AllenBradley.AllenBradleyHelper"/>上的常用字段 ->  Type code, see the commonly used Fields section on the <see cref= "T:Communication.Profinet.AllenBradley.AllenBradleyHelper"/> in detail</param>
            <param name="value">实际的数据值 -> The actual data value </param>
            <param name="length">如果节点是数组，就是数组长度 -> If the node is an array, it is the array length </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int16[])">
            <summary>
            向PLC中写入short数组，返回是否写入成功 -> Writes a short array to the PLC to return whether the write was successful
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="values">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt16[])">
            <summary>
            向PLC中写入ushort数组，返回是否写入成功 -> Writes an array of ushort to the PLC to return whether the write was successful
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="values">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int32[])">
            <summary>
            向PLC中写入int数组，返回是否写入成功 -> Writes an int array to the PLC to return whether the write was successful
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="values">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt32[])">
            <summary>
            Writes an array of UINT to the PLC to return whether the write was successful
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="values">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Single[])">
            <summary>
            Writes an array of float to the PLC to return whether the write was successful
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="values">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.String)">
            <summary>
            向PLC中写入string数据，返回是否写入成功，该string类型是针对PLC的DINT类型，长度自动扩充到8
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="value">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Boolean)">
            <summary>
            向PLC中写入bool数据，返回是否写入成功
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="value">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回是否写入成功
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="value">实际数据 -> Actual data </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.RegisterSessionHandle">
            <summary>
            向PLC注册会话ID的报文 ->
            Register a message with the PLC for the session ID
            </summary>
            <returns>报文信息 -> Message information </returns>
        </member>
        <member name="M:Communication.Profinet.AllenBradley.AllenBradleyNet.UnRegisterSessionHandle">
            <summary>
            获取卸载一个已注册的会话的报文 ->
            Get a message to uninstall a registered session
            </summary>
            <returns>字节报文信息 -> BYTE message information </returns>
        </member>
        <member name="T:Communication.Profinet.Keyence.KeyenceDataType">
            <summary>
            Keyence PLC的数据类型，此处包含了几个常用的类型
            </summary>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceDataType.#ctor(System.Byte,System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:Communication.Profinet.Keyence.KeyenceDataType.DataCode">
            <summary>
            类型的代号值
            </summary>
        </member>
        <member name="P:Communication.Profinet.Keyence.KeyenceDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:Communication.Profinet.Keyence.KeyenceDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:Communication.Profinet.Keyence.KeyenceDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.M">
            <summary>
            内部辅助继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.SM">
            <summary>
            控制继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.SD">
            <summary>
            控制存储器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.D">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.ZR">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.W">
            <summary>
            链路寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Keyence.KeyenceDataType.CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="T:Communication.Profinet.Keyence.KeyenceMcAsciiNet">
            <summary>
            基恩士PLC的数据读写类
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>KV-7500/7300</term>
                <term>KV-5500/5000/3000</term>
                <term>KV Nano</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>B0000~B7FFF</term>
                <term>B0000~B3FFF</term>
                <term>B0000~B1FFF</term>
              </item>
              <item>
                <term>内部辅助继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>MR00000~MR99915</term>
                <term>MR00000~MR99915</term>
                <term>MR00000～MR59915</term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>LR00000~LR99915</term>
                <term>LR00000~LR99915</term>
                <term>LR00000～LR19915</term>
              </item>
              <item>
                <term>控制继电器</term>
                <term>SM</term>
                <term>SM100,SM200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>CR0000~CR7915</term>
                <term>CR0000~CR3915</term>
                <term>CR0000～CR8915</term>
              </item>
              <item>
                <term>控制存储器</term>
                <term>SD</term>
                <term>SD100,SD200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>CM0000~CM5999</term>
                <term>CM0000~CM5999</term>
                <term>CM0000～CM8999</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>DM00000~DM65534</term>
                <term>DM00000~DM65534</term>
                <term>DM00000～DM32767</term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>D</term>
                <term>D100000~D165534</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>EM00000~EM65534</term>
                <term>EM00000~EM65534</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>FM00000~FM32767</term>
                <term>FM00000~FM32767</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>ZF000000~ZF524287</term>
                <term>ZF000000~ZF131071</term>
                <term>×</term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>W0000~7FFF</term>
                <term>W0000~3FFF</term>
                <term>W0000~3FFF</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcAsciiNet.#ctor">
            <summary>
            实例化基恩士的Qna兼容3E帧协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcAsciiNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个基恩士的Qna兼容3E帧协议的通讯对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcAsciiNet.McAnalysisAddress(System.String)">
            <summary>
            分析地址的方法，允许派生类里进行重写操作
            </summary>
            <param name="address">地址信息</param>
            <returns>解析后的数据信息</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcAsciiNet.ToString">
            <summary>
            获取当前对象的字符串标识形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Profinet.Keyence.KeyenceMcNet">
            <summary>
            基恩士PLC的数据通信类
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>KV-7500/7300</term>
                <term>KV-5500/5000/3000</term>
                <term>KV Nano</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>B0000~B7FFF</term>
                <term>B0000~B3FFF</term>
                <term>B0000~B1FFF</term>
              </item>
              <item>
                <term>内部辅助继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>MR00000~MR99915</term>
                <term>MR00000~MR99915</term>
                <term>MR00000～MR59915</term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>LR00000~LR99915</term>
                <term>LR00000~LR99915</term>
                <term>LR00000～LR19915</term>
              </item>
              <item>
                <term>控制继电器</term>
                <term>SM</term>
                <term>SM100,SM200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>CR0000~CR7915</term>
                <term>CR0000~CR3915</term>
                <term>CR0000～CR8915</term>
              </item>
              <item>
                <term>控制存储器</term>
                <term>SD</term>
                <term>SD100,SD200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>CM0000~CM5999</term>
                <term>CM0000~CM5999</term>
                <term>CM0000～CM8999</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>DM00000~DM65534</term>
                <term>DM00000~DM65534</term>
                <term>DM00000～DM32767</term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>D</term>
                <term>D100000~D165534</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>EM00000~EM65534</term>
                <term>EM00000~EM65534</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>FM00000~FM32767</term>
                <term>FM00000~FM32767</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>ZF000000~ZF524287</term>
                <term>ZF000000~ZF131071</term>
                <term>×</term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>W0000~7FFF</term>
                <term>W0000~3FFF</term>
                <term>W0000~3FFF</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcNet.#ctor">
            <summary>
            实例化基恩士的Qna兼容3E帧协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个基恩士的Qna兼容3E帧协议的通讯对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcNet.McAnalysisAddress(System.String)">
            <summary>
            分析地址的方法，允许派生类里进行重写操作
            </summary>
            <param name="address">地址信息</param>
            <returns>解析后的数据信息</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceMcNet.ToString">
            <summary>
            获取当前对象的字符串标识形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Profinet.Keyence.KeyenceNanoByteTransform">
             <summary>
             基恩士Nano串口Bytes数据转换规则
             </summary>  
            以数据格式“位”读取R100~R103时, []表示空格，发送指令如下：
            ACSII码：   R       D      S        []       R      1        0        0      []     4       /r
            16进制码：0x52,0x44,0x53,0x20,0x52,0x31,0x30,0x30,0x20,0x34,0x0d
            响应如下
            ACSII码：   1        []      0        []       1       []        0     /r      /n
            16进制码：0x31,0x20,0x30,0x20,0x31,0x20,0x30,0x0d,0x0a 
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:Communication.Profinet.Keyence.KeyenceNanoByteTransform.DataFormat">
            <summary>
            数据格式
            </summary>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.BytesToStringArray(System.Byte[])">
            <summary>
            Nano响应的Bytes转换为string数组
            </summary>
            <param name="buffer">缓存数据 </param>
            <returns>字符串数组 </returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransBool(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取出bool结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <returns>bool对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransBool(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取出bool数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <param name="length">bool长度</param>
            <returns>bool数组</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取byte结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>byte对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取byte数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>byte数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取short结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>short对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取short数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>short数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransUInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ushort结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ushort对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ushort数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ushort数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取int结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>int对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取int数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>int数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransUInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取uint结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>uint对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取uint数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>uint数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取long结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>long对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取long数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>long数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransUInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ulong结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ulong对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ulong数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ulong数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransSingle(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取float结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>float对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取float数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>float数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransDouble(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取double结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>double对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取double数组结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>double数组对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            从缓存中提取string结果，使用指定的编码
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">byte数组长度</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Boolean)">
            <summary>
            bool变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Boolean[])">
            <summary>
            bool数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Byte)">
            <summary>
            byte变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Int16)">
            <summary>
            short变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Int16[])">
            <summary>
            short数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.UInt16)">
            <summary>
            ushort变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.UInt16[])">
            <summary>
            ushort数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Int32)">
            <summary>
            int变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Int32[])">
            <summary>
            int数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.UInt32)">
            <summary>
            uint变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.UInt32[])">
            <summary>
            uint数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Int64)">
            <summary>
            long变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Int64[])">
            <summary>
            long数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.UInt64)">
            <summary>
            ulong变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.UInt64[])">
            <summary>
            ulong数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Single)">
            <summary>
            float变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Single[])">
            <summary>
            float数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Double)">
            <summary>
            double变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.Double[])">
            <summary>
            double数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.TransByte(System.String,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="T:Communication.Profinet.Keyence.KeyenceNanoByteTransform.Trans`1">
            <summary>
            字节转换类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoByteTransform.Trans`1.ToBytes(`0[],System.String)">
            <summary>
            泛型对象转换为字节数组
            </summary>
            <param name="values"></param>
            <param name="dataFormat"></param>
            <returns></returns>
        </member>
        <member name="T:Communication.Profinet.Keyence.KeyenceNanoSerial">
            <summary>
            基恩士KV上位链路串口通信的对象,适用于Nano系列串口数据,以及L20V通信模块
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>KV-7500/7300</term>
                <term>KV-5500/5000/3000</term>
                <term>KV Nano</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>内部辅助继电器</term>
                <term>MR</term>
                <term>MR100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>MR00000~MR99915</term>
                <term>MR00000~MR99915</term>
                <term>MR00000～MR59915</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>DM</term>
                <term>DM100,DM200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>DM00000~DM65534</term>
                <term>DM00000~DM65534</term>
                <term>DM00000～DM32767</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.#ctor">
            <summary>
            实例化基恩士的串口协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.InitializationOnOpen">
            <summary>
            初始化后建立通讯连接
            </summary>
            <returns>是否初始化成功</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.CheckPlcReadResponse(System.Byte[])">
            <summary>
            校验读取返回数据状态
            </summary>
            <param name="ack"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.CheckPlcWriteResponse(System.Byte[])">
            <summary>
            校验写入返回数据状态
            </summary>
            <param name="ack"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            建立读取指令
            </summary>
            <param name="address">软元件地址</param>
            <param name="length">读取长度</param>
            <returns>是否建立成功</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadInt16(System.String)">
            <summary>
            读取设备的short类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取设备的short类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadUInt16(System.String)">
            <summary>
            读取设备的ushort数据类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取设备的ushort类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadInt32(System.String)">
            <summary>
            读取设备的int类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取设备的int类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadUInt32(System.String)">
            <summary>
            读取设备的uint类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取设备的uint类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.Read(System.String,System.UInt16)">
            <summary>
            从PLC中读取想要的数据，返回读取结果
            </summary>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadBool(System.String,System.UInt16)">
            <summary>
            成批读取Bool值
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ReadBool(System.String)">
            <summary>
            读取单个Bool值
            </summary>
            <param name="address">地址信息</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Byte[])">
            <summary>
            写入转换后的数据值
            </summary>
            <param name="address">软元件地址</param>
            <param name="value">转换后的Byte[]数据</param>
            <returns>是否成功写入的结果</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Boolean)">
            <summary>
             写入位数据的通断，支持的类型参考文档说明
            </summary>
            <param name="address">地址信息</param>
            <param name="value">是否为通</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            建立写入指令
            </summary>
            <param name="address">软元件地址</param>
            <param name="value">转换后的数据</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.ExtractActualData(System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼操作
            </summary>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.KvCalculateWordStartAddress(System.String)">
            <summary>
            返回读取的地址及长度信息
            </summary>
            <param name="address">读取的地址信息</param>
            <returns>带起始地址的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Keyence.KeyenceNanoSerial.KvAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的Keyence地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="T:Communication.Profinet.LSIS.LSCpuInfo">
            <summary>
            It is determined to be the XGK/I/R series through a reserved area
            </summary>
        </member>
        <member name="T:Communication.Profinet.LSIS.LSisServer">
            <summary>
            LSisServer
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.#ctor">
            <summary>
            LSisServer  
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.Read(System.String,System.UInt16)">
            <summary>
            读取自定义的寄存器的值
            </summary>
            <param name="address">起始地址，示例："I100"，"M100"</param>
            <param name="length">数据长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <returns>byte数组值</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.Write(System.String,System.Byte[])">
            <summary>
            写入自定义的数据到数据内存中去
            </summary>
            <param name="address">地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.ReadByte(System.String)">
            <summary>
            读取指定地址的字节数据
            </summary>
            <param name="address">西门子的地址信息</param>
            <returns>带有成功标志的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.Write(System.String,System.Byte)">
            <summary>
            将byte数据信息写入到指定的地址当中
            </summary>
            <param name="address">西门子的地址信息</param>
            <param name="value">字节数据信息</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.ReadBool(System.String)">
            <summary>
            读取指定地址的bool数据对象
            </summary>
            <param name="address">西门子的地址信息</param>
            <returns>带有成功标志的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.Write(System.String,System.Boolean)">
            <summary>
            往指定的地址里写入bool数据对象
            </summary>
            <param name="address">西门子的地址信息</param>
            <param name="value">值</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端登录后，进行Ip信息的过滤，然后触发本方法，也就是说之后的客户端需要
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endPoint">终端节点</param>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.LoadFromBytes(System.Byte[])">
            <summary>
            从字节数据加载数据信息
            </summary>
            <param name="content">字节数据</param>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.SaveToBytes">
            <summary>
            将数据信息存储到字节数组去
            </summary>
            <returns>所有的内容</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.StartSerialPort(System.String)">
            <summary>
            使用默认的参数进行初始化串口，9600波特率，8位数据位，无奇偶校验，1位停止位
            </summary>
            <param name="com">串口信息</param>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.StartSerialPort(System.String,System.Int32)">
            <summary>
            使用默认的参数进行初始化串口，8位数据位，无奇偶校验，1位停止位
            </summary>
            <param name="com">串口信息</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.StartSerialPort(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            使用自定义的初始化方法初始化串口的参数
            </summary>
            <param name="inni">初始化信息的委托</param>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.CloseSerialPort">
            <summary>
            关闭串口
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.SerialPort_DataReceived(System.Object,System.IO.Ports.SerialDataReceivedEventArgs)">
            <summary>
            接收到串口数据的时候触发
            </summary>
            <param name="sender">串口对象</param>
            <param name="e">消息</param>
        </member>
        <member name="M:Communication.Profinet.LSIS.LSisServer.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Profinet.LSIS.XGBCnet">
            <summary>
            XGB Cnet I/F module supports Serial Port.
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="P:Communication.Profinet.LSIS.XGBCnet.Station">
            <summary>
            PLC Station No.
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.ReadByte(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>result</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.Write(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.WriteCoil(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.Read(System.String,System.UInt16)">
            <summary>
            Read Bytes From PLC, you should specify the length
            </summary>
            <param name="address">the address of the data</param>
            <param name="length">the length of the data, in byte unit</param>
            <returns>result contains whether success.</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.Write(System.String,System.Byte[])">
            <summary>
            Write Data into plc, , you should specify the address
            </summary>
            <param name="address">the address of the data</param>
            <param name="value">source data</param>
            <returns>result contains whether success.</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.ToString">
            <summary>
            Returns a string representing the current object
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.BuildReadByteCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            reading address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="length">read length</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.BuildReadOneCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            One reading address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: MX100, DW100, TW100</param>
            <param name="length">read length</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.BuildWriteByteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            write data to address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="value">source value</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBCnet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            Extract actual data form plc response
            </summary>
            <param name="response">response data</param>
            <param name="isRead">read</param>
            <returns>result</returns>
        </member>
        <member name="T:Communication.Profinet.LSIS.XGBFastEnet">
            <summary>
            XGB Fast Enet I/F module supports open Ethernet. It provides network configuration that is to connect LSIS and other company PLC, PC on network
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a object by ipaddress and port
            </summary>
            <param name="ipAddress">the ip address of the plc</param>
            <param name="port">the port of the plc, default is 2004</param>
        </member>
        <member name="P:Communication.Profinet.LSIS.XGBFastEnet.CpuType">
            <summary>
            CPU TYPE
            </summary>
        </member>
        <member name="P:Communication.Profinet.LSIS.XGBFastEnet.CpuError">
            <summary>
            Cpu is error
            </summary>
        </member>
        <member name="P:Communication.Profinet.LSIS.XGBFastEnet.LSCpuStatus">
            <summary>
            RUN, STOP, ERROR, DEBUG
            </summary>
        </member>
        <member name="P:Communication.Profinet.LSIS.XGBFastEnet.BaseNo">
            <summary>
            FEnet I/F module’s Base No.
            </summary>
        </member>
        <member name="P:Communication.Profinet.LSIS.XGBFastEnet.SlotNo">
            <summary>
            FEnet I/F module’s Slot No.
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.Read(System.String,System.UInt16)">
            <summary>
            Read Bytes from plc, you should specify address
            </summary>
            <param name="address">Start Address, for example: M100</param>
            <param name="length">Array of data Lengths</param>
            <returns>Whether to read the successful result object</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <remarks>
            </remarks>
            <example>
            </example>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte[])">
            <summary>
            Write bytes to plc, you should specify bytes, can't be null
            </summary>
            <param name="address">Start Address, for example: M100</param>
            <param name="value">source dara</param>
            <returns>Whether to write the successful result object</returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.ReadByte(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>result</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.WriteCoil(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Communication.Profinet.LSIS.XGBFastEnet.LsDataType">
            <summary>
            LSDataType to Address
            </summary>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.AnalysisAddress(System.String,System.Boolean)">
            <summary>
            AnalysisAddress
            </summary>
            <param name="address"></param>
            <param name="isRead"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.AnalysisAddressDataType(System.String)">
            <summary>
            Get DataType to Address
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.ExtractActualData(System.Byte[])">
            <summary>
            Returns true data content, supports read and write returns
            </summary>
            <param name="response">response data</param>
            <returns>real data</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.GetErrorDesciption(System.Byte)">
            <summary>
            get the description of the error code meanning
            </summary>
            <param name="code">code value</param>
            <returns>string information</returns>
        </member>
        <member name="M:Communication.Profinet.LSIS.XGBFastEnet.ToString">
            <summary>
            Returns a string representing the current object
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecA1EDataType">
            <summary>
            三菱PLC的数据类型，此处包含了几个常用的类型
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1EDataType.#ctor(System.Byte[],System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecA1EDataType.DataCode">
            <summary>
            类型的代号值（软元件代码，用于区分软元件类型，如：D，R）
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecA1EDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecA1EDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecA1EDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecA1EDataType.X">
            <summary>
            X输入寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecA1EDataType.Y">
            <summary>
            Y输出寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecA1EDataType.M">
            <summary>
            M中间寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecA1EDataType.S">
            <summary>
            S状态寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecA1EDataType.D">
            <summary>
            D数据寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecA1EDataType.R">
            <summary>
            R文件寄存器
            </summary>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecA1ENet">
            <summary>
            三菱PLC通讯协议，采用A兼容1E帧协议实现，使用二进制码通讯，请根据实际型号来进行选取
            </summary>
            <remarks>
            本类适用于的PLC列表
            <list type="number">
            <item>FX3U(C) PLC   测试人sandy_liao</item>
            </list>
            数据地址支持的格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            <note type="important">本通讯类由CKernal推送，感谢</note>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.#ctor">
            <summary>
            实例化三菱的A兼容1E帧协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个三菱的A兼容1E帧协议的通讯对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecA1ENet.PLCNumber">
            <summary>
            PLC编号
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.Read(System.String,System.UInt16)">
            <summary>
            从三菱PLC中读取想要的数据，返回读取结果
            </summary>
            <param name="address">读取地址，格式为"M100","D100","W1A0"</param>
            <param name="length">读取的数据长度，字最大值960，位最大值7168</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型
            </summary>
            <param name="address">初始地址</param>
            <param name="value">原始的字节数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Boolean)">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入M100,values[0]对应M100
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="value">要写入的实际数据，长度为8的倍数</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入M100,values[0]对应M100
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.ToString">
            <summary>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.BuildReadCommand(System.String,System.UInt16,System.Boolean,System.Byte)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">指示是否按照位成批的读出</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.BuildWriteCommand(System.String,System.Byte[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA1ENet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecA3CNet1">
            <summary>
            基于Qna 兼容3C帧的格式一的通讯，具体的地址需要参照三菱的基本地址
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
               <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>边沿继电器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>ZR文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR2A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的触点</term>
                <term>SS</term>
                <term>SS100,SS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的线圈</term>
                <term>SC</term>
                <term>SC100,SC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的当前值</term>
                <term>SN</term>
                <term>SN100,SN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前值</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.#ctor">
            <summary>
            实例化默认的构造方法
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecA3CNet1.Station">
            <summary>
            PLC的站号信息
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.ReadBool(System.String)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.Write(System.String,System.Boolean)">
            <summary>
            批量写入bool类型的数值，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.Write(System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.RemoteRun">
            <summary>
            远程Run操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.RemoteStop">
            <summary>
            远程Stop操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.ReadPlcType">
            <summary>
            读取PLC的型号信息
            </summary>
            <returns>返回型号的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecA3CNet1.PackCommand(System.Byte[],System.Byte)">
            <summary>
            将命令进行打包传送
            </summary>
            <param name="mcCommand">mc协议的命令</param>
            <param name="station">PLC的站号</param>
            <returns>最终的原始报文信息</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecFxLinks">
            <summary>
            三菱PLC的计算机链接协议，适用的PLC型号参考备注
            </summary>
            <remarks>
            支持的通讯的系列如下参考
            <list type="table">
                <listheader>
                    <term>系列</term>
                    <term>是否支持</term>
                    <term>备注</term>
                </listheader>
                <item>
                    <description>FX3UC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3U系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3GC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3G系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3S系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2NC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2N系列</description>
                    <description>部分支持(v1.06+)</description>
                    <description>通过监控D8001来确认版本号</description>
                </item>
                <item>
                    <description>FX1NC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1N系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1S系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0N系列</description>
                    <description>部分支持(v1.20+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0S系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2C系列</description>
                    <description>部分支持(v3.30+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2(FX)系列</description>
                    <description>部分支持(v3.30+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
            </list>
            数据地址支持的格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.#ctor">
            <summary>
            实例化默认的构造方法
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecFxLinks.Station">
            <summary>
            PLC的站号信息
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecFxLinks.WaittingTime">
            <summary>
            报文等待时间，单位10ms，设置范围为0-15
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecFxLinks.SumCheck">
            <summary>
            是否启动和校验
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.ReadBool(System.String)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.Write(System.String,System.Boolean)">
            <summary>
            批量写入bool类型的数值，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.Write(System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.StartPLC">
            <summary>
            启动PLC
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.StopPLC">
            <summary>
            停止PLC
            </summary>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.FxAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的三菱地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.CalculateAcc(System.String)">
            <summary>
            计算指令的和校验码
            </summary>
            <param name="data">指令</param>
            <returns>校验之后的信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean,System.Boolean,System.Byte)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数
            </summary>
            <param name="station">PLCd的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBool">是否位读取</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean[],System.Boolean,System.Byte)">
            <summary>
            创建一条别入bool数据的指令信息，需要指定一些参数
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.BuildWriteByteCommand(System.Byte,System.String,System.Byte[],System.Boolean,System.Byte)">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.BuildStart(System.Byte,System.Boolean,System.Byte)">
            <summary>
            创建启动PLC的报文信息
            </summary>
            <param name="station">站号信息</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxLinks.BuildStop(System.Byte,System.Boolean,System.Byte)">
            <summary>
            创建启动PLC的报文信息
            </summary>
            <param name="station">站号信息</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecFxSerial">
            <summary>
            三菱的串口通信的对象，适用于读取FX系列的串口数据，支持的类型参考文档说明
            </summary>
            <remarks>
            字读写地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>D0-D511,D8000-D8255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>TN</term>
                <term>TN10,TN20</term>
                <term>TN0-TN255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>CN</term>
                <term>CN10,CN20</term>
                <term>CN0-CN199,CN200-CN255</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            位地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>M0-M1023,M8000-M8255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X1,X20</term>
                <term>X0-X177</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>Y0-Y177</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>S0-S999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器触点</term>
                <term>TS</term>
                <term>TS10,TS20</term>
                <term>TS0-TS255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器线圈</term>
                <term>TC</term>
                <term>TC10,TC20</term>
                <term>TC0-TC255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器触点</term>
                <term>CS</term>
                <term>CS10,CS20</term>
                <term>CS0-CS255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器线圈</term>
                <term>CC</term>
                <term>CC10,CC20</term>
                <term>CC0-CC255</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="Usage" title="简单的使用" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.#ctor">
            <summary>
            实例化三菱的串口协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.Read(System.String,System.UInt16)">
            <summary>
            从三菱PLC中读取想要的数据，返回读取结果
            </summary>
            <param name="address">读取地址，，支持的类型参考文档说明</param>
            <param name="length">读取的数据长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.ReadBool(System.String,System.UInt16)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果，该读取地址最好从0，16，32...等开始读取，这样可以读取比较长得数据数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
             <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadBool" title="Bool类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.ReadBool(System.String)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>参照 <see cref="M:Communication.Profinet.Melsec.MelsecFxSerial.ReadBool(System.String,System.UInt16)"/> 方法 </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.Write(System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型
            </summary>
            <param name="address">初始地址，支持的类型参考文档说明</param>
            <param name="value">原始的字节数据</param>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，写入如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample2" title="Write示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample1" title="Write示例" />
            </example>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.Write(System.String,System.Boolean)">
            <summary>
            强制写入位数据的通断，支持的类型参考文档说明
            </summary>
            <param name="address">地址信息</param>
            <param name="value">是否为通</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.ToString">
            <summary>
            获取当前对象的字符串标识形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.BuildWriteBoolPacket(System.String,System.Boolean)">
            <summary>
            生成位写入的数据报文信息，该报文可直接用于发送串口给PLC
            </summary>
            <param name="address">地址信息，每个地址存在一定的范围，需要谨慎传入数据。举例：M10,S10,X5,Y10,C10,T10</param>
            <param name="value"><c>True</c>或是<c>False</c></param>
            <returns>带报文信息的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.BuildReadWordCommand(System.String,System.UInt16)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.BuildReadBoolCommand(System.String,System.UInt16)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">bool数组长度</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.BuildWriteWordCommand(System.String,System.Byte[])">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">实际的数据信息</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.ExtractActualData(System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼操作
            </summary>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.ExtractActualBoolData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从PLC反馈的数据进行提炼bool数组操作
            </summary>
            <param name="response">PLC反馈的真实数据</param>
            <param name="start">起始提取的点信息</param>
            <param name="length">bool数组的长度</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.FxAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的三菱地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.FxCalculateWordStartAddress(System.String)">
            <summary>
            返回读取的地址及长度信息
            </summary>
            <param name="address">读取的地址信息</param>
            <returns>带起始地址的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecFxSerial.FxCalculateBoolStartAddress(System.String)">
            <summary>
            返回读取的地址及长度信息，以及当前的偏置信息
            </summary><param name="address">读取的地址信息</param>
            <returns>带起始地址的结果对象</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecHelper">
            <summary>
            所有三菱通讯类的通用辅助工具类，包含了一些通用的静态方法，可以使用本类来获取一些原始的报文信息。详细的操作参见例子
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.McA1EAnalysisAddress(System.String)">
            <summary>
            解析A1E协议数据地址
            </summary>
            <param name="address">数据地址</param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.McAnalysisAddress(System.String)">
            <summary>
            解析数据地址
            </summary>
            <param name="address">数据地址</param>
            <returns>解析值</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.KeyenceAnalysisAddress(System.String)">
            <summary>
            基恩士解析数据地址
            </summary>
            <param name="address">数据地址</param>
            <returns>解析值</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.GetPanasonicAddress(System.String)">
            <summary>
            计算松下的MC协议的偏移地址的机制
            </summary>
            <param name="address">字符串形式的地址</param>
            <returns>实际的偏移地址</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.PanasonicAnalysisAddress(System.String)">
            <summary>
            松下的解析数据地址
            </summary>
            <param name="address">数据地址</param>
            <returns>解析值</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildReadMcCoreCommand(System.String,System.UInt16,System.Boolean,System.Func{System.String,Communication.OperateResult{Communication.Profinet.Melsec.MelsecMcDataType,System.Int32}})">
            <summary>
            从地址，长度，是否位读取进行创建读取的MC的核心报文
            </summary>
            <param name="address">三菱的地址信息，具体格式参照<seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的注释说明</param>
            <param name="length">读取的长度信息</param>
            <param name="isBit">是否进行了位读取操作</param>
            <param name="analysisAddress">对地址分析的委托方法</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildAsciiReadMcCoreCommand(System.String,System.UInt16,System.Boolean,System.Func{System.String,Communication.OperateResult{Communication.Profinet.Melsec.MelsecMcDataType,System.Int32}})">
            <summary>
            从地址，长度，是否位读取进行创建读取Ascii格式的MC的核心报文
            </summary>
            <param name="address">三菱的地址信息，具体格式参照<seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的注释说明</param>
            <param name="length">读取的长度信息</param>
            <param name="isBit">是否进行了位读取操作</param>
            <param name="analysisAddress">对地址分析的委托方法</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildWriteWordCoreCommand(System.String,System.Byte[],System.Func{System.String,Communication.OperateResult{Communication.Profinet.Melsec.MelsecMcDataType,System.Int32}})">
            <summary>
            以字为单位，创建数据写入的核心报文
            </summary>
            <param name="address">三菱的地址信息，具体格式参照<seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的注释说明</param>
            <param name="value">实际的原始数据信息</param>
            <param name="analysisAddress">对地址分析的委托方法</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildAsciiWriteWordCoreCommand(System.String,System.Byte[],System.Func{System.String,Communication.OperateResult{Communication.Profinet.Melsec.MelsecMcDataType,System.Int32}})">
            <summary>
            以字为单位，创建ASCII数据写入的核心报文
            </summary>
            <param name="address">三菱的地址信息，具体格式参照<seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的注释说明</param>
            <param name="value">实际的原始数据信息</param>
            <param name="analysisAddress">对地址分析的委托方法</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildWriteBitCoreCommand(System.String,System.Boolean[],System.Func{System.String,Communication.OperateResult{Communication.Profinet.Melsec.MelsecMcDataType,System.Int32}})">
            <summary>
            以位为单位，创建数据写入的核心报文
            </summary>
            <param name="address">三菱的地址信息，具体格式参照<seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的注释说明</param>
            <param name="value">原始的bool数组数据</param>
            <param name="analysisAddress">对地址分析的委托方法</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildAsciiWriteBitCoreCommand(System.String,System.Boolean[],System.Func{System.String,Communication.OperateResult{Communication.Profinet.Melsec.MelsecMcDataType,System.Int32}})">
            <summary>
            以位为单位，创建ASCII数据写入的核心报文
            </summary>
            <param name="address">三菱的地址信息，具体格式参照<seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的注释说明</param>
            <param name="value">原始的bool数组数据</param>
            <param name="analysisAddress">对地址分析的委托方法</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildBytesFromData(System.Byte)">
            <summary>
            从字节构建一个ASCII格式的地址字节
            </summary>
            <param name="value">字节信息</param>
            <returns>ASCII格式的地址</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildBytesFromData(System.Int16)">
            <summary>
            从short数据构建一个ASCII格式地址字节
            </summary>
            <param name="value">short值</param>
            <returns>ASCII格式的地址</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildBytesFromData(System.UInt16)">
            <summary>
            从ushort数据构建一个ASCII格式地址字节
            </summary>
            <param name="value">ushort值</param>
            <returns>ASCII格式的地址</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildBytesFromAddress(System.Int32,Communication.Profinet.Melsec.MelsecMcDataType)">
            <summary>
            从三菱的地址中构建MC协议的6字节的ASCII格式的地址
            </summary>
            <param name="address">三菱地址</param>
            <param name="type">三菱的数据类型</param>
            <returns>6字节的ASCII格式的地址</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.BuildBytesFromData(System.Byte[])">
            <summary>
            从字节数组构建一个ASCII格式的地址字节
            </summary>
            <param name="value">字节信息</param>
            <returns>ASCII格式的地址</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.TransBoolArrayToByteData(System.Byte[])">
            <summary>
            将0，1，0，1的字节数组压缩成三菱格式的字节数组来表示开关量的
            </summary>
            <param name="value">原始的数据字节</param>
            <returns>压缩过后的数据字节</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.TransBoolArrayToByteData(System.Boolean[])">
            <summary>
            将bool的组压缩成三菱格式的字节数组来表示开关量的
            </summary>
            <param name="value">原始的数据字节</param>
            <returns>压缩过后的数据字节</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.FxCalculateCRC(System.Byte[])">
            <summary>
            计算Fx协议指令的和校验信息
            </summary>
            <param name="data">字节数据</param>
            <returns>校验之后的数据</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecHelper.CheckCRC(System.Byte[])">
            <summary>
            检查指定的和校验是否是正确的
            </summary>
            <param name="data">字节数据</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecMcAsciiNet">
            <summary>
            三菱PLC通讯类，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为ASCII通讯格式
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
               <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>边沿继电器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>ZR文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR2A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的触点</term>
                <term>SS</term>
                <term>SS100,SS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的线圈</term>
                <term>SC</term>
                <term>SC100,SC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的当前值</term>
                <term>SN</term>
                <term>SN100,SN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前值</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.#ctor">
            <summary>
            实例化三菱的Qna兼容3E帧协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个三菱的Qna兼容3E帧协议的通讯对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcAsciiNet.NetworkNumber">
            <summary>
            网络号
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcAsciiNet.NetworkStationNumber">
            <summary>
            网络站号
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.McAnalysisAddress(System.String)">
            <summary>
            分析地址的方法，允许派生类里进行重写操作
            </summary>
            <param name="address">地址信息</param>
            <returns>解析后的数据信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.Read(System.String,System.UInt16)">
            <summary>
            从三菱PLC中读取想要的数据，返回读取结果
            </summary>
            <param name="address">读取地址，格式为"M100","D100","W1A0"</param>
            <param name="length">读取的数据长度，字最大值960，位最大值7168</param>
            <returns>带成功标志的结果数据对象</returns>
            <remarks>
            地址支持的列表参考 <seealso cref="T:Communication.Profinet.Melsec.MelsecMcAsciiNet"/> 的备注说明
            </remarks>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型
            </summary>
            <param name="address">初始地址</param>
            <param name="value">原始的字节数据</param>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，写入如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="WriteExample2" title="Write示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="WriteExample1" title="Write示例" />
            </example>
            <returns>结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.ReadBool(System.String,System.UInt16)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <remarks>
            地址支持的列表参考 <seealso cref="T:Communication.Profinet.Melsec.MelsecMcAsciiNet"/> 的备注说明
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="ReadBool" title="Bool类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.ReadBool(System.String)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>参照 <see cref="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.ReadBool(System.String,System.UInt16)"/> 方法 </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Boolean)">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入M100,values[0]对应M100
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="value">要写入的实际数据，长度为8的倍数</param>
            <example>
            详细请查看<see cref="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Boolean[])"/>方法的示例
            </example>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入M100,values[0]对应M100
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="WriteBool" title="Write示例" />
            </example>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.RemoteRun">
            <summary>
            远程Run操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.RemoteStop">
            <summary>
            远程Stop操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.ReadPlcType">
            <summary>
            读取PLC的型号信息
            </summary>
            <returns>返回型号的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.ToString">
            <summary>
            获取当前对象的字符串标识形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.PackMcCommand(System.Byte[],System.Byte,System.Byte)">
            <summary>
            将MC协议的核心报文打包成一个可以直接对PLC进行发送的原始报文
            </summary>
            <param name="mcCore">MC协议的核心报文</param>
            <param name="networkNumber">网络号</param>
            <param name="networkStationNumber">网络站号</param>
            <returns>原始报文信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcAsciiNet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecMcDataType">
            <summary>
            三菱PLC的数据类型，此处包含了几个常用的类型
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcDataType.#ctor(System.Byte,System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcDataType.DataCode">
            <summary>
            类型的代号值
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.M">
            <summary>
            M中间继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.D">
            <summary>
            D数据寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.W">
            <summary>
            W链接寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.L">
            <summary>
            L锁存继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.F">
            <summary>
            F报警器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.V">
            <summary>
            V边沿继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.B">
            <summary>
            B链接继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.R">
            <summary>
            R文件寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.S">
            <summary>
            S步进继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Z">
            <summary>
            变址寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.TN">
            <summary>
            定时器的当前值
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.TS">
            <summary>
            定时器的触点
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.TC">
            <summary>
            定时器的线圈
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.SS">
            <summary>
            累计定时器的触点
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.SC">
            <summary>
            累计定时器的线圈
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.SN">
            <summary>
            累计定时器的当前值
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.CN">
            <summary>
            计数器的当前值
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.CS">
            <summary>
            计数器的触点
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.CC">
            <summary>
            计数器的线圈
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.ZR">
            <summary>
            文件寄存器ZR区
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_M">
            <summary>
            内部辅助继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_SM">
            <summary>
            控制继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_SD">
            <summary>
            控制存储器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_D">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_ZR">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_W">
            <summary>
            链路寄存器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Keyence_CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_X">
            <summary>
            输入继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_Y">
            <summary>
            输出继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_L">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_R">
            <summary>
            内部继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_DT">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_LD">
            <summary>
            链接存储器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_SM">
            <summary>
            特殊链接继电器
            </summary>
        </member>
        <member name="F:Communication.Profinet.Melsec.MelsecMcDataType.Panasonic_SD">
            <summary>
            特殊链接存储器
            </summary>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecMcNet">
            <summary>
            三菱PLC通讯类，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为二进制通讯
            </summary>
            <remarks>
            目前组件测试通过的PLC型号列表，有些来自于网友的测试
            <list type="number">
            <item>Q06UDV PLC  感谢hwdq0012</item>
            <item>fx5u PLC  感谢山楂</item>
            <item>Q02CPU PLC </item>
            <item>L02CPU PLC </item>
            </list>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
               <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>边沿继电器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>ZR文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR2A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的触点</term>
                <term>SS</term>
                <term>SS100,SS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的线圈</term>
                <term>SC</term>
                <term>SC100,SC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的当前值</term>
                <term>SN</term>
                <term>SN100,SN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前值</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.#ctor">
            <summary>
            实例化三菱的Qna兼容3E帧协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个三菱的Qna兼容3E帧协议的通讯对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcNet.NetworkNumber">
            <summary>
            网络号，通常为0
            </summary>
            <remarks>
            依据PLC的配置而配置，如果PLC配置了1，那么此处也填0，如果PLC配置了2，此处就填2，测试不通的话，继续测试0
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber">
            <summary>
            网络站号，通常为0
            </summary>
            <remarks>
            依据PLC的配置而配置，如果PLC配置了1，那么此处也填0，如果PLC配置了2，此处就填2，测试不通的话，继续测试0
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String)">
            <summary>
            分析地址的方法，允许派生类里进行重写操作
            </summary>
            <param name="address">地址信息</param>
            <returns>解析后的数据信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.Read(System.String,System.UInt16)">
            <summary>
            从三菱PLC中读取想要的数据，输入地址，按照字单位读取，返回读取结果
            </summary>
            <param name="address">读取地址，格式为"M100","D100","W1A0"</param>
            <param name="length">读取的数据长度，字最大值960，位最大值7168</param>
            <returns>带成功标志的结果数据对象</returns>
            <remarks>
            地址支持的列表参考 <seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的备注说明
            </remarks>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型
            </summary>
            <param name="address">初始地址</param>
            <param name="value">原始的字节数据</param>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，写入如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="WriteExample1" title="Write示例" />
            </example>
            <returns>结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.ReadBool(System.String,System.UInt16)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <remarks>
            地址支持的列表参考 <seealso cref="T:Communication.Profinet.Melsec.MelsecMcNet"/> 的备注说明
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadBool" title="Bool类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.ReadBool(System.String)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>参照 <see cref="M:Communication.Profinet.Melsec.MelsecMcNet.ReadBool(System.String,System.UInt16)"/> 方法 </example>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Boolean)">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入M100,values[0]对应M100
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="value">要写入的实际数据，长度为8的倍数</param>
            <example>
            详细请查看<see cref="M:Communication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Boolean[])"/>方法的示例
            </example>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入M100,values[0]对应M100
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="WriteBool" title="Write示例" />
            </example>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.RemoteRun">
            <summary>
            远程Run操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.RemoteStop">
            <summary>
            远程Stop操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.RemoteReset">
            <summary>
            远程Reset操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.ReadPlcType">
            <summary>
            读取PLC的型号信息
            </summary>
            <returns>返回型号的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.ToString">
            <summary>
            获取当前对象的字符串标识形式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.PackMcCommand(System.Byte[],System.Byte,System.Byte)">
            <summary>
            将MC协议的核心报文打包成一个可以直接对PLC进行发送的原始报文
            </summary>
            <param name="mcCore">MC协议的核心报文</param>
            <param name="networkNumber">网络号</param>
            <param name="networkStationNumber">网络站号</param>
            <returns>原始报文信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcNet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:Communication.Profinet.Melsec.MelsecMcServer">
            <summary>
            三菱MC协议的虚拟服务器，支持M,X,Y,D,W的数据池读写操作，使用二进制进行读写操作
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.#ctor">
            <summary>
            实例化一个mc协议的服务器
            </summary>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.Read(System.String,System.UInt16)">
            <summary>
            读取自定义的寄存器的值。按照字为单位
            </summary>
            <param name="address">起始地址，示例："D100"，"M100"</param>
            <param name="length">数据长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <returns>byte数组值</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.Write(System.String,System.Byte[])">
            <summary>
            写入自定义的数据到数据内存中去
            </summary>
            <param name="address">地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.ReadBool(System.String)">
            <summary>
            读取指定地址的bool数据对象
            </summary>
            <param name="address">西门子的地址信息</param>
            <returns>带有成功标志的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.ReadBool(System.String,System.UInt16)">
            <summary>
            读取指定地址的bool数据对象
            </summary>
            <param name="address">三菱的地址信息</param>
            <param name="length">数组的长度</param>
            <returns>带有成功标志的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.Write(System.String,System.Boolean)">
            <summary>
            往指定的地址里写入bool数据对象
            </summary>
            <param name="address">三菱的地址信息</param>
            <param name="value">值</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.Write(System.String,System.Boolean[])">
            <summary>
            往指定的地址里写入bool数组对象
            </summary>
            <param name="address">三菱的地址信息</param>
            <param name="value">值</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端登录后，进行Ip信息的过滤，然后触发本方法，也就是说之后的客户端需要
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endPoint">终端节点</param>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.ReadFromMcCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。
            </summary>
            <param name="mcCore">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.LoadFromBytes(System.Byte[])">
            <summary>
            从字节数据加载数据信息
            </summary>
            <param name="content">字节数据</param>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.SaveToBytes">
            <summary>
            将数据信息存储到字节数组去
            </summary>
            <returns>所有的内容</returns>
        </member>
        <member name="M:Communication.Profinet.Melsec.MelsecMcServer.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Profinet.Omron.OmronFinsDataType">
            <summary>
            欧姆龙的Fins协议的数据类型
            </summary>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsDataType.#ctor(System.Byte,System.Byte)">
            <summary>
            实例化一个Fins的数据类型
            </summary>
            <param name="bitCode">进行位操作的指令</param>
            <param name="wordCode">进行字操作的指令</param>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsDataType.BitCode">
            <summary>
            进行位操作的指令
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsDataType.WordCode">
            <summary>
            进行字操作的指令
            </summary>
        </member>
        <member name="F:Communication.Profinet.Omron.OmronFinsDataType.DM">
            <summary>
            DM Area
            </summary>
        </member>
        <member name="F:Communication.Profinet.Omron.OmronFinsDataType.CIO">
            <summary>
            CIO Area
            </summary>
        </member>
        <member name="F:Communication.Profinet.Omron.OmronFinsDataType.WR">
            <summary>
            Work Area
            </summary>
        </member>
        <member name="F:Communication.Profinet.Omron.OmronFinsDataType.HR">
            <summary>
            Holding Bit Area
            </summary>
        </member>
        <member name="F:Communication.Profinet.Omron.OmronFinsDataType.AR">
            <summary>
            Auxiliary Bit Area
            </summary>
        </member>
        <member name="T:Communication.Profinet.Omron.OmronFinsNet">
            <summary>
            欧姆龙PLC通讯类，采用Fins-Tcp通信协议实现
            </summary>
            <remarks>
            <note type="important">实例化之后，使用之前，需要初始化三个参数信息，具体见三个参数的说明：<see cref="P:Communication.Profinet.Omron.OmronFinsNet.SA1"/>，<see cref="P:Communication.Profinet.Omron.OmronFinsNet.DA1"/>，<see cref="P:Communication.Profinet.Omron.OmronFinsNet.DA2"/></note>
            <br />
            <note type="warning">如果在测试的时候报错误码64，经网友 上海-Lex 指点，是因为PLC中产生了报警，如伺服报警，模块错误等产生的，但是数据还是能正常读到的，屏蔽64报警或清除plc错误可解决</note>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>DM Area</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>CIO Area</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Work Area</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Holding Bit Area</term>
                <term>H</term>
                <term>H100,H200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Auxiliary Bit Area</term>
                <term>A</term>
                <term>A100,A200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.#ctor">
            <summary>
            实例化一个欧姆龙PLC Fins帧协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个欧姆龙PLC Fins帧协议的通讯对象
            </summary>
            <param name="ipAddress">PLCd的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.IpAddress">
            <summary>
            设备的Ip地址信息
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.ICF">
            <summary>
            信息控制字段，默认0x80
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.RSV">
            <summary>
            系统使用的内部信息
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.GCT">
            <summary>
            网络层信息，默认0x02，如果有八层消息，就设置为0x07
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.DNA">
            <summary>
            PLC的网络号地址，默认0x00
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.DA1">
            <summary>
            PLC的节点地址，这个值在配置了ip地址之后是默认赋值的，默认为Ip地址的最后一位
            </summary>
            <remarks>
            <note type="important">假如你的PLC的Ip地址为192.168.0.10，那么这个值就是10</note>
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.DA2">
            <summary>
            PLC的单元号地址
            </summary>
            <remarks>
            <note type="important">通常都为0</note>
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.SNA">
            <summary>
            上位机的网络号地址
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.SA1">
            <summary>
            上位机的节点地址，假如你的电脑的Ip地址为192.168.0.13，那么这个值就是13
            </summary>
            <remarks>
            <note type="important">假如你的电脑的Ip地址为192.168.0.13，那么这个值就是13</note>
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.SA2">
            <summary>
            上位机的单元号地址
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsNet.SID">
            <summary>
            设备的标识号
            </summary>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">是否是位读取</param>
            <returns>带有成功标志的报文数据</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.BuildWriteCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">真实的数据值信息</param>
            <param name="isBit">是否是位操作</param>
            <returns>带有成功标志的报文数据</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            在连接上欧姆龙PLC后，需要进行一步握手协议
            </summary>
            <param name="socket">连接的套接字</param>
            <returns>初始化成功与否</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)">
            <summary>
            从欧姆龙PLC中读取想要的数据，返回读取结果，读取单位为字
            </summary>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的数据长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.ReadBool(System.String)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">读取地址，格式为"D100.0","C100.15","W100.7","H100.4","A100.9"</param>
            <returns>带成功标志的结果数据对象</returns>
            <remarks>
            地址的格式请参照<see cref="M:Communication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>方法
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型
            </summary>
            <param name="address">初始地址</param>
            <param name="value">原始的字节数据</param>
            <returns>结果</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean)">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入D100,values[0]对应D100.0
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="value">要写入的实际数据，长度为8的倍数</param>
            <returns>返回写入结果</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入D100,values[0]对应D100.0
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <returns>返回写入结果</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNet.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Profinet.Omron.OmronFinsNetHelper">
            <summary>
            Omron PLC的FINS协议相关的辅助类
            </summary>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNetHelper.AnalysisAddress(System.String,System.Boolean)">
            <summary>
            解析数据地址，Omron手册第188页
            </summary>
            <param name="address">数据地址</param>
            <param name="isBit">是否是位地址</param>
            <returns>解析后的结果地址对象</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNetHelper.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据读取的地址，长度，是否位读取创建Fins协议的核心报文
            </summary>
            <param name="address">地址，具体格式请参照示例说明</param>
            <param name="length">读取的数据长度</param>
            <param name="isBit">是否使用位读取</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNetHelper.BuildWriteWordCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            根据写入的地址，数据，是否位写入生成Fins协议的核心报文
            </summary>
            <param name="address">地址内容，具体格式请参照示例说明</param>
            <param name="value">实际的数据</param>
            <param name="isBit">是否位数据</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNetHelper.ResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNetHelper.UdpResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-Udp返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsNetHelper.GetStatusDescription(System.Int32)">
            <summary>
            获取错误信息的字符串描述文本
            </summary>
            <param name="err">错误码</param>
            <returns>文本描述</returns>
        </member>
        <member name="T:Communication.Profinet.Omron.OmronFinsUdp">
            <summary>
            欧姆龙的Udp的数据对象
            </summary>
            <remarks>
            <note type="warning">如果在测试的时候报错误码64，经网友 上海-Lex 指点，是因为PLC中产生了报警，如伺服报警，模块错误等产生的，但是数据还是能正常读到的，屏蔽64报警或清除plc错误可解决</note>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>DM Area</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>CIO Area</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Work Area</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Holding Bit Area</term>
                <term>H</term>
                <term>H100,H200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Auxiliary Bit Area</term>
                <term>A</term>
                <term>A100,A200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的欧姆龙Udp的对象
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.#ctor">
            <summary>
            实例化一个默认的欧姆龙Udp的对象
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.IpAddress">
            <summary>
            设备的Ip地址信息
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.ICF">
            <summary>
            信息控制字段，默认0x80
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.RSV">
            <summary>
            系统使用的内部信息
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.GCT">
            <summary>
            网络层信息，默认0x02，如果有八层消息，就设置为0x07
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.DNA">
            <summary>
            PLC的网络号地址，默认0x00
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.DA1">
            <summary>
            PLC的节点地址，这个值在配置了ip地址之后是默认赋值的，默认为Ip地址的最后一位
            </summary>
            <remarks>
            <note type="important">假如你的PLC的Ip地址为192.168.0.10，那么这个值就是10</note>
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.DA2">
            <summary>
            PLC的单元号地址
            </summary>
            <remarks>
            <note type="important">通常都为0</note>
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.SNA">
            <summary>
            上位机的网络号地址
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.SA1">
            <summary>
            上位机的节点地址，假如你的电脑的Ip地址为192.168.0.13，那么这个值就是13
            </summary>
            <remarks>
            <note type="important">假如你的电脑的Ip地址为192.168.0.13，那么这个值就是13</note>
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.SA2">
            <summary>
            上位机的单元号地址
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronFinsUdp.SID">
            <summary>
            设备的标识号
            </summary>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">是否是位读取</param>
            <returns>带有成功标志的报文数据</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.BuildWriteCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">真实的数据值信息</param>
            <param name="isBit">是否是位操作</param>
            <returns>带有成功标志的报文数据</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.Read(System.String,System.UInt16)">
            <summary>
            从欧姆龙PLC中读取想要的数据，返回读取结果，读取单位为字
            </summary>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的数据长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.ReadBool(System.String,System.UInt16)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.ReadBool(System.String)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">读取地址，格式为"D100.0","C100.15","W100.7","H100.4","A100.9"</param>
            <returns>带成功标志的结果数据对象</returns>
            <remarks>
            地址的格式请参照<see cref="M:Communication.Profinet.Omron.OmronFinsUdp.ReadBool(System.String,System.UInt16)"/>方法
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型
            </summary>
            <param name="address">初始地址</param>
            <param name="value">原始的字节数据</param>
            <returns>结果</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.Boolean)">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入D100,values[0]对应D100.0
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="value">要写入的实际数据，长度为8的倍数</param>
            <returns>返回写入结果</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入D100,values[0]对应D100.0
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <returns>返回写入结果</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronFinsUdp.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Profinet.Omron.OmronHostLink">
            <summary>
            欧姆龙的HostLink协议的实现
            </summary>
            <remarks>
            感谢 深圳～拾忆 的测试
            欧姆龙的地址参考如下：
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>DM Area</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>CIO Area</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Work Area</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Holding Bit Area</term>
                <term>H</term>
                <term>H100,H200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Auxiliary Bit Area</term>
                <term>A</term>
                <term>A100,A200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronHostLink.ICF">
            <summary>
            Specifies whether or not there are network relays. Set “80” (ASCII: 38,30) 
            when sending an FINS command to a CPU Unit on a network.Set “00” (ASCII: 30,30) 
            when sending to a CPU Unit connected directly to the host computer.
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronHostLink.DA2">
            <summary>
            PLC的单元号地址
            </summary>
            <remarks>
            <note type="important">通常都为0</note>
            </remarks>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronHostLink.SA2">
            <summary>
            上位机的单元号地址
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronHostLink.SID">
            <summary>
            设备的标识号
            </summary>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronHostLink.ResponseWaitTime">
            <summary>
            The response wait time sets the time from when the CPU Unit receives a command block until it starts 
            to return a response.It can be set from 0 to F in hexadecimal, in units of 10 ms.
            </summary>
            <example>
            If F(15) is set, the response will begin to be returned 150 ms (15 × 10 ms) after the command block was received.
            </example>
        </member>
        <member name="P:Communication.Profinet.Omron.OmronHostLink.UnitNumber">
            <summary>
            PLC设备的站号信息
            </summary>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，具体的地址参考文档
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，具体的地址参考文档
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.ReadBool(System.String,System.UInt16)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">读取地址，具体的地址参考文档</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.ReadBool(System.String)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，返回读取结果
            </summary>
            <param name="address">读取地址，具体的地址参考文档</param>
            <returns>带成功标志的结果数据对象</returns>
            <remarks>
            地址的格式请参照<see cref="M:Communication.Profinet.Omron.OmronHostLink.ReadBool(System.String,System.UInt16)"/>方法
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.Write(System.String,System.Boolean)">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入D100,values[0]对应D100.0
            </summary>
            <param name="address">要写入的数据地址，具体的地址参考文档</param>
            <param name="value">要写入的实际数据，长度为8的倍数</param>
            <returns>返回写入结果</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回值说明，比如你写入D100,values[0]对应D100.0
            </summary>
            <param name="address">要写入的数据地址，具体的地址参考文档</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <returns>返回写入结果</returns>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd">fins指令</param>
            <returns>完整的质量</returns>
        </member>
        <member name="M:Communication.Profinet.Omron.OmronHostLink.ResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="T:Communication.Profinet.Panasonic.PanasonicMcNet">
            <summary>
            松下PLC的MC协议的信息，具体的地址格式请参考备注说明
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址示例一</term>
                <term>地址范围</term>
                <term>字操作</term>
                <term>位操作</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X0000,X100F</term>
                <term>X0000～X109F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y0000,Y100F</term>
                <term>Y0000～Y109F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>L</term>
                <term>L0000,L100F</term>
                <term>L0000～L0127F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>内部继电器</term>
                <term>R</term>
                <term>R0000,R100F</term>
                <term>R0000～R511F,R9000～R951F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>D0～D65532,D90000～D90999</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>LD</term>
                <term>LD0,LD100</term>
                <term>LD0～LD255</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>TN0～TN1023</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>TS0～TS1023</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>CN0～CN1023</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>CS0～CS1023</term>
                <term>√</term>
                <term>√</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMcNet.#ctor">
            <summary>
            实例化松下的的Qna兼容3E帧协议的通讯对象
            </summary>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMcNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个基恩士的Qna兼容3E帧协议的通讯对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMcNet.McAnalysisAddress(System.String)">
            <summary>
            分析地址的方法，允许派生类里进行重写操作
            </summary>
            <param name="address">地址信息</param>
            <returns>解析后的数据信息</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMcNet.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Profinet.Panasonic.PanasonicMewtocol">
            <summary>
            松下PLC的数据交互协议，采用Mewtocol协议通讯
            </summary>
            <remarks>
            触点地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>外部输入继电器</term>
                <term>X</term>
                <term>X0,X100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>外部输出继电器</term>
                <term>Y</term>
                <term>Y0,Y100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>内部继电器</term>
                <term>R</term>
                <term>R0,R100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0,T100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0,C100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>L</term>
                <term>L0,L100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            数据地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器 DT</term>
                <term>D</term>
                <term>D0,D100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器 LT</term>
                <term>L</term>
                <term>L0,L100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器 FL</term>
                <term>F</term>
                <term>F0,F100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>目标值 SV</term>
                <term>S</term>
                <term>S0,S100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>经过值 EV</term>
                <term>K</term>
                <term>K0,K100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>索引寄存器 IX</term>
                <term>IX</term>
                <term>IX0,IX100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>索引寄存器 IY</term>
                <term>IY</term>
                <term>IY0,IY100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.#ctor(System.Byte)">
            <summary>
            实例化一个默认的松下PLC通信对象，默认站号为1
            </summary>
            <param name="station">站号信息，默认为0xEE</param>
        </member>
        <member name="P:Communication.Profinet.Panasonic.PanasonicMewtocol.Station">
            <summary>
            设备的目标站号
            </summary>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.Read(System.String,System.UInt16)">
            <summary>
            从松下PLC中读取数据
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <returns>返回数据信息</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到松下PLC中
            </summary>
            <param name="address">起始地址</param>
            <param name="value">真实数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取松下PLC的位地址
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String)">
            <summary>
            读取单个的Bool数据
            </summary>
            <param name="address">起始地址</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean[])">
            <summary>
            写入bool数据信息，存在一定的风险，谨慎操作
            </summary>
            <param name="address">起始地址</param>
            <param name="values">数据值信息</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean)">
            <summary>
            写入bool数据数据
            </summary>
            <param name="address">起始地址</param>
            <param name="value">True还是False</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址
            </summary>
            <param name="address">数据地址</param>
            <returns>解析出地址类型，起始地址，是否位读取</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.BuildReadMultiCoil(System.String[])">
            <summary>
            创建读取离散触点的报文指令
            </summary>
            <param name="address">地址信息</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.BuildWriteMultiCoil(System.String[],System.Boolean[])">
            <summary>
            创建写入离散触点的报文指令
            </summary>
            <param name="address">地址信息</param>
            <param name="values">bool值数组</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.BuildReadCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            创建批量读取触点的报文指令
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.BuildWriteCommand(System.Byte,System.String,System.Byte[],System.Int16)">
            <summary>
            创建批量读取触点的报文指令
            </summary>
            <param name="station">设备站号</param>
            <param name="address">地址信息</param>
            <param name="values">数据值</param>
            <param name="length">数据长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Panasonic.PanasonicMewtocol.ExtraActualData(System.Byte[])">
            <summary>
            检查从PLC反馈的数据，并返回正确的数据内容
            </summary>
            <param name="response">反馈信号</param>
            <returns>是否成功的结果信息</returns>
        </member>
        <member name="T:Communication.Profinet.Siemens.SiemensFetchWriteNet">
            <summary>
            使用了Fetch/Write协议来和西门子进行通讯，该种方法需要在PLC侧进行一些配置 ->
            Using the Fetch/write protocol to communicate with Siemens, this method requires some configuration on the PLC side
            </summary>
            <remarks>
            与S7协议相比较而言，本协议不支持对单个的点位的读写操作。如果读取M100.0，需要读取M100的值，然后进行提取位数据
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.#ctor">
            <summary>
            实例化一个西门子的Fetch/Write协议的通讯对象 ->
            Instantiate a communication object for a Siemens Fetch/write protocol
            </summary>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个西门子的Fetch/Write协议的通讯对象 ->
            Instantiate a communication object for a Siemens Fetch/write protocol
            </summary>
            <param name="ipAddress">PLC的Ip地址 -> Specify IP Address</param>
            <param name="port">PLC的端口 -> Specify IP Port</param>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.Read(System.String,System.UInt16)">
            <summary>
            从PLC读取数据，地址格式为I100，Q100，DB20.100，M100，T100，C100，以字节为单位 ->
            Read data from PLC, address format I100,Q100,DB20.100,M100,T100,C100, in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100，T100，C100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100,T100,C100
            </param>
            <param name="length">读取的数量，以字节为单位 -> The number of reads, in bytes</param>
            <returns>带有成功标志的字节信息 -> Byte information with a success flag</returns>
            <example>
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据 -> Reads the byte data for the specified address
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <returns>byte类型的结果对象 -> Result object of type Byte</returns>
            <remarks>
            <note type="warning">
            不适用于DB块，定时器，计数器的数据读取，会提示相应的错误，读取长度必须为偶数
            </note>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到PLC数据，地址格式为I100，Q100，DB20.100，M100，以字节为单位 ->
            Writes data to the PLC data, in the address format i100,q100,db20.100,m100, in bytes
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="value">要写入的实际数据 -> The actual data to write</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设起始地址为M100，M100,M101存储了温度，100.6℃值为1006，M102,M103存储了压力，1.23Mpa值为123，M104-M107存储了产量计数，写入如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中写入bool数组，返回值说明，比如你写入M100,那么data[0]对应M100.0 ->
            Write the bool array to the PLC, return the value description, for example, if you write M100, then data[0] corresponds to M100.0
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="values">要写入的实际数据，长度为8的倍数 -> The actual data to write, a multiple of 8 in length</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <remarks>
            <note type="warning">
            批量写入bool数组存在一定的风险，原因是只能批量写入长度为8的倍数的数组，否则会影响其他的位的数据，请谨慎使用。 ->
            There is a risk in bulk writing to a bool array, because it is possible to write arrays of multiples of length 8 in bulk, otherwise it will affect the data of other bits, please use sparingly.
            </note>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回是否写入成功 -> Writes byte data to the PLC and returns whether the write succeeded
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="value">要写入的实际数据 -> The actual data to write</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.ToString">
            <summary>
            返回表示当前对象的字符串 -> Returns a String representing the current object
            </summary>
            <returns>字符串数据 -> String data</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.CalculateAddressStarted(System.String)">
            <summary>
            计算特殊的地址信息
            </summary>
            <param name="address">字符串信息</param>
            <returns>实际值</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址 -> Parse data address, parse out address type, start address, db block address
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <returns>解析出地址类型，起始地址，DB块的地址 -> Resolves address type, start address, db block address</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取字数据指令头的通用方法 -> A general method for generating a command header to read a Word data
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="count">读取数据个数 -> Number of Read data</param>
            <returns>带结果对象的报文数据 -> Message data with a result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensFetchWriteNet.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            生成一个写入字节数据的指令 -> Generate an instruction to write byte data
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="data">实际的写入的内容 -> The actual content of the write</param>
            <returns>带结果对象的报文数据 -> Message data with a result object</returns>
        </member>
        <member name="T:Communication.Profinet.Siemens.SiemensPLCS">
            <summary>
            西门子的PLC类型，目前支持的访问类型
            </summary>
        </member>
        <member name="F:Communication.Profinet.Siemens.SiemensPLCS.S1200">
            <summary>
            1200系列
            </summary>
        </member>
        <member name="F:Communication.Profinet.Siemens.SiemensPLCS.S300">
            <summary>
            300系列
            </summary>
        </member>
        <member name="F:Communication.Profinet.Siemens.SiemensPLCS.S400">
            <summary>
            400系列
            </summary>
        </member>
        <member name="F:Communication.Profinet.Siemens.SiemensPLCS.S1500">
            <summary>
            1500系列PLC
            </summary>
        </member>
        <member name="F:Communication.Profinet.Siemens.SiemensPLCS.S200Smart">
            <summary>
            200的smart系列
            </summary>
        </member>
        <member name="F:Communication.Profinet.Siemens.SiemensPLCS.S200">
            <summary>
            200系统，需要额外配置以太网模块
            </summary>
        </member>
        <member name="T:Communication.Profinet.Siemens.SiemensPPI">
            <summary>
            西门子的PPI协议，适用于s7-200plc，注意，本类库有个致命的风险需要注意，由于本类库的每次通讯分成2次操作，故而不支持多线程同时读写，当发生线程竞争的时候，会导致数据异常，
            想要解决的话，需要您在每次数据交互时添加同步锁。
            </summary>
            <remarks>
            适用于西门子200的通信，非常感谢 合肥-加劲 的测试，让本类库圆满完成。
            
            注意：M地址范围有限 0-31地址
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.#ctor">
            <summary>
            实例化一个西门子的PPI协议对象
            </summary>
        </member>
        <member name="P:Communication.Profinet.Siemens.SiemensPPI.Station">
            <summary>
            西门子PLC的站号信息
            </summary>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.Read(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取数据信息，地址为"M100","AI100","I0","Q0","V100","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.ReadBool(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取bool数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.ReadBool(System.String)">
            <summary>
            从西门子的PLC中读取bool数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte[])">
            <summary>
            将字节数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Boolean[])">
            <summary>
            将bool数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Boolean)">
            <summary>
            将bool数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.ReadByte(System.String)">
            <summary>
            从西门子的PLC中读取byte数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.WriteByte(System.String,System.Byte)">
            <summary>
            将byte数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.Start">
            <summary>
            启动西门子PLC为RUN模式
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.Stop">
            <summary>
            停止西门子PLC，切换为Stop模式
            </summary>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址 ->
            Parse data address, parse out address type, start address, db block address
            </summary>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <returns>解析数据地址，解析出地址类型，起始地址，DB块的地址 ->
            Parse data address, parse out address type, start address, db block address</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            生成一个读取字数据指令头的通用方法 ->
            A general method for generating a command header to read a Word data
            </summary>
            <param name="station">设备的站号信息 -> Station number information for the device</param>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <param name="length">读取数据长度 -> Read Data length</param>
            <param name="isBit">是否为位读取</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            生成一个写入PLC数据信息的报文内容
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址</param>
            <param name="values">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.GetMsgFromStatus(System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="code">状态</param>
            <returns>消息文本</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.GetMsgFromStatus(System.Byte,System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="errorClass">错误类型</param>
            <param name="errorCode">错误代码</param>
            <returns>错误信息</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensPPI.BuildWriteCommand(System.Byte,System.String,System.Boolean[])">
            <summary>
            创建写入PLC的bool类型数据报文指令
            </summary>
            <param name="station">PLC的站号信息</param>
            <param name="address">地址信息</param>
            <param name="values">bool[]数据值</param>
            <returns>带有成功标识的结果对象</returns>
        </member>
        <member name="T:Communication.Profinet.Siemens.SiemensS7Net">
            <summary>
            一个西门子的客户端类，使用S7协议来进行数据交互 ->
            A Siemens client class that uses the S7 protocol for data interaction
            </summary>
            <remarks>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>V寄存器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>V寄存器本质就是DB块1</term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
            </list>
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100</note>
            </remarks>
            <example>
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.#ctor(Communication.Profinet.Siemens.SiemensPLCS)">
            <summary>
            实例化一个西门子的S7协议的通讯对象 ->
            Instantiate a communication object for a Siemens S7 protocol
            </summary>
            <param name="siemens">指定西门子的型号</param>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.#ctor(Communication.Profinet.Siemens.SiemensPLCS,System.String)">
            <summary>
            实例化一个西门子的S7协议的通讯对象并指定Ip地址 ->
            Instantiate a communication object for a Siemens S7 protocol and specify an IP address
            </summary>
            <param name="siemens">指定西门子的型号</param>
            <param name="ipAddress">Ip地址</param>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Initialization(Communication.Profinet.Siemens.SiemensPLCS,System.String)">
            <summary>
            初始化方法 -> Initialize method
            </summary>
            <param name="siemens">指定西门子的型号 -> Designation of Siemens</param>
            <param name="ipAddress">Ip地址 -> IpAddress</param>
        </member>
        <member name="P:Communication.Profinet.Siemens.SiemensS7Net.Slot">
            <summary>
            PLC的槽号，针对S7-400的PLC设置的
            </summary>
        </member>
        <member name="P:Communication.Profinet.Siemens.SiemensS7Net.Rack">
            <summary>
            PLC的机架号，针对S7-400的PLC设置的
            </summary>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            连接上服务器后需要进行的二次握手操作 -> Two handshake actions required after connecting to the server
            </summary>
            <param name="socket">网络套接字 -> Network sockets</param>
            <returns>是否初始化成功，依据具体的协议进行重写 ->
            Whether the initialization succeeds and is rewritten according to the specific protocol</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.ReadOrderNumber">
            <summary>
            从PLC读取订货号信息 -> Reading order number information from PLC
            </summary>
            <returns>CPU的订货号信息 -> Order number information for the CPU</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.HotStart">
            <summary>
            对PLC进行热启动
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.ColdStart">
            <summary>
            对PLC进行冷启动
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Stop">
            <summary>
            对PLC进行停止
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)">
            <summary>
            从PLC读取数据，地址格式为I100，Q100，DB20.100，M100，T100，C100以字节为单位 ->
            Read data from PLC, address format I100，Q100，DB20.100，M100，T100，C100 in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="length">读取的数量，以字节为单位 -> The number of reads, in bytes</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <remarks>
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100</note>
            </remarks>
            <example>
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.ReadBitFromPLC(System.String)">
            <summary>
            从PLC读取数据，地址格式为I100，Q100，DB20.100，M100，以位为单位 ->
            Read the data from the PLC, the address format is I100，Q100，DB20.100，M100, in bits units
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Read(System.String[],System.UInt16[])">
            <summary>
            一次性从PLC获取所有的数据，按照先后顺序返回一个统一的Buffer，需要按照顺序处理，两个数组长度必须一致 ->
            One-time from the PLC to obtain all the data, in order to return a unified buffer, need to be processed sequentially, two array length must be consistent
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="length">数据长度数组 -> Array of data Lengths</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <remarks>
            <note type="warning">批量读取的长度有限制，最大为19个地址</note>
            </remarks>
            <example>
            参照<see cref="M:Communication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String)">
            <summary>
            读取指定地址的bool数据，地址格式为I100，M100，Q100，DB20.100 -> 
            reads bool data for the specified address in the format I100，M100，Q100，DB20.100
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <remarks>
            <note type="important">
            对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100
            </note>
            </remarks>
            <example>
            假设读取M100.0的位是否通断
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据，地址格式I100，M100，Q100，DB20.100 ->
            Reads the byte data of the specified address, the address format I100,Q100,DB20.100,M100
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <example>参考<see cref="M:Communication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>的注释</example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.WriteBase(System.Byte[])">
            <summary>
            基础的写入数据的操作支持 -> Operational support for the underlying write data
            </summary>
            <param name="entireValue">完整的字节数据 -> Full byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到PLC数据，地址格式为I100，Q100，DB20.100，M100，以字节为单位 ->
            Writes data to the PLC data, in the address format I100,Q100,DB20.100,M100, in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="value">写入的原始数据 -> Raw data written to</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设起始地址为M100，M100,M101存储了温度，100.6℃值为1006，M102,M103存储了压力，1.23Mpa值为123，M104-M107存储了产量计数，写入如下：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean)">
            <summary>
            写入PLC的一个位，例如"M100.6"，"I100.7"，"Q100.0"，"DB20.100.0"，如果只写了"M100"默认为"M100.0" ->
            Write a bit of PLC, for example  "M100.6",  "I100.7",  "Q100.0",  "DB20.100.0", if only write  "M100" defaults to  "M100.0"
            </summary>
            <param name="address">起始地址，格式为"M100.6",  "I100.7",  "Q100.0",  "DB20.100.0" ->
            Start address, format  "M100.6",  "I100.7",  "Q100.0",  "DB20.100.0"</param>
            <param name="value">写入的数据，True或是False -> Writes the data, either True or False</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设写入M100.0的位是否通断
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中写入bool数组，比如你写入M100,那么data[0]对应M100.0 ->
            Write the bool array to the PLC, for example, if you write M100, then data[0] corresponds to M100.0
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="values">要写入的bool数组，长度为8的倍数 -> The bool array to write, a multiple of 8 in length</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <remarks>
            <note type="warning">
            批量写入bool数组存在一定的风险，原因是只能批量写入长度为8的倍数的数组，否则会影响其他的位的数据，请谨慎使用。
            </note>
            </remarks>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回值说明 -> Write byte data to the PLC, return value description
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="value">byte数据 -> Byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.ReadString(System.String)">
            <summary>
            读取西门子的地址的字符串信息，这个信息是和西门子绑定在一起，长度随西门子的信息动态变化的
            </summary>
            <param name="address">数据地址，具体的格式需要参照类的说明文档</param>
            <returns>带有是否成功的字符串结果类对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.ToString">
            <summary>
            返回表示当前对象的字符串 -> Returns a String representing the current object
            </summary>
            <returns>字符串信息 -> String information</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.CalculateAddressStarted(System.String)">
            <summary>
            计算特殊的地址信息 -> Calculate Special Address information
            </summary>
            <param name="address">字符串地址 -> String address</param>
            <returns>实际值 -> Actual value</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址 ->
            Parse data address, parse out address type, start address, db block address
            </summary>
            <param name="address">起始地址，例如M100，I0，Q0，DB2.100 ->
            Start address, such as M100,I0,Q0,DB2.100</param>
            <returns>解析数据地址，解析出地址类型，起始地址，DB块的地址 ->
            Parse data address, parse out address type, start address, db block address</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取字数据指令头的通用方法 ->
            A general method for generating a command header to read a Word data
            </summary>
            <param name="address">起始地址，例如M100，I0，Q0，DB2.100 ->
            Start address, such as M100,I0,Q0,DB2.100</param>
            <param name="length">读取数据长度 -> Read Data length</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.BuildReadCommand(Communication.OperateResult{System.Byte,System.Int32,System.UInt16}[],System.UInt16[])">
            <summary>
            生成一个读取字数据指令头的通用方法 ->
            A general method for generating a command header to read a Word data
            </summary>
            <param name="address">起始地址，例如M100，I0，Q0，DB2.100 ->
            Start address, such as M100,I0,Q0,DB2.100</param>
            <param name="length">读取数据长度 -> Read Data length</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.BuildBitReadCommand(System.String)">
            <summary>
            生成一个位读取数据指令头的通用方法 ->
            A general method for generating a bit-read-Data instruction header
            </summary>
            <param name="address">起始地址，例如M100.0，I0.1，Q0.1，DB2.100.2 ->
            Start address, such as M100.0,I0.1,Q0.1,DB2.100.2
            </param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.BuildWriteByteCommand(System.String,System.Byte[])">
            <summary>
            生成一个写入字节数据的指令 -> Generate an instruction to write byte data
            </summary>
            <param name="address">起始地址，示例M100,I100,Q100,DB1.100 -> Start Address, example M100,I100,Q100,DB1.100</param>
            <param name="data">原始的字节数据 -> Raw byte data</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.BuildWriteByteCommand(Communication.OperateResult{System.Byte,System.Int32,System.UInt16},System.Byte[])">
            <summary>
            生成一个写入字节数据的指令 -> Generate an instruction to write byte data
            </summary>
            <param name="analysis">起始地址，示例M100,I100,Q100,DB1.100 -> Start Address, example M100,I100,Q100,DB1.100</param>
            <param name="data">原始的字节数据 -> Raw byte data</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Net.BuildWriteBitCommand(System.String,System.Boolean)">
            <summary>
            生成一个写入位数据的指令 -> Generate an instruction to write bit data
            </summary>
            <param name="address">起始地址，示例M100,I100,Q100,DB1.100 -> Start Address, example M100,I100,Q100,DB1.100</param>
            <param name="data">是否通断 -> Power on or off</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="T:Communication.Profinet.Siemens.SiemensS7Server">
            <summary>
            西门子S7协议的虚拟服务器，支持TCP协议，无视PLC的型号，所以在客户端进行操作操作的时候，选择1200或是1500或是300或是400都是一样的。
            </summary>
            <remarks>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>V寄存器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>V寄存器本质就是DB块1</term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
            </list>
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100</note>
            </remarks>
            <example>
            你可以很快速并且简单的创建一个虚拟的s7服务器
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="UseExample1" title="简单的创建服务器" />
            当然如果需要高级的服务器，指定日志，限制客户端的IP地址，获取客户端发送的信息，在服务器初始化的时候就要参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="UseExample4" title="定制服务器" />
            服务器创建好之后，我们就可以对服务器进行一些读写的操作了，下面的代码是基础的BCL类型的读写操作。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="ReadWriteExample" title="基础的读写示例" />
            高级的对于byte数组类型的数据进行批量化的读写操作如下：   
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="BytesReadWrite" title="字节的读写示例" />
            更高级操作请参见源代码。
            </example>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.#ctor">
            <summary>
            实例化一个S7协议的服务器，支持I，Q，M，DB1.X 数据区块的读写操作
            </summary>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.Read(System.String,System.UInt16)">
            <summary>
            读取自定义的寄存器的值
            </summary>
            <param name="address">起始地址，示例："I100"，"M100"</param>
            <param name="length">数据长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <returns>byte数组值</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Byte[])">
            <summary>
            写入自定义的数据到数据内存中去
            </summary>
            <param name="address">地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.ReadByte(System.String)">
            <summary>
            读取指定地址的字节数据
            </summary>
            <param name="address">西门子的地址信息</param>
            <returns>带有成功标志的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Byte)">
            <summary>
            将byte数据信息写入到指定的地址当中
            </summary>
            <param name="address">西门子的地址信息</param>
            <param name="value">字节数据信息</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.ReadBool(System.String)">
            <summary>
            读取指定地址的bool数据对象
            </summary>
            <param name="address">西门子的地址信息</param>
            <returns>带有成功标志的结果对象</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Boolean)">
            <summary>
            往指定的地址里写入bool数据对象
            </summary>
            <param name="address">西门子的地址信息</param>
            <param name="value">值</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端登录后，进行Ip信息的过滤，然后触发本方法，也就是说之后的客户端需要
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endPoint">终端节点</param>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.LoadFromBytes(System.Byte[])">
            <summary>
            从字节数据加载数据信息
            </summary>
            <param name="content">字节数据</param>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.SaveToBytes">
            <summary>
            将数据信息存储到字节数组去
            </summary>
            <returns>所有的内容</returns>
        </member>
        <member name="M:Communication.Profinet.Siemens.SiemensS7Server.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:Communication.Robot.EFORT.EfortData">
            <summary>
            埃夫特机器人的数据结构
            </summary>
        </member>
        <member name="M:Communication.Robot.EFORT.EfortData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.PacketStart">
            <summary>
            报文开始的字符串
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.PacketOrders">
            <summary>
            数据命令
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.PacketHeartbeat">
            <summary>
            数据心跳
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ErrorStatus">
            <summary>
            报警状态，1:有报警，0：无报警
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.HstopStatus">
            <summary>
            急停状态，1：无急停，0：有急停
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.AuthorityStatus">
            <summary>
            权限状态，1：有权限，0：无权限
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ServoStatus">
            <summary>
            伺服状态，1：有使能，0：未使能
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.AxisMoveStatus">
            <summary>
            轴运动状态，1：有运动，0：未运动
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ProgMoveStatus">
            <summary>
            程序运行状态，1：有运行，0：未运行
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ProgLoadStatus">
            <summary>
            程序加载状态，1：有加载，0：无加载
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ProgHoldStatus">
            <summary>
            程序暂停状态，1：有暂停，0：无暂停
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ModeStatus">
            <summary>
            模式状态，1:手动，2:自动，3:远程
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.SpeedStatus">
            <summary>
            读读状态，百分比（单位）
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.IoDOut">
            <summary>
            IoDOut状态
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.IoDIn">
            <summary>
            IoDIn状态
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.IoIOut">
            <summary>
            IoIOut状态
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.IoIIn">
            <summary>
            IoIIn状态
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ProjectName">
            <summary>
            加载工程名
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ProgramName">
            <summary>
            加载程序名
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.ErrorText">
            <summary>
            错误信息
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbAxisPos">
            <summary>
            一到七轴的角度
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbCartPos">
            <summary>
            X,Y,Z,A,B,C方向，也叫笛卡尔坐标系
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbAxisSpeed">
            <summary>
            一到七轴的速度
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbAxisAcc">
            <summary>
            一到七轴的加速度
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbAxisAccAcc">
            <summary>
            一到七轴的加加速度
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbAxisTorque">
            <summary>
            一到七轴的力矩
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbAxisDirCnt">
            <summary>
            轴反向计数
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbAxisTime">
            <summary>
            轴工作总时长
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.DbDeviceTime">
            <summary>
            设备开机总时长
            </summary>
        </member>
        <member name="P:Communication.Robot.EFORT.EfortData.PacketEnd">
            <summary>
            报文结束标记
            </summary>
        </member>
        <member name="M:Communication.Robot.EFORT.EfortData.PraseFromPrevious(System.Byte[])">
            <summary>
            从之前的版本数据构造一个埃夫特机器人的数据类型
            </summary>
            <param name="data">真实的数据内容</param>
            <returns>转换的结果内容</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.EfortData.PraseFrom(System.Byte[])">
            <summary>
            从新版本数据构造一个埃夫特机器人的数据类型
            </summary>
            <param name="data">真实的数据内容</param>
            <returns>转换的结果内容</returns>
        </member>
        <member name="T:Communication.Robot.EFORT.ER7BC10">
            <summary>
            埃夫特机器人对应型号为ER7B-C10，此协议为定制版，使用前请测试
            </summary>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的对象，并指定IP地址和端口号，端口号通常为8008
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.GetReadCommand">
            <summary>
            获取发送的消息的命令
            </summary>
            <returns>字节数组命令</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.Read(System.String)">
            <summary>
            读取埃夫特机器人的原始的字节数据信息，该地址参数是没有任何作用的，随便填什么
            </summary>
            <param name="address">无效参数</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.ReadString(System.String)">
            <summary>
            读取机器人的所有的数据信息，返回JSON格式的数据对象，地址参数无效
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.Write(System.String,System.Byte[])">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.Write(System.String,System.String)">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.ReadEfortData">
            <summary>
            读取机器人的详细信息，返回解析后的数据类型
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Robot.EFORT.ER7BC10Previous">
            <summary>
            埃夫特机器人对应型号为ER7B-C10，此协议为旧版的定制版，使用前请测试
            </summary>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的对象，并指定IP地址和端口号，端口号通常为8008
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.GetReadCommand">
            <summary>
            获取发送的消息的命令
            </summary>
            <returns>字节数组命令</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.Read(System.String)">
            <summary>
            读取埃夫特机器人的原始的字节数据信息，该地址参数是没有任何作用的，随便填什么
            </summary>
            <param name="address">无效参数</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.ReadString(System.String)">
            <summary>
            读取机器人的所有的数据信息，返回JSON格式的数据对象，地址参数无效
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.Byte[])">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.String)">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.ReadEfortData">
            <summary>
            读取机器人的详细信息
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:Communication.Robot.EFORT.ER7BC10Previous.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Robot.KUKA.KukaAvarProxyNet">
            <summary>
            Kuka机器人的数据交互对象，通讯支持的条件为KUKA 的 KRC4 控制器中运行KUKAVARPROXY 这个第三方软件，端口通常为7000
            </summary>
            <remarks>
            非常感谢 昆山-LT 网友的测试和意见反馈。
            </remarks>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的Kuka机器人对象，并指定IP地址和端口号，端口号通常为7000
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.Read(System.String)">
            <summary>
            读取埃夫特机器人的原始的字节数据信息，该地址参数是没有任何作用的，随便填什么
            </summary>
            <param name="address">无效参数</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.ReadString(System.String)">
            <summary>
            读取机器人的所有的数据信息，返回JSON格式的数据对象，地址参数无效
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.Byte[])">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.String)">
            <summary>
            本机器人支持该方法操作，根据实际的值记性返回
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.PackCommand(System.Byte[])">
            <summary>
            将核心的指令打包成一个可用于发送的消息对象
            </summary>
            <param name="commandCore">核心命令</param>
            <returns>最终实现的可以发送的机器人的字节数据</returns>
        </member>
        <member name="M:Communication.Robot.KUKA.KukaAvarProxyNet.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:Communication.Robot.YASKAWA.YRC1000TcpNet">
            <summary>
            安川机器人的Ethernet 服务器功能的通讯类
            </summary>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.Read(System.String)">
            <summary>
            根据地址读取机器人的原始的字节数据信息
            </summary>
            <param name="address">指定的地址信息，对于某些机器人无效</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.ReadString(System.String)">
            <summary>
            根据地址读取机器人的字符串的数据信息
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.Write(System.String,System.Byte[])">
            <summary>
            根据地址，来写入设备的相关的数据
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.Write(System.String,System.String)">
            <summary>
            根据地址，来写入设备相关的数据
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            before read data , the connection should be Initialized
            </summary>
            <param name="socket">connected socket</param>
            <returns>whether is the Initialization is success.</returns>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            重写父类的数据交互方法，接收的时候采用标识符来接收
            </summary>
            <param name="socket">套接字</param>
            <param name="send">发送的数据</param>
            <returns>发送结果对象</returns>
        </member>
        <member name="M:Communication.Robot.YASKAWA.YRC1000TcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.String)">
            <summary>
            Read string value from socket
            </summary>
            <param name="socket">connected socket</param>
            <param name="send">string value</param>
            <returns>received string value with is successfully</returns>
        </member>
        <member name="T:Communication.Serial.SoftCRC16">
            <summary>
            用于CRC16验证的类，提供了标准的验证方法
            </summary>
            <remarks>
            本类提供了几个静态的方法，用来进行CRC16码的计算和验证的，多项式码可以自己指定配置，但是预置的寄存器为0xFF 0xFF
            </remarks>
            <example>
            先演示如何校验一串数据的CRC码
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Serial\SoftCRC16.cs" region="Example1" title="SoftCRC16示例" />
            然后下面是如何生成你自己的CRC校验码
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Serial\SoftCRC16.cs" region="Example2" title="SoftCRC16示例" />
            </example>
        </member>
        <member name="M:Communication.Serial.SoftCRC16.CheckCRC16(System.Byte[])">
            <summary>
            来校验对应的接收数据的CRC校验码，默认多项式码为0xA001
            </summary>
            <param name="value">需要校验的数据，带CRC校验码</param>
            <returns>返回校验成功与否</returns>
        </member>
        <member name="M:Communication.Serial.SoftCRC16.CheckCRC16(System.Byte[],System.Byte,System.Byte)">
            <summary>
            指定多项式码来校验对应的接收数据的CRC校验码
            </summary>
            <param name="value">需要校验的数据，带CRC校验码</param>
            <param name="CH">多项式码高位</param>
            <param name="CL">多项式码低位</param>
            <returns>返回校验成功与否</returns>
        </member>
        <member name="M:Communication.Serial.SoftCRC16.CRC16(System.Byte[])">
            <summary>
            获取对应的数据的CRC校验码，默认多项式码为0xA001
            </summary>
            <param name="value">需要校验的数据，不包含CRC字节</param>
            <returns>返回带CRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="M:Communication.Serial.SoftCRC16.CRC16(System.Byte[],System.Byte,System.Byte)">
            <summary>
            通过指定多项式码来获取对应的数据的CRC校验码
            </summary>
            <param name="value">需要校验的数据，不包含CRC字节</param>
            <param name="CL">多项式码地位</param>
            <param name="CH">多项式码高位</param>
            <returns>返回带CRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="T:Communication.Serial.SerialBase">
            <summary>
            所有串行通信类的基类，提供了一些基础的服务
            </summary>
        </member>
        <member name="M:Communication.Serial.SerialBase.#ctor">
            <summary>
            实例化一个无参的构造方法
            </summary>
        </member>
        <member name="M:Communication.Serial.SerialBase.SerialPortInni(System.String)">
            <summary>
            初始化串口信息，9600波特率，8位数据位，1位停止位，无奇偶校验
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
        </member>
        <member name="M:Communication.Serial.SerialBase.SerialPortInni(System.String,System.Int32)">
            <summary>
            初始化串口信息，波特率，8位数据位，1位停止位，无奇偶校验
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:Communication.Serial.SerialBase.SerialPortInni(System.String,System.Int32,System.Int32,System.IO.Ports.StopBits,System.IO.Ports.Parity)">
            <summary>
            初始化串口信息，波特率，数据位，停止位，奇偶校验需要全部自己来指定
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
            <param name="dataBits">数据位</param>
            <param name="stopBits">停止位</param>
            <param name="parity">奇偶校验</param>
        </member>
        <member name="M:Communication.Serial.SerialBase.SerialPortInni(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            根据自定义初始化方法进行初始化串口信息
            </summary>
            <param name="initi">初始化的委托方法</param>
        </member>
        <member name="M:Communication.Serial.SerialBase.Open">
            <summary>
            打开一个新的串行端口连接
            </summary>
        </member>
        <member name="M:Communication.Serial.SerialBase.IsOpen">
            <summary>
            获取一个值，指示串口是否处于打开状态
            </summary>
            <returns>是或否</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.Close">
            <summary>
            关闭端口连接
            </summary>
        </member>
        <member name="M:Communication.Serial.SerialBase.ReadBase(System.Byte[])">
            <summary>
            读取串口的数据
            </summary>
            <param name="send">发送的原始字节数据</param>
            <returns>带接收字节的结果对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.ClearSerialCache">
            <summary>
            清除串口缓冲区的数据，并返回该数据，如果缓冲区没有数据，返回的字节数组长度为0
            </summary>
            <returns>是否操作成功的方法</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.CheckReceiveBytes(System.Byte[])">
            <summary>
            检查当前接收的字节数据是否正确的
            </summary>
            <param name="rBytes">输入字节</param>
            <returns>检查是否正确</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.InitializationOnOpen">
            <summary>
            在打开端口时的初始化方法，按照协议的需求进行必要的重写
            </summary>
            <returns>是否初始化成功</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.ExtraOnClose">
            <summary>
            在将要和服务器进行断开的情况下额外的操作，需要根据对应协议进行重写
            </summary>
            <returns>当断开连接时额外的操作结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.SPSend(System.IO.Ports.SerialPort,System.Byte[])">
            <summary>
            发送数据到串口里去
            </summary>
            <param name="serialPort">串口对象</param>
            <param name="data">字节数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.SPReceived(System.IO.Ports.SerialPort,System.Boolean)">
            <summary>
            从串口接收一串数据信息，可以指定是否一定要接收到数据
            </summary>
            <param name="serialPort">串口对象</param>
            <param name="awaitData">是否必须要等待数据返回</param>
            <returns>结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialBase.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="P:Communication.Serial.SerialBase.LogNet">
            <summary>
            当前的日志情况
            </summary>
        </member>
        <member name="P:Communication.Serial.SerialBase.ReceiveTimeout">
            <summary>
            接收数据的超时时间，默认5000ms
            </summary>
        </member>
        <member name="P:Communication.Serial.SerialBase.SleepTime">
            <summary>
            连续串口缓冲数据检测的间隔时间，默认20ms
            </summary>
        </member>
        <member name="P:Communication.Serial.SerialBase.IsClearCacheBeforeRead">
            <summary>
            是否在发送数据前清空缓冲数据，默认是false
            </summary>
        </member>
        <member name="T:Communication.Serial.SerialDeviceBase`1">
            <summary>
            基于串口的设备交互类的对象，需要从本类继承，然后实现不同的设备读写操作。
            </summary>
            <typeparam name="TTransform">数据解析的规则泛型</typeparam>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.#ctor">
            <summary>
            默认的构造方法实现的设备信息
            </summary>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Read(System.String,System.UInt16)">
            <summary>
            从设备读取原始数据
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Byte[])">
            <summary>
            将原始数据写入设备
            </summary>
            <param name="address">起始地址</param>
            <param name="value">原始数据</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>需要在继承类中重写实现，并且实现地址解析操作</remarks>
        </member>
        <member name="P:Communication.Serial.SerialDeviceBase`1.WordLength">
            <summary>
            单个数据字节的长度，西门子为2，三菱，欧姆龙，modbusTcp就为1
            </summary>
            <remarks>对设备来说，一个地址的数据对应的字节数，或是1个字节或是2个字节</remarks>
        </member>
        <member name="P:Communication.Serial.SerialDeviceBase`1.ByteTransform">
            <summary>
            当前客户端的数据变换机制，当你需要从字节数据转换类型数据的时候需要。
            </summary>
            <example>
            主要是用来转换数据类型的，下面仅仅演示了2个方法，其他的类型转换，类似处理。
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ByteTransform" title="ByteTransform示例" />
            </example>
        </member>
        <member name="P:Communication.Serial.SerialDeviceBase`1.ConnectionId">
            <summary>
            当前连接的唯一ID号，默认为长度20的guid码加随机数组成，方便列表管理，也可以自己指定
            </summary>
            <remarks>
            Current Connection ID, conclude guid and random data, also, you can spcified
            </remarks>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadCustomer``1(System.String)">
            <summary>
            读取自定义类型的数据，需要规定解析规则
            </summary>
            <typeparam name="T">类型名称</typeparam>
            <param name="address">起始地址</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的ByteTransform实例，才能调用该方法。
            </remarks>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.WriteCustomer``1(System.String,``0)">
            <summary>
            写入自定义类型的数据到设备去，需要规定生成字节的方法
            </summary>
            <typeparam name="T">自定义类型</typeparam>
            <param name="address">起始地址</param>
            <param name="data">实例对象</param>
            <returns>带有成功标识的结果对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的<see cref="T:Communication.IDataTransfer"/>实例，才能调用该方法。
            </remarks>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadInt16(System.String)">
            <summary>
            读取设备的short类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取设备的short类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadUInt16(System.String)">
            <summary>
            读取设备的ushort数据类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取设备的ushort类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadInt32(System.String)">
            <summary>
            读取设备的int类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取设备的int类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadUInt32(System.String)">
            <summary>
            读取设备的uint类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取设备的uint类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadFloat(System.String)">
            <summary>
            读取设备的float类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取设备的float类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadInt64(System.String)">
            <summary>
            读取设备的long类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取设备的long类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadUInt64(System.String)">
            <summary>
            读取设备的ulong类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取设备的ulong类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadDouble(System.String)">
            <summary>
            读取设备的double类型的数据
            </summary>
            <param name="address">起始地址</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取设备的double类型的数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ReadString(System.String,System.UInt16)">
            <summary>
            读取设备的字符串数据，编码为ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="length">地址长度</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Int16[])">
            <summary>
            向设备中写入short数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Int16)">
            <summary>
            向设备中写入short数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.UInt16[])">
            <summary>
            向设备中写入ushort数组，返回是否写入成功
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.UInt16)">
            <summary>
            向设备中写入ushort数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Int32[])">
            <summary>
            向设备中写入int数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Int32)">
            <summary>
            向设备中写入int数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.UInt32[])">
            <summary>
            向设备中写入uint数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.UInt32)">
            <summary>
            向设备中写入uint数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Single[])">
            <summary>
            向设备中写入float数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Single)">
            <summary>
            向设备中写入float数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Int64[])">
            <summary>
            向设备中写入long数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Int64)">
            <summary>
            向设备中写入long数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.UInt64[])">
            <summary>
            向P设备中写入ulong数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.UInt64)">
            <summary>
            向设备中写入ulong数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Double[])">
            <summary>
            向设备中写入double数组，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="values">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.Double)">
            <summary>
            向设备中写入double数据，返回是否写入成功
            </summary>
            <param name="address">数据地址</param>
            <param name="value">实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="Communication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.Write(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为ASCII
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.WriteUnicodeString(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.WriteUnicodeString(System.String,System.String,System.Int32)">
            <summary>
            向设备中写入指定长度的字符串,超出截断，不够补0，编码格式为Unicode
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <param name="length">指定的字符串长度，必须大于0</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:Communication.Serial.SerialDeviceBase`1.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串数据</returns>
        </member>
        <member name="T:Communication.Serial.SoftLRC">
            <summary>
            用于LRC验证的类，提供了标准的验证方法
            </summary>
        </member>
        <member name="M:Communication.Serial.SoftLRC.LRC(System.Byte[])">
            <summary>
            获取对应的数据的LRC校验码
            </summary>
            <param name="value">需要校验的数据，不包含LRC字节</param>
            <returns>返回带LRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="M:Communication.Serial.SoftLRC.CheckLRC(System.Byte[])">
            <summary>
            检查对应的数据是否符合LRC的验证
            </summary>
            <param name="value">等待校验的数据，是否正确</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="T:Communication.StringResources">
            <summary>
            系统的字符串资源及多语言管理中心 ->
            System string resource and multi-language management Center
            </summary>
        </member>
        <member name="F:Communication.StringResources.Language">
            <summary>
            获取或设置系统的语言选项 ->
            Gets or sets the language options for the system
            </summary>
        </member>
        <member name="M:Communication.StringResources.SetLanguageChinese">
            <summary>
            将语言设置为中文 ->
            Set the language to Chinese
            </summary>
        </member>
        <member name="M:Communication.StringResources.SeteLanguageEnglish">
            <summary>
            将语言设置为英文 ->
            Set the language to English
            </summary>
        </member>
        <member name="T:Communication.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.abstr1">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.abstr11">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Activity_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.AddressViewer">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.alipay">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.asset_progressBar_24x24_on">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.asset_progressBar_24x24_on1">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.AudioRecording">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.brackets_Square_16xMD">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Class_489">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.ClassIcon">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Cloud_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Copy_6524">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Delegate_8339">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.docview_xaml_on_16x16">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Enum_582">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Event_594">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Event_594_exp">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.glasses_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.grid_Data_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.lightningBolt_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.ListView_687">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Method_636">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.mm_facetoface_collect_qrcode_1525331158525">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Module_648">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.PropertyIcon">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.qrcode_for_gh_319218678954_258">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Soundfile_461">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Structure_507">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.TabControl_707">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Table_748">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Tag_7213">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.Textfile_818_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.TreeView_713">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.usbcontroller">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.UseCaseDiagramFile_usecasediagram_13447_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.VirtualMachine">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.WebFormTemplate_11274_16x_color">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Communication.Properties.Resources.WindowsForm_817_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
    </members>
</doc>
